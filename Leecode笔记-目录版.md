#### Table of contents
(toc generated by [ghtoc](https://github.com/sk1418/ghtoc))
- [待解决的问题](#待解决的问题)
- [记忆化搜索](#记忆化搜索)
- [kmp](#kmp)
- [分治法+16进制掩码解决二进制数分组问题：LC190/LC191](#分治法+16进制掩码解决二进制数分组问题：LC190/LC191)
- [DP解决LC-524.通过删除字母匹配到字典里最长单词](#DP解决LC-524.通过删除字母匹配到字典里最长单词)
- [DP解决LC-279.完全平方数](#DP解决LC-279.完全平方数)
- [对比-归并排序-LC315.计算右侧小于当前元素的个数]](#对比-归并排序-LC315.计算右侧小于当前元素的个数])
- [对比-归并排序-LC剑指Offer 51.数组中的逆序对]](#对比-归并排序-LC剑指Offer-51.数组中的逆序对])
- [牛顿迭代法解决LC69.x的平方根](#牛顿迭代法解决LC69.x的平方根)
- [并查集解决LC 695.岛屿的最大面积，顺便整理并查集模板](#并查集解决LC-695.岛屿的最大面积，顺便整理并查集模板)
- [字典树解决 LC 440.字典序的第K小数字 (字节常考题)](#字典树解决-LC-440.字典序的第K小数字-(字节常考题))
- [单调栈解决 剑指Offer 33.二叉搜索树的后序遍历序列](#单调栈解决-剑指Offer-33.二叉搜索树的后序遍历序列)
- [插入图片命令](#插入图片命令)
- [LeetCode刷题笔记](#LeetCode刷题笔记)
    - [一些数学知识](#一些数学知识)
- [利用 x & 0 = 0 和 x & 1 = x 的特点，可以实现掩码操作。一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask  的 1 部分相对应的位。](#利用-x-&-0-=-0-和-x-&-1-=-x-的特点，可以实现掩码操作。一个数-num-与-mask：00111100-进行位与操作，只保留-num-中与-mask--的-1-部分相对应的位。)
- [n&(n-1) 去除 n 的位级表示中最低的那一位 1。例如对于二进制表示 01011011，减去 1 得到 01011010，这两个数相与得到 01011010。](#n&(n-1)-去除-n-的位级表示中最低的那一位-1。例如对于二进制表示-01011011，减去-1-得到-01011010，这两个数相与得到-01011010。)
- [n&(-n) 得到 n 的位级表示中最低的那一位 1。-n 得到 n 的反码加 1，也就是 -n=~n+1。例如对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。](#n&(-n)-得到-n-的位级表示中最低的那一位-1。-n-得到-n-的反码加-1，也就是--n=~n+1。例如对于二进制表示-10110100，-n-得到-01001100，相与得到-00000100。)
    - [一些易混淆的点](#一些易混淆的点)
        - [求长度](#求长度)
        - [不同集合添加元素的方式](#不同集合添加元素的方式)
        - [不同集合删除元素的方式](#不同集合删除元素的方式)
        - [判断集合中是否包含某元素](#判断集合中是否包含某元素)
        - [判断字符串是否包括空格](#判断字符串是否包括空格)
    - [经验总结](#经验总结)
- [Kth问题可以用快排/堆排序/桶排序/BST解决](#Kth问题可以用快排/堆排序/桶排序/BST解决)
- [频率 + TopK问题：哈希表+桶排序](#频率-+-TopK问题：哈希表+桶排序)
- [双指针问题找到各自位置后进行处理，处理后一定要记得更新指针位置，不然会死循环；另外处处要先判断指针的合法性](#双指针问题找到各自位置后进行处理，处理后一定要记得更新指针位置，不然会死循环；另外处处要先判断指针的合法性)
- [二分的关键在于利用check()确认某一边肯定没问题](#二分的关键在于利用check()确认某一边肯定没问题)
- [如果只是要找到某一个结果是否存在，那么DFS会更高效。因为DFS会首先把一种可能的情况尝试到底，才会回溯去尝试下一种情况，只要找到一种情况，就可以返回了。但是BFS必须所有可能的情况同时尝试，在找到一种满足条件的结果的同时，也尝试了很多不必要的路径；](#如果只是要找到某一个结果是否存在，那么DFS会更高效。因为DFS会首先把一种可能的情况尝试到底，才会回溯去尝试下一种情况，只要找到一种情况，就可以返回了。但是BFS必须所有可能的情况同时尝试，在找到一种满足条件的结果的同时，也尝试了很多不必要的路径；)
- [如果是要找所有可能结果中最短的，那么BFS回更高效。因为DFS是一种一种的尝试，在把所有可能情况尝试完之前，无法确定哪个是最短，所以DFS必须把所有情况都找一遍，才能确定最终答案（DFS的优化就是剪枝，不剪枝很容易超时）。而BFS从一开始就是尝试所有情况，所以只要找到第一个达到的那个点，那就是最短的路径，可以直接返回了，其他情况都可以省略了，所以这种情况下，BFS更高效。](#如果是要找所有可能结果中最短的，那么BFS回更高效。因为DFS是一种一种的尝试，在把所有可能情况尝试完之前，无法确定哪个是最短，所以DFS必须把所有情况都找一遍，才能确定最终答案（DFS的优化就是剪枝，不剪枝很容易超时）。而BFS从一开始就是尝试所有情况，所以只要找到第一个达到的那个点，那就是最短的路径，可以直接返回了，其他情况都可以省略了，所以这种情况下，BFS更高效。)
- [Java中Math.min()和Math.max()不支持三个元素取最值，可以通过套娃实现：Math.min(Math.min(a, b), c); 更多个的话同理。](#Java中Math.min()和Math.max()不支持三个元素取最值，可以通过套娃实现：Math.min(Math.min(a,-b),-c);-更多个的话同理。)
    - [Java基础语法](#Java基础语法)
        - [Java数据类型中String、Integer、int相互间的转换](#Java数据类型中String、Integer、int相互间的转换)
        - [Collections工具类](#Collections工具类)
        - [String](#String)
        - [StringBuffer](#StringBuffer)
        - [Array](#Array)
        - [List](#List)
        - [Map](#Map)
        - [ArrayDeque](#ArrayDeque)
        - [Stack](#Stack)
        - [Queue](#Queue)
        - [Heap](#Heap)
        - [BitSet](#BitSet)
        - [Java数据类型取值范围](#Java数据类型取值范围)
    - [模板总结](#模板总结)
        - [重写排序比较器](#重写排序比较器)
        - [反转链表](#反转链表)
        - [获取链表的中点](#获取链表的中点)
        - [删除有序链表中重复的元素（重复的元素仅保留一个）](#删除有序链表中重复的元素（重复的元素仅保留一个）)
        - [删除有序链表中重复的元素（重复的元素不保留）](#删除有序链表中重复的元素（重复的元素不保留）)
        - [判断回文字符串](#判断回文字符串)
        - [二分查找](#二分查找)
        - [二叉树的高度](#二叉树的高度)
        - [计算树的节点个数](#计算树的节点个数)
        - [判断两棵树是不是相同的树](#判断两棵树是不是相同的树)
        - [BFS](#BFS)
        - [递归三部曲](#递归三部曲)
        - [回溯的框架](#回溯的框架)
        - [前、中、后序遍历树](#前、中、后序遍历树)
        - [统计二进制中1的个数](#统计二进制中1的个数)
        - [双指针](#双指针)
        - [快速排序](#快速排序)
        - [归并与归并排序](#归并与归并排序)
        - [生成平方数](#生成平方数)
        - [并查集](#并查集)
        - [单调栈](#单调栈)
        - [滑动窗口](#滑动窗口)
    - [手撕数据结构系列](#手撕数据结构系列)
        - [用数组实现堆](#用数组实现堆)
        - [用栈实现队列](#用栈实现队列)
        - [用队列实现栈](#用队列实现栈)
    - [题解](#题解)
    - [数据结构部分](#数据结构部分)
        - [LC [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)](#LC-[160.-相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/))
        - [对比: LC [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)](#对比:-LC-[剑指-Offer-52.-两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/))
        - [**LC [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)](#**LC-[206.-反转链表](https://leetcode-cn.com/problems/reverse-linked-list/))
        - [LC [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)](#LC-[21.-合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/))
        - [对比：合并两个有序数组](#对比：合并两个有序数组)
        - [LC [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)](#LC-[83.-删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/))
        - [对比：LC [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)](#对比：LC-[82.-删除排序链表中的重复元素-II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/))
        - [LC [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)](#LC-[19.-删除链表的倒数第-N-个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/))
        - [LC [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)](#LC-[24.-两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/))
        - [LC [445. 两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/)](#LC-[445.-两数相加-II](https://leetcode-cn.com/problems/add-two-numbers-ii/))
        - [LC [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)](#LC-[234.-回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/))
        - [对比：LC  [680. 验证回文字符串 Ⅱ](https://leetcode-cn.com/problems/valid-palindrome-ii/)](#对比：LC--[680.-验证回文字符串-Ⅱ](https://leetcode-cn.com/problems/valid-palindrome-ii/))
        - [LC [725. 分隔链表](https://leetcode-cn.com/problems/split-linked-list-in-parts/)](#LC-[725.-分隔链表](https://leetcode-cn.com/problems/split-linked-list-in-parts/))
        - [LC [328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)](#LC-[328.-奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/))
        - [LC [283. 移动零到数组的末尾](https://leetcode-cn.com/problems/move-zeroes/)](#LC-[283.-移动零到数组的末尾](https://leetcode-cn.com/problems/move-zeroes/))
        - [LC [566. 重塑矩阵](https://leetcode-cn.com/problems/reshape-the-matrix/)](#LC-[566.-重塑矩阵](https://leetcode-cn.com/problems/reshape-the-matrix/))
        - [LC [485. 最大连续 1 的个数](https://leetcode-cn.com/problems/max-consecutive-ones/)](#LC-[485.-最大连续-1-的个数](https://leetcode-cn.com/problems/max-consecutive-ones/))
        - [LC [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)](#LC-[240.-搜索二维矩阵-II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/))
        - [LC [378. 有序矩阵中第 K 小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)](#LC-[378.-有序矩阵中第-K-小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/))
        - [LC [645. 错误的集合](https://leetcode-cn.com/problems/set-mismatch/)](#LC-[645.-错误的集合](https://leetcode-cn.com/problems/set-mismatch/))
        - [对比： LC [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)-位运算](#对比：-LC-[136.-只出现一次的数字](https://leetcode-cn.com/problems/single-number/)-位运算)
        - [对比： LC [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)-位运算](#对比：-LC-[137.-只出现一次的数字-II](https://leetcode-cn.com/problems/single-number-ii/)-位运算)
        - [对比 LC 260. [只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)-位运算](#对比-LC-260.-[只出现一次的数字-III](https://leetcode-cn.com/problems/single-number-iii/)-位运算)
        - [LC [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)](#LC-[287.-寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/))
        - [LC [667. 优美的排列 II](https://leetcode-cn.com/problems/beautiful-arrangement-ii/)](#LC-[667.-优美的排列-II](https://leetcode-cn.com/problems/beautiful-arrangement-ii/))
        - [LC [697. 数组的度](https://leetcode-cn.com/problems/degree-of-an-array/)](#LC-[697.-数组的度](https://leetcode-cn.com/problems/degree-of-an-array/))
        - [LC [766. 托普利茨矩阵](https://leetcode-cn.com/problems/toeplitz-matrix/)](#LC-[766.-托普利茨矩阵](https://leetcode-cn.com/problems/toeplitz-matrix/))
        - [LC [565. 数组嵌套](https://leetcode-cn.com/problems/array-nesting/)](#LC-[565.-数组嵌套](https://leetcode-cn.com/problems/array-nesting/))
        - [LC [769. 最多能完成排序的块](https://leetcode-cn.com/problems/max-chunks-to-make-sorted/)](#LC-[769.-最多能完成排序的块](https://leetcode-cn.com/problems/max-chunks-to-make-sorted/))
        - [LC [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)](#LC-[232.-用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/))
        - [LC [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)](#LC-[225.-用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/))
        - [LC [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)](#LC-[155.-最小栈](https://leetcode-cn.com/problems/min-stack/))
        - [LC [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)](#LC-[20.-有效的括号](https://leetcode-cn.com/problems/valid-parentheses/))
        - [LC [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)](#LC-[739.-每日温度](https://leetcode-cn.com/problems/daily-temperatures/))
        - [LC [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)](#LC-[503.-下一个更大元素-II](https://leetcode-cn.com/problems/next-greater-element-ii/))
        - [LC [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)](#LC-[104.-二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/))
        - [LC [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)](#LC-[110.-平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/))
        - [LC [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)](#LC-[543.-二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/))
        - [LC [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)](#LC-[226.-翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/))
        - [LC [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)](#LC-[617.-合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/))
        - [LC [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)](#LC-[112.-路径总和](https://leetcode-cn.com/problems/path-sum/))
        - [LC [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)](#LC-[437.-路径总和-III](https://leetcode-cn.com/problems/path-sum-iii/))
        - [[总结文章：一篇文章解决所有二叉树路径问题](https://leetcode-cn.com/problems/path-sum-iii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-smch/)](#[总结文章：一篇文章解决所有二叉树路径问题](https://leetcode-cn.com/problems/path-sum-iii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-smch/))
        - [LC [572. 另一棵树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)](#LC-[572.-另一棵树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/))
            - [待续 kmp](#待续-kmp)
        - [方法二：深度优先搜索序列上做KMP串匹配](#方法二：深度优先搜索序列上做KMP串匹配)
        - [对比 LC [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)](#对比-LC-[100.-相同的树](https://leetcode-cn.com/problems/same-tree/))
        - [LC [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)](#LC-[101.-对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/))
        - [LC [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)](#LC-[111.-二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/))
        - [LC [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)](#LC-[404.-左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/))
        - [LC [687. 最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path/)](#LC-[687.-最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path/))
        - [LC [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)](#LC-[337.-打家劫舍-III](https://leetcode-cn.com/problems/house-robber-iii/))
        - [LC [671. 二叉树中第二小的节点](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/)](#LC-[671.-二叉树中第二小的节点](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/))
        - [LC [637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)](#LC-[637.-二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/))
        - [LC [513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)](#LC-[513.-找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/))
        - [LC [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)](#LC-[144.-二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/))
        - [LC [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)](#LC-[145.-二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/))
        - [LC [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)](#LC-[94.-二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/))
        - [LC [669. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)](#LC-[669.-修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/))
        - [LC [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)](#LC-[230.-二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/))
        - [LC [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)](#LC-[538.-把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/))
        - [LC [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)](#LC-[235.-二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/))
        - [LC [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)](#LC-[108.-将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/))
        - [LC [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)](#LC-[109.-有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/))
        - [LC [653. 两数之和 IV - 输入 BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)](#LC-[653.-两数之和-IV---输入-BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/))
        - [LC [530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)](#LC-[530.-二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/))
        - [LC [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)](#LC-[501.-二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/))
        - [LC [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)](#LC-[208.-实现-Trie-(前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/))
        - [LC [677. 键值映射](https://leetcode-cn.com/problems/map-sum-pairs/)](#LC-[677.-键值映射](https://leetcode-cn.com/problems/map-sum-pairs/))
        - [对比：LC [440. 字典序的第K小数字](https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/)](#对比：LC-[440.-字典序的第K小数字](https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/))
        - [LC [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)](#LC-[242.-有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/))
        - [LC [409. 最长回文串](https://leetcode-cn.com/problems/longest-palindrome/)](#LC-[409.-最长回文串](https://leetcode-cn.com/problems/longest-palindrome/))
        - [LC [205. 同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/)](#LC-[205.-同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/))
        - [LC [647. 统计字符串中回文子串的数目](https://leetcode-cn.com/problems/palindromic-substrings/)](#LC-[647.-统计字符串中回文子串的数目](https://leetcode-cn.com/problems/palindromic-substrings/))
        - [对比：LC [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)](#对比：LC-[5.-最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/))
        - [LC [9. 判断回文数](https://leetcode-cn.com/problems/palindrome-number/)](#LC-[9.-判断回文数](https://leetcode-cn.com/problems/palindrome-number/))
        - [LC [696. 计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings/)](#LC-[696.-计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings/))
        - [LC [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)](#LC-[1.-两数之和](https://leetcode-cn.com/problems/two-sum/))
        - [LC [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)](#LC-[217.-存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/))
        - [LC [594. 最长和谐子序列](https://leetcode-cn.com/problems/longest-harmonious-subsequence/)](#LC-[594.-最长和谐子序列](https://leetcode-cn.com/problems/longest-harmonious-subsequence/))
        - [LC [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)](#LC-[128.-最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/))
        - [LC [785. 判断二分图](https://leetcode-cn.com/problems/is-graph-bipartite/)](#LC-[785.-判断二分图](https://leetcode-cn.com/problems/is-graph-bipartite/))
        - [LC [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)](#LC-[207.-课程表](https://leetcode-cn.com/problems/course-schedule/))
        - [LC [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)](#LC-[210.-课程表-II](https://leetcode-cn.com/problems/course-schedule-ii/))
        - [LC [684. 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)](#LC-[684.-冗余连接](https://leetcode-cn.com/problems/redundant-connection/))
        - [LC [461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)](#LC-[461.-汉明距离](https://leetcode-cn.com/problems/hamming-distance/))
        - [LC [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)](#LC-[136.-只出现一次的数字](https://leetcode-cn.com/problems/single-number/))
        - [LC [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)](#LC-[268.-丢失的数字](https://leetcode-cn.com/problems/missing-number/))
        - [LC [260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)](#LC-[260.-只出现一次的数字-III](https://leetcode-cn.com/problems/single-number-iii/))
        - [LC [190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)](#LC-[190.-颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/))
        - [LC [面试题 16.01. 交换数字](https://leetcode-cn.com/problems/swap-numbers-lcci/)](#LC-[面试题-16.01.-交换数字](https://leetcode-cn.com/problems/swap-numbers-lcci/))
        - [LC [231. 2 的幂](https://leetcode-cn.com/problems/power-of-two/)](#LC-[231.-2-的幂](https://leetcode-cn.com/problems/power-of-two/))
        - [LC [342. 4的幂](https://leetcode-cn.com/problems/power-of-four/)](#LC-[342.-4的幂](https://leetcode-cn.com/problems/power-of-four/))
        - [LC [693. 交替位二进制数](https://leetcode-cn.com/problems/binary-number-with-alternating-bits/)](#LC-[693.-交替位二进制数](https://leetcode-cn.com/problems/binary-number-with-alternating-bits/))
        - [LC [476. 数字的补数](https://leetcode-cn.com/problems/number-complement/)](#LC-[476.-数字的补数](https://leetcode-cn.com/problems/number-complement/))
        - [LC [371. 两整数之和](https://leetcode-cn.com/problems/sum-of-two-integers/)](#LC-[371.-两整数之和](https://leetcode-cn.com/problems/sum-of-two-integers/))
        - [LC [318. 最大单词长度乘积](https://leetcode-cn.com/problems/maximum-product-of-word-lengths/)](#LC-[318.-最大单词长度乘积](https://leetcode-cn.com/problems/maximum-product-of-word-lengths/))
        - [LC [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)](#LC-[338.-比特位计数](https://leetcode-cn.com/problems/counting-bits/))
    - [算法思想部分](#算法思想部分)
    - [双指针](#双指针)
        - [LC [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)](#LC-[167.-两数之和-II---输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/))
        - [LC [633. 平方数之和](https://leetcode-cn.com/problems/sum-of-square-numbers/)](#LC-[633.-平方数之和](https://leetcode-cn.com/problems/sum-of-square-numbers/))
        - [LC [345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)](#LC-[345.-反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/))
        - [LC [680. 验证回文字符串 Ⅱ](https://leetcode-cn.com/problems/valid-palindrome-ii/)](#LC-[680.-验证回文字符串-Ⅱ](https://leetcode-cn.com/problems/valid-palindrome-ii/))
        - [LC [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)](#LC-[88.-合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/))
        - [LC [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)](#LC-[141.-环形链表](https://leetcode-cn.com/problems/linked-list-cycle/))
        - [LC [524. 通过删除字母匹配到字典里最长单词](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/)](#LC-[524.-通过删除字母匹配到字典里最长单词](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/))
    - [排序](#排序)
        - [LC [912. 排序数组！](https://leetcode-cn.com/problems/sort-an-array/)](#LC-[912.-排序数组！](https://leetcode-cn.com/problems/sort-an-array/))
        - [对比-归并排序-LC [315. 计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)](#对比-归并排序-LC-[315.-计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/))
        - [对比-归并排序-LC [剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)](#对比-归并排序-LC-[剑指-Offer-51.-数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/))
        - [LC [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)](#LC-[215.-数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/))
        - [LC [75. 颜色分类-荷兰国旗颜色问题](https://leetcode-cn.com/problems/sort-colors/)](#LC-[75.-颜色分类-荷兰国旗颜色问题](https://leetcode-cn.com/problems/sort-colors/))
        - [LC [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)](#LC-[347.-前-K-个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/))
        - [LC [451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)](#LC-[451.-根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/))
    - [二分查找](#二分查找)
        - [LC [69. x 的平方根 ](https://leetcode-cn.com/problems/sqrtx/)](#LC-[69.-x-的平方根-](https://leetcode-cn.com/problems/sqrtx/))
        - [LC [744. 寻找比目标字母大的最小字母](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/)](#LC-[744.-寻找比目标字母大的最小字母](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/))
        - [LC [540. 有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)](#LC-[540.-有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/))
        - [LC [278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)](#LC-[278.-第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/))
        - [LC [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)](#LC-[153.-寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/))
        - [对比 [剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)](#对比-[剑指-Offer-11.-旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/))
        - [LC [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)](#LC-[34.-在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/))
    - [分治](#分治)
        - [LC [241. 为运算表达式设计优先级](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)](#LC-[241.-为运算表达式设计优先级](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/))
        - [LC [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)](#LC-[95.-不同的二叉搜索树-II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/))
    - [搜索](#搜索)
    - [-BFS](#-BFS)
        - [LC [1091. 二进制矩阵中的最短路径](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/)](#LC-[1091.-二进制矩阵中的最短路径](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/))
        - [LC [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)](#LC-[279.-完全平方数](https://leetcode-cn.com/problems/perfect-squares/))
        - [LC [127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)](#LC-[127.-单词接龙](https://leetcode-cn.com/problems/word-ladder/))
    - [-DFS](#-DFS)
        - [LC [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)](#LC-[695.-岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/))
        - [LC [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)](#LC-[200.-岛屿数量](https://leetcode-cn.com/problems/number-of-islands/))
        - [LC [547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)](#LC-[547.-省份数量](https://leetcode-cn.com/problems/number-of-provinces/))
        - [LC [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)](#LC-[130.-被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/))
        - [LC [417. 太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)](#LC-[417.-太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/))
    - [-回溯](#-回溯)
        - [LC [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)](#LC-[17.-电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/))
    - [DP](#DP)
- [剑指Offer部分](#剑指Offer部分)
    - [数组与矩阵](#数组与矩阵)
        - [[剑指 Offer 03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)](#[剑指-Offer-03.-数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/))
        - [[剑指 Offer 04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)](#[剑指-Offer-04.-二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/))
        - [[剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)](#[剑指-Offer-05.-替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/))
        - [[剑指 Offer 29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)](#[剑指-Offer-29.-顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/))
        - [剑指Offer-[面试题50. 第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)](#剑指Offer-[面试题50.-第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/))
    - [栈、队列、堆](#栈、队列、堆)
        - [[剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)](#[剑指-Offer-09.-用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/))
        - [[剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)](#[剑指-Offer-30.-包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/))
        - [[剑指 Offer 31. 通过栈的压入、弹出序列判断合法性](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)](#[剑指-Offer-31.-通过栈的压入、弹出序列判断合法性](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/))
        - [[剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)](#[剑指-Offer-40.-最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/))
        - [](#)
        - [[剑指 Offer 41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)](#[剑指-Offer-41.-数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/))
        - [[剑指Offer 41.1  字符流中第一个不重复的字符](https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=23448&ru=%2Fpractice%2F00de97733b8e4f97a3fb5c680ee10720&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&sourceUrl=)](#[剑指Offer-41.1--字符流中第一个不重复的字符](https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=23448&ru=%2Fpractice%2F00de97733b8e4f97a3fb5c680ee10720&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&sourceUrl=))
        - [[剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)](#[剑指-Offer-59---I.-滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/))
    - [双指针](#双指针)
        - [[剑指 Offer 57. 和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/)](#[剑指-Offer-57.-和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/))
        - [[剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)](#[剑指-Offer-57---II.-和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/))
        - [[剑指 Offer 58 - I. 翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)](#[剑指-Offer-58---I.-翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/))
        - [[剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)](#[剑指-Offer-58---II.-左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/))
        - [48题](#48题)
    - [链表](#链表)
        - [[剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)](#[剑指-Offer-06.-从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/))
        - [[剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)](#[剑指-Offer-18.-删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/))
        - [[剑指Offer 76. 删除链表中重复的结点-不保留](https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github)](#[剑指Offer-76.-删除链表中重复的结点-不保留](https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github))
        - [[剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)](#[剑指-Offer-22.-链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/))
        - [[剑指Offer 23. 链表中环的入口结点](https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github)](#[剑指Offer-23.-链表中环的入口结点](https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github))
        - [[剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)](#[剑指-Offer-24.-反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/))
        - [[剑指 Offer 25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)](#[剑指-Offer-25.-合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/))
        - [[剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)](#[剑指-Offer-52.-两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/))
        - [[剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)](#[剑指-Offer-35.-复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/))
    - [树](#树)
        - [[剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)](#[剑指-Offer-07.-重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/))
        - [[剑指 Offer 二叉树的下一个结点](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github)](#[剑指-Offer-二叉树的下一个结点](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github))
        - [[剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)](#[剑指-Offer-26.-树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/))
        - [[剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)](#[剑指-Offer-27.-二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/))
        - [[剑指 Offer 28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)](#[剑指-Offer-28.-对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/))
        - [[剑指 Offer 32 - II. 从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)](#[剑指-Offer-32---II.-从上到下打印二叉树-II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/))
        - [[剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)](#[剑指-Offer-32---III.-从上到下打印二叉树-III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/))
        - [[剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)](#[剑指-Offer-33.-二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/))
        - [[剑指 Offer 34. 二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)](#[剑指-Offer-34.-二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/))
        - [[剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)](#[剑指-Offer-36.-二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/))
        - [[剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)](#[剑指-Offer-54.-二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/))
        - [[剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)](#[剑指-Offer-55---I.-二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/))
        - [[剑指 Offer 55 - II. 平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)](#[剑指-Offer-55---II.-平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/))
        - [[剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)](#[剑指-Offer-68---II.-二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/))
        - [对比：LC [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)](#对比：LC-[235.-二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/))
    - [二分查找](#二分查找)
        - [[剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)](#[剑指-Offer-11.-旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/))
        - [[剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)](#[剑指-Offer-53---I.-在排序数组中查找数字-I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/))
    - [位运算](#位运算)
        - [[剑指 Offer 15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)](#[剑指-Offer-15.-二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/))
        - [[剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)](#[剑指-Offer-56---I.-数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/))
    - [分治](#分治)
        - [[剑指 Offer 16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)](#[剑指-Offer-16.-数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/))
    - [搜索](#搜索)
        - [[剑指 Offer 12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)](#[剑指-Offer-12.-矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/))
        - [[剑指 Offer 13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)](#[剑指-Offer-13.-机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/))
        - [[剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)](#[剑指-Offer-38.-字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/))
    - [排序](#排序)
    - [动态规划](#动态规划)
        - [[剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)](#[剑指-Offer-10--I.-斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/))
        - [[剑指 Offer 10- II. 青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)](#[剑指-Offer-10--II.-青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/))
        - [[剑指 Offer 71. 跳台阶扩展问题](https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github)](#[剑指-Offer-71.-跳台阶扩展问题](https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github))
        - [[剑指 Offer 70. 矩形覆盖](https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github)](#[剑指-Offer-70.-矩形覆盖](https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github))
        - [[剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)](#[剑指-Offer-42.-连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/))
        - [[剑指 Offer 47. 礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)](#[剑指-Offer-47.-礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/))
        - [[剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)](#[剑指-Offer-48.-最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/))
        - [[剑指 Offer 49. 丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)](#[剑指-Offer-49.-丑数](https://leetcode-cn.com/problems/chou-shu-lcof/))
        - [[剑指 Offer 60. n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/)](#[剑指-Offer-60.-n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/))
        - [[剑指 Offer 66. 构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)](#[剑指-Offer-66.-构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/))
    - [贪心思想](#贪心思想)
    - [数学](#数学)
        - [[剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)](#[剑指-Offer-39.-数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/))
        - [[剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)](#[剑指-Offer-62.-圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/))
        - [[剑指 Offer 43. 1～n 整数中 1 出现的次数](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/)](#[剑指-Offer-43.-1～n-整数中-1-出现的次数](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/))
- [参考题库](#参考题库)
    - [递归](#递归)
        - [LC-[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)](#LC-[70.-爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/))
        - [LC-[112. 路径总和](https://leetcode-cn.com/problems/path-sum/)](#LC-[112.-路径总和](https://leetcode-cn.com/problems/path-sum/))
        - [LC-[509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)](#LC-[509.-斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/))
    - [分治](#分治)
        - [LC-[23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)](#LC-[23.-合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/))
        - [[LC-169. 多数元素](https://leetcode-cn.com/problems/majority-element/)](#[LC-169.-多数元素](https://leetcode-cn.com/problems/majority-element/))
        - [(TODO)对比 LC-[229. 求众数 II](https://leetcode-cn.com/problems/majority-element-ii/)](#(TODO)对比-LC-[229.-求众数-II](https://leetcode-cn.com/problems/majority-element-ii/))
        - [LC-[240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)](#LC-[240.-搜索二维矩阵-II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/))
    - [单调栈](#单调栈)
        - [[739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)](#[739.-每日温度](https://leetcode-cn.com/problems/daily-temperatures/))
        - [[503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)](#[503.-下一个更大元素-II](https://leetcode-cn.com/problems/next-greater-element-ii/))
        - [[84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)](#[84.-柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/))
        - [[85. 矩阵中最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)](#[85.-矩阵中最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/))
    - [并查集](#并查集)
        - [LC-[547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)](#LC-[547.-省份数量](https://leetcode-cn.com/problems/number-of-provinces/))
        - [LC-[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)](#LC-[200.-岛屿数量](https://leetcode-cn.com/problems/number-of-islands/))
        - [LC-[684. 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)](#LC-[684.-冗余连接](https://leetcode-cn.com/problems/redundant-connection/))
    - [滑动窗口](#滑动窗口)
        - [LC-[209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)](#LC-[209.-长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/))
        - [LC -[3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)](#LC--[3.-无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/))
        - [LC-[1004. 最大连续1的个数 III](https://leetcode-cn.com/problems/max-consecutive-ones-iii/)](#LC-[1004.-最大连续1的个数-III](https://leetcode-cn.com/problems/max-consecutive-ones-iii/))
        - [LC-[1208. 尽可能使字符串相等](https://leetcode-cn.com/problems/get-equal-substrings-within-budget/)](#LC-[1208.-尽可能使字符串相等](https://leetcode-cn.com/problems/get-equal-substrings-within-budget/))
    - [前缀和](#前缀和)
        - [LC-[724. 寻找数组的中心下标](https://leetcode-cn.com/problems/find-pivot-index/)](#LC-[724.-寻找数组的中心下标](https://leetcode-cn.com/problems/find-pivot-index/))
        - [LC-[560. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)](#LC-[560.-和为-K-的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/))
        - [[437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)](#[437.-路径总和-III](https://leetcode-cn.com/problems/path-sum-iii/))
        - [[1248. 统计「优美子数组」](https://leetcode-cn.com/problems/count-number-of-nice-subarrays/)](#[1248.-统计「优美子数组」](https://leetcode-cn.com/problems/count-number-of-nice-subarrays/))
    - [差分](#差分)
        - [LC-[1094. 拼车](https://leetcode-cn.com/problems/car-pooling/)](#LC-[1094.-拼车](https://leetcode-cn.com/problems/car-pooling/))
        - [[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)](#[121.-买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/))
        - [[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)](#[122.-买卖股票的最佳时机-II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/))
    - [拓扑排序](#拓扑排序)
        - [LeetCode210](#LeetCode210)
    - [字符串](#字符串)
        - [LC-[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)](#LC-[5.-最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/))
        - [LC-[20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)](#LC-[20.-有效的括号](https://leetcode-cn.com/problems/valid-parentheses/))
        - [LC-[43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)](#LC-[43.-字符串相乘](https://leetcode-cn.com/problems/multiply-strings/))
        - [LC-[93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)](#LC-[93.-复原-IP-地址](https://leetcode-cn.com/problems/restore-ip-addresses/))
    - [二分查找](#二分查找)
        - [LC-[33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)](#LC-[33.-搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/))
        - [LC-[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)](#LC-[34.-在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/))
    - [BFS](#BFS)
        - [[127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)](#[127.-单词接龙](https://leetcode-cn.com/problems/word-ladder/))
        - [[139. 单词拆分](https://leetcode-cn.com/problems/word-break/)](#[139.-单词拆分](https://leetcode-cn.com/problems/word-break/))
        - [[130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)](#[130.-被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/))
        - [[529. 扫雷游戏](https://leetcode-cn.com/problems/minesweeper/)](#[529.-扫雷游戏](https://leetcode-cn.com/problems/minesweeper/))
        - [815(hard)](#815(hard))
    - [DFS&回溯](#DFS&回溯)
        - [LC-[78. 子集](https://leetcode-cn.com/problems/subsets/)](#LC-[78.-子集](https://leetcode-cn.com/problems/subsets/))
        - [LC-[934. 最短的桥](https://leetcode-cn.com/problems/shortest-bridge/)](#LC-[934.-最短的桥](https://leetcode-cn.com/problems/shortest-bridge/))
        - [685(hard)](#685(hard))
        - [1102（会员）](#1102（会员）)
        - [531（会员）](#531（会员）)
        - [533 （会员）](#533-（会员）)
        - [LC-[113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)](#LC-[113.-路径总和-II](https://leetcode-cn.com/problems/path-sum-ii/))
        - [332(hard)](#332(hard))
        - [LC [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)](#LC-[337.-打家劫舍-III](https://leetcode-cn.com/problems/house-robber-iii/))
    - [动态规划](#动态规划)
        - [LC-[213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)](#LC-[213.-打家劫舍-II](https://leetcode-cn.com/problems/house-robber-ii/))
        - [对比：LC-[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)](#对比：LC-[198.-打家劫舍](https://leetcode-cn.com/problems/house-robber/))
        - [123（hard）](#123（hard）)
        - [LC-[62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)](#LC-[62.-不同路径](https://leetcode-cn.com/problems/unique-paths/))
        - [LC-[63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)](#LC-[63.-不同路径-II](https://leetcode-cn.com/problems/unique-paths-ii/))
        - [361(会员)](#361(会员))
        - [1230(会员)](#1230(会员))
        - [LC-[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)](#LC-[300.-最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/))
    - [贪心算法](#贪心算法)
        - [LC-[55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)](#LC-[55.-跳跃游戏](https://leetcode-cn.com/problems/jump-game/))
        - [对比 LC-[45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)](#对比-LC-[45.-跳跃游戏-II](https://leetcode-cn.com/problems/jump-game-ii/))
        - [LC-[435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)](#LC-[435.-无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/))
        - [621](#621)
        - [452](#452)
    - [字典树](#字典树)
        - [LeetCode820](#LeetCode820)
        - [208](#208)
        - [648](#648)
- [SQL](#SQL)
    - [LC-175 组合两个表](#LC-175-组合两个表)
    - [LC-[176. 第二高的薪水](https://leetcode-cn.com/problems/second-highest-salary/)](#LC-[176.-第二高的薪水](https://leetcode-cn.com/problems/second-highest-salary/))
    - [LC-[177. 第N高的薪水](https://leetcode-cn.com/problems/nth-highest-salary/)](#LC-[177.-第N高的薪水](https://leetcode-cn.com/problems/nth-highest-salary/))
# 待解决的问题

~~~
# 记忆化搜索
f（problem p）{
    if(p has been solved){
         return the result
    }else{
         divide the p into some sub-problems (p1, p2, p3...)
         f(p1);
         f(p2);
         f(p3);
         ...
    }
# kmp
# 分治法+16进制掩码解决二进制数分组问题：LC190/LC191
# DP解决LC-524.通过删除字母匹配到字典里最长单词
# DP解决LC-279.完全平方数
# 对比-归并排序-LC315.计算右侧小于当前元素的个数]
# 对比-归并排序-LC剑指Offer 51.数组中的逆序对]  
# 牛顿迭代法解决LC69.x的平方根
# 并查集解决LC 695.岛屿的最大面积，顺便整理并查集模板
# 字典树解决 LC 440.字典序的第K小数字 (字节常考题)
# 单调栈解决 剑指Offer 33.二叉搜索树的后序遍历序列
~~~

# 插入图片命令

~~~
<img src="alg-img/.png" width="550px">
~~~

# LeetCode刷题笔记 

## 一些数学知识

~~~
x >> k //将（x）2右移k位，即删掉最后k位
x >> k & 1 //看x的第k位是0还是1
--------------
在计算机的运算中，“-”（前缀）运算表示各二制位取反再加1，也就是说 b = -a 在计算机内部是 b = ~a + 1 

-------位运算--------
1.异或
x ^ 0 = x    x ^ 1 = ~x   x ^ x = 0 
利用 x ^ 1 = ~x 的特点，可以将一个数的位级表示翻转；
利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。
2.与
x & 0 = 0    x & 1 = x    x & x = x 
# 利用 x & 0 = 0 和 x & 1 = x 的特点，可以实现掩码操作。一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask  的 1 部分相对应的位。
# n&(n-1) 去除 n 的位级表示中最低的那一位 1。例如对于二进制表示 01011011，减去 1 得到 01011010，这两个数相与得到 01011010。
01011011 &  
01011010
--------
01011010
# n&(-n) 得到 n 的位级表示中最低的那一位 1。-n 得到 n 的反码加 1，也就是 -n=~n+1。例如对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。
10110100 &
01001100
--------
00000100
3.或
x | 0 = x    x | 1 = 1    x | x = x
利用 x | 0 = x 和 x | 1 = 1 的特点，可以实现设值操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1。
4.移位运算
>> n 为算术右移(左边补1)，相当于除以 2n，例如 -7 >> 2 = -2。
11111111111111111111111111111001  >> 2
--------
11111111111111111111111111111110

>>> n 为无符号右移(左边补0)。例如 -7 >>> 2 = 1073741822。
11111111111111111111111111111001  >>> 2
--------
00111111111111111111111111111111

<< n 为算术左移(右边补0)，相当于乘以 2n。-7 << 2 = -28。
11111111111111111111111111111001  << 2
--------
11111111111111111111111111100100
5.mask计算
要获取 111111111，将 0 取反即可，~0。
要得到只有第 i 位为 1 的 mask，将 1 向左移动 i-1 位即可，1<<(i-1) 。例如 1<<4 得到只有第 5 位为 1 的 mask ：00010000。
要得到 1 到 i 位为 1 的 mask，(1<<i)-1 即可，例如将 (1<<4)-1 = 00010000-1 = 00001111。
要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~((1<<i)-1)。
6.Java 中的位操作
static int Integer.bitCount();           // 统计1的数量
static int Integer.highestOneBit(int x);      // 获得小于x的最大2次幂 --> 最高位1保留，其他位设为0
static String Integer.toBinaryString(int i);     // 转换为二进制表示的字符串
6.lowbit运算
Lowbit(x):返回x的二进制表示中的最后一位1到最后   x & (-x) == x & (~x+1)
若x = 1010, 则返回(10)-->2
---------------
2^31 --> 10000000...0(31个0)
小于2^31 --> 最大是1111111.....1(31个1)
                  |这里的最高位是符号位
Integer.MIN_VALUE:1000 0000 0000 0000 0000 0000 0000 0000  --> -2^31     
Integer.MAX_VALUE:0111 1111 1111 1111 1111 1111 1111 1111  -->  2^31-1  2147483647
Integer.MAX_VALUE + 1 = Integer.MIN_VALUE
Math.abs(Integer.MIN_VALUE) =  Integer.MIN_VALUE


~~~

## 一些易混淆的点

### 求长度

~~~java
// 字符串s的长度：s.length()
// 数组nums[]的长度：nums.length
// 队列qu的长度：qu.size()
// 链表list的长度：list.size()
//// 集合类的都是size()
~~~

### 不同集合添加元素的方式

~~~java
// 集合set：set.add()
// list: list.add()
// map： map.put()
// queue: qu.add()/qu.offer()
~~~

### 不同集合删除元素的方式

~~~JAVA
//queue: qu.poll()
~~~

### 判断集合中是否包含某元素

~~~java
// Map
map.containsKey()
// Set
set.contains();
// List
list.contains();  // 判断元素是否在 arraylist
list.containsAll();  // 查看 arraylist 是否包含指定集合中的所有元素
~~~

### 判断字符串是否包括空格

~~~java
if (s.trim().isEmpty())
~~~



## 经验总结

~~~
# Kth问题可以用快排/堆排序/桶排序/BST解决
# 频率 + TopK问题：哈希表+桶排序
# 双指针问题找到各自位置后进行处理，处理后一定要记得更新指针位置，不然会死循环；另外处处要先判断指针的合法性
# 二分的关键在于利用check()确认某一边肯定没问题
# 如果只是要找到某一个结果是否存在，那么DFS会更高效。因为DFS会首先把一种可能的情况尝试到底，才会回溯去尝试下一种情况，只要找到一种情况，就可以返回了。但是BFS必须所有可能的情况同时尝试，在找到一种满足条件的结果的同时，也尝试了很多不必要的路径；
# 如果是要找所有可能结果中最短的，那么BFS回更高效。因为DFS是一种一种的尝试，在把所有可能情况尝试完之前，无法确定哪个是最短，所以DFS必须把所有情况都找一遍，才能确定最终答案（DFS的优化就是剪枝，不剪枝很容易超时）。而BFS从一开始就是尝试所有情况，所以只要找到第一个达到的那个点，那就是最短的路径，可以直接返回了，其他情况都可以省略了，所以这种情况下，BFS更高效。
# Java中Math.min()和Math.max()不支持三个元素取最值，可以通过套娃实现：Math.min(Math.min(a, b), c); 更多个的话同理。
~~~



## Java基础语法

### Java数据类型中String、Integer、int相互间的转换

~~~
1.Integer转换成int的方法
Integer i = new Integer(10); 
int k = i.intValue();
即Integer.intValue();

2.int转换成Integer
int i = 10;
Integer it = new Integer(i);

3.String转换成int的方法
String str = "10";    
即：int i = Integer.parseInt(str)

4.int转换成String
int i = 10;
(1)String s = String.valueOf(i);
(2)String s = Ingeger.toString(i);
(3)String s = "" + i;

5.String转换成Integer
String str = "10";
Integer it = Integer.valueOf(str);

6.Integer转换成String
Integer it = new Integer(10);
String str = it.toString();

7.char转int
int x = num1.charAt(i) - '0';

8.int转char
char ch = (char)('0' + cnt);
~~~

### Collections工具类

~~~java
import java.util.Collections;
Collections.reverse(nums);
Collections.sort(nums);
Collections.sort(nums, new Comparator() {
    @Override
    public int compare(Object o1, Object o2) {
        // TODO Auto-generated method stub
        String s1 = String.valueOf(o1);
        String s2 = String.valueOf(o2);
        return s1.compareTo(s2);
    }
});
Collections.shuffle(nums);
/**
void reverse(List list)：反转
void shuffle(List list),随机排序
void sort(List list),按自然排序的升序排序
void sort(List list, Comparator c);定制排序，由Comparator控制排序逻辑
void swap(List list, int i , int j),交换两个索引位置的元素
int max(Collection coll),根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)
int max(Collection coll, Comparator c)，根据定制排序，返回最大元素。类比int min(Collection coll, Comparator c)
void fill(List list, Object obj),用元素obj填充list中所有元素
int frequency(Collection c, Object o)，统计元素出现次数
boolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素。
void rotate(List list, int distance),旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。
int binarySearch(List list, Object key), 对List进行二分查找，返回索引，注意List必须是有序的
int indexOfSubList(List list, List target), 统计targe在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).
*/
~~~



### String

~~~java
//
public int indexOf(int ch)  // 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。
public int indexOf(int ch, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。
int indexOf(String str): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。
int indexOf(String str, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。
//
String.valueOf(char[] data)  // 返回 char 数组参数的字符串表示形式。
new String(char[] arr)   // 返回 char 数组参数的字符串表示形式。
String.valueOf(int i)  //返回 int 参数的字符串表示形式。
//    
str1.compareTo(str2);  
// 其返回的是一个int类型值。
// 若Str1等于参数字符串Str2字符串，则返回0；
// 若该Str1按字典顺序小于参数字符串Str2，则返回值小于0；	
// 若Str1按字典顺序大于参数字符串Str2，则返回值大于0。
String str =s.toLowerCase();  // 将所有大写字母替换成小写
String str =s.toUpperCase();  // 将所有大写字母替换成小写
String str = str.replaceAll(s,"")  // 将字符串中的所有s子串替换为空格
// 返回一个新字符串，用给定的定界符连接所有元素
public static String join(CharSequence delimiter, CharSequence... elements)  
//  第1个参数是分隔符，第2个参数是需要进行拼接的元素，可以是多个字符串，可以是字符串数组，可以是字符串队列,只要是字符序列都行
String[] strArray = new String[]{"ni","zhen","hao","kan"};
List<String> strList = new ArrayList<String>();
String a = String.join("!",strArray);
//第2个参数是字符串队列
String b = String.join("!",strList);
//第1个参数之后是多个字符串
String c = String.join("!","ni","zhen","hao","kan");
~~~

### StringBuffer

~~~java
StringBuffer stringBuffer=new StringBuffer ();
stringBuffer.append("aaa,");
stringBuffer.deleteCharAt(stringBuffer.length() - 1);  // 删除最后一位
stringBuffer.length();
stringBuffer.toString();
~~~



### Array

基础语法：

~~~java
// 初始化
Arrays.fill(next, -1);
// 集合 –> 数组: (无法转成int[])
list.toArray()
// return res.stream().mapToInt(Integer::intValue).toArray();  // 一维int[]
Integer[] array = list.toArray(new Integer[list.size()]);//能正确运行
int[] array = list.toArray(new int[list.size()]); //不能正确运行
// return res.toArray(new int[res.size()][]);  // 二维list转int[][]数组
// 数组 –> 集合: 
Arrays.asList(T...t)
//默认的从小到大排序
Arrays.sort(int[] a);
//指定起点和终点，从小到大排序
Arrays.sort(int[] a, int fromIndex, int toIndex);  //左闭右开
//字符串 -> 字符数组
// String s;
s.toCharArray();
//字符数组->字符串
String.valueOf(char[] data)
new String(char[] arr)
//字符数组也可以排序！
Arrays.sort(char[] s);
//比较数组的内容是否相同
Arrays.equals(s, t);
~~~

数组排序：

~~~java
//默认的从小到大排序
Arrays.sort(int[] a);
//指定起点和终点，从小到大排序
Arrays.sort(int[] a, int fromIndex, int toIndex);  //左闭右开
//从大到小排序(需要传入一个重写的比较器)
import java.util.Arrays;
import java.util.Comparator;
public class Main {
public static void main(String[] args) {
	//注意，要想改变默认的排列顺序，不能使用基本类型（int,double, char）, 要使用它们对应的包裹类型
	Integer[] a = {9, 8, 7, 2, 3, 4, 1, 0, 6, 5};
	//定义一个自定义类MyComparator的对象
	Comparator cmp = new MyComparator();
	Arrays.sort(a, cmp);
 }

 class MyComparator implements Comparator<Integer>{
     @Override
     public int compare(Integer o1, Integer o2) {
         //如果n1小于n2，我们就返回正值，如果n1大于n2我们就返回负值，
         //这样颠倒一下，就可以实现反向排序了
        if (o1 < o2) return 1;
        else if (o1 > o2) return -1;
        else return 0;
    }
 }
~~~

Arrays.asList()的坑:		

~~~java
/**
用此方法得到的List的长度是不可改变的，
当你向这个List添加或删除一个元素时（例如 list.add("d");）, 程序就会抛出异常（java.lang.UnsupportedOperationException）。 
asList()方法的实现：
**/
public static <T> List<T> asList(T... a) {
    return new ArrayList<>(a);
}
//当你看到这段代码时可能觉得没啥问题啊，不就是返回了一个ArrayList对象吗？问题就出在这里, 这个ArrayList不是java.util包下的，而是java.util.Arrays.ArrayList, 它是Arrays类自己定义的一个静态内部类，这个内部类没有实现add()、remove()方法，而是直接使用它的父类AbstractList的相应方法。而AbstractList中的add()和remove()是直接抛出java.lang.UnsupportedOperationException异常的！
public void add(int index, E element) { throw new UnsupportedOperationException();}
public E remove(int index) {throw new UnsupportedOperationException();}
//总结：如果你的List只是用来遍历，就用Arrays.asList(), 如果你的List还要添加或删除元素，还是乖乖地new一个java.util.ArrayList，然后一个一个的添加元素。
~~~



### List

基础语法：

~~~java
//  LinkedList 实现了Queue的接口
/**  常用：add() poll() remove() peek() isEmpty()
add        增加一个元索                     如果队列已满，则抛出一个IIIegaISlabEepeplian异常
remove   移除并返回队列头部的元素    如果队列为空，则抛出一个NoSuchElementException异常
element  返回队列头部的元素             如果队列为空，则抛出一个NoSuchElementException异常

** admitted
offer       添加一个元素并返回true       如果队列已满，则返回false
poll         移除并返问队列头部的元素    如果队列为空，则返回null
peek       返回队列头部的元素             如果队列为空，则返回null

put         添加一个元素                      如果队列满，则阻塞
take        移除并返回队列头部的元素     如果队列为空，则阻塞

1、offer()和add()的区别
add()和offer()都是向队列中添加一个元素。但是如果想在一个满的队列中加入一个新元素，调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false。可以据此在程序中进行有效的判断！

2、peek()和element()的区别
peek()和element()都将在不移除的情况下返回队头，但是peek()方法在队列为空时返回null，调用element()方法会抛出NoSuchElementException异常。

3、poll()和remove()的区别
poll()和remove()都将移除并且返回对头，但是在poll()在队列为空时返回null，而remove()会抛出NoSuchElementException异常。

**/
~~~



### Map

基础语法：

~~~java
// 当Map集合中有这个key时，就使用这个key对应的value值，如果没有就使用默认值defaultValue
getOrDefault(Object key, V defaultValue)
~~~

### ArrayDeque

~~~markdown
`ArrayDeque`是`Deque`接口的一个实现，使用了可变数组，所以没有容量上的限制。同时，`ArrayDeque`是线程不安全的，在没有外部同步的情况下，不能再多线程环境下使用。`ArrayDeque`是`Deque`的实现类，可以作为栈来使用，效率高于`Stack`；也可以作为队列来使用，效率高于`LinkedList`。需要注意的是，`ArrayDeque`不支持`null`值。
1.添加元素
        addFirst(E e)在数组前面添加元素
        addLast(E e)在数组后面添加元素
        offerFirst(E e) 在数组前面添加元素，并返回是否添加成功
        offerLast(E e) 在数组后天添加元素，并返回是否添加成功
  2.删除元素
        removeFirst()删除第一个元素，并返回删除元素的值,如果元素为null，将抛出异常
        pollFirst()删除第一个元素，并返回删除元素的值，如果元素为null，将返回null
        removeLast()删除最后一个元素，并返回删除元素的值，如果为null，将抛出异常
        pollLast()删除最后一个元素，并返回删除元素的值，如果为null，将返回null
        removeFirstOccurrence(Object o) 删除第一次出现的指定元素
        removeLastOccurrence(Object o) 删除最后一次出现的指定元素
   3.获取元素
        getFirst() 获取第一个元素,如果没有将抛出异常
        getLast() 获取最后一个元素，如果没有将抛出异常
 -----------------------------------------------------
    4.队列操作
        add(E e) 在队列尾部添加一个元素
        offer(E e) 在队列尾部添加一个元素，并返回是否成功
        remove() 删除队列中第一个元素，并返回该元素的值，如果元素为null，将抛出异常(其实底层调用的是removeFirst())
        poll()  删除队列中第一个元素，并返回该元素的值,如果元素为null，将返回null(其实调用的是pollFirst())
        element() 获取第一个元素，如果没有将抛出异常
        peek() 获取第一个元素，如果队列为空返回null
 -----------------------------------------------------
    5.栈操作
        push(E e) 栈顶添加一个元素
        peek() 获取栈顶元素，如果栈为空返回null
        pop(E e) 移除栈顶元素,如果栈顶没有元素将抛出异常
 -----------------------------------------------------
    6.其他
        size() 获取队列中元素个数
        isEmpty() 判断队列是否为空
        iterator() 迭代器，从前向后迭代
        descendingIterator() 迭代器，从后向前迭代
        contain(Object o) 判断队列中是否存在该元素
        toArray() 转成数组
        clear() 清空队列
        clone() 克隆(复制)一个新的队列
        
   Deque<Integer> stackL = new ArrayDeque<Integer>();
~~~



### Stack

~~~java
public class StackDemo {
 
    static void showpush(Stack<Integer> st, int a) {
        st.push(new Integer(a));
        System.out.println("push(" + a + ")");
        System.out.println("stack: " + st);
    }
 
    static void showpop(Stack<Integer> st) {
        System.out.print("pop -> ");
        Integer a =  (Integer) st.pop();
        System.out.println(a);
        System.out.println("stack: " + st);
    }
 
    public static void main(String args[]) {
        Stack<Integer> st = new Stack<Integer>();
        System.out.println("stack: " + st);
        showpush(st, 42);
        showpush(st, 66);
        showpush(st, 99);
        showpop(st);
        showpop(st);
        showpop(st);
        try {
            showpop(st);
        } catch (EmptyStackException e) {
            System.out.println("empty stack");
        }
    }
}
~~~

### Queue

~~~java
Queue<TreeNode> queue = new LinkedList<>();


// 双端队列不能用多态的方式写声明
LinkedList<Integer> dequeue = new LinkedList<>();
queue.addLast(node.val); // 从队列尾部入队
queue.addFirst(node.val); // 从队列头部入队

~~~



### Heap

~~~java


/** 堆 */
// 默认是小根堆
Queue<Integer> heap = new PriorityQueue<>();

// 重写比较器，创建一个大根堆
// 大根堆写法1：
Queue<Integer> heap = new PriorityQueue<>(new Comparator<Integer>(){
    @Override
    public int compare(Integer o1, Integer o2){
        return o1 > o2 ? -1 : 1;
        /* e.g., return o1.compare(o2); */
    }
});
// 大根堆写法2：
Queue<Integer> heap = new PriorityQueue<>((o1, o2) -> {
    return o2 - o1;
});
// 大根堆写法3：
Queue<Integer> heap = new PriorityQueue<>((x, y) -> (y - x));  // lambda表达式简化写法
~~~

### BitSet

~~~java
//一个Bitset类创建一种特殊类型的数组来保存位值
BitSet bits1 = new BitSet(16);
// 将指定索引处的位设置为 true。
void set(int index)
//将指定索引处的位设置为指定的值
void set(int index, boolean v)
//返回指定索引处的位值。
boolean get(int index)
//如果此 BitSet 中没有包含任何设置为 true 的位，则返回 true。
boolean isEmpty( )
// 返回此 BitSet 的"逻辑大小"：BitSet 中最高设置位的索引加 1。
int length( )
// 返回第一个设置为 true 的位的索引，这发生在指定的起始索引或之后的索引上。
int nextSetBit(int startIndex)
返回第一个设置为 false 的位的索引，这发生在指定的起始索引或之后的索引上。
int nextClearBit(int startIndex)
~~~





### Java数据类型取值范围

~~~
一、基本数据类型的特点，位数，最大值和最小值。
1、
基本类型：short 二进制位数：16
包装类：java.lang.Short
最小值：Short.MIN_VALUE=-32768 （-2的15此方）
最大值：Short.MAX_VALUE=32767 （2的15次方-1）
2、
基本类型：int 二进制位数：32
包装类：java.lang.Integer
最小值：Integer.MIN_VALUE= -2147483648 （-2的31次方）
最大值：Integer.MAX_VALUE= 2147483647  （2的31次方-1）
3、
基本类型：long 二进制位数：64
包装类：java.lang.Long
最小值：Long.MIN_VALUE=-9223372036854775808 （-2的63次方）
最大值：Long.MAX_VALUE=9223372036854775807 （2的63次方-1）
4、
基本类型：float 二进制位数：32
包装类：java.lang.Float
最小值：Float.MIN_VALUE=1.4E-45 （2的-149次方）
最大值：Float.MAX_VALUE=3.4028235E38 （2的128次方-1）
5、
基本类型：double 二进制位数：64
包装类：java.lang.Double
最小值：Double.MIN_VALUE=4.9E-324 （2的-1074次方）
最大值：Double.MAX_VALUE=1.7976931348623157E308 （2的1024次方-1）
~~~



-------------------------------------------------------------------------------------------------------------------



## 模板总结

### 重写排序比较器

~~~java
new Comparator<int[]>(){
    @Override
    public int compare(int[] pair1, int[] pair2) {
        return pair1[1] > pair2[1] ? -1 : 1;  // 大顶堆
        return pair1[1] < pair2[1] ? -1 : 1;  // 小顶堆
}
/**
o1 < o2 ? -1 : 1  --> 递增  -->  o1 - o2
o1 > o2 ? -1 : 1  --> 递减  -->  o2 - o1
*/
~~~



### 反转链表

~~~java
public ListNode reverseList(ListNode head) {
    if (head == null) return null;
    ListNode pre = null, cur = head;
    ListNode tmp = null;  //要用一个临时节点来存放cur下一个节点的地址 不然cur.next连到前面后原本下一个节点就丢失了
    while (cur != null) {
        tmp = cur.next; // 注意这里哦！
        cur.next = pre;
        pre = cur;
        cur = tmp;
    }
    return pre;
}
public ListNode reverseList2(ListNode pre, ListNode cur) {
    if (cur == null) return pre;
    ListNode tmp = cur.next;  //要用一个临时节点来存放cur下一个节点的地址 不然cur.next连到前面后原本下一个节点就丢失了
    cur.next = pre;
    return reverseList2(cur, tmp);
}
~~~

### 获取链表的中点

~~~java
// p1一次走一步，p2一次走两步  将链表分为前后两部分
// 若链表长度为偶数，前后一样长；若为奇数，中间一个节点不用考虑，前后还是一样长

// 获取链表的中点(奇数) 或 前半部分的最后一个(偶数)  --> 下面统称为中点
// [-10,-3,1,5,9] --> 1
// [-10,-3,0,1,5,9] --> 0
public ListNode endOfFirstHalf(ListNode head) {
    ListNode slow = head, fast = head.next;
    while(fast != null && fast.next != null){
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;  //返回前半部分的终点
}
// 将链表分成两部分 返回中点的后一个元素
// [-10,-3,1,5,9] --> 5
// [-10,-3,0,1,5,9] --> 1
public ListNode startOfSecondHalf(ListNode head) {
    ListNode slow = head, fast = head.next;
    while(fast != null && fast.next != null){
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow.next;  //返回后半部分的起点
}
// 将链表分成两部分 返回中点的前一个元素
// [-10,-3,1,5,9] --> -3
// [-10,-3,0,1,5,9] --> -3
public ListNode preMid(ListNode head) {
    ListNode slow = head, fast = head.next;
    ListNode pre = head;
    while (fast != null && fast.next != null) {
        pre = slow;
        slow = slow.next;
        fast = fast.next.next;
    }
    return pre;
}
~~~

### 删除有序链表中重复的元素（重复的元素仅保留一个）

~~~java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode pre = dummy, cur = head;
        while (cur != null) {
            if (cur.next != null && cur.next.val == cur.val) {
                while (cur.next != null && cur.next.val == cur.val) {
                    cur = cur.next;
                }
                // cur = cur.next;  // 与不保留重读==重复元素那题唯一的区别！！！
                pre.next = cur;
            } else {
                pre = cur;
                cur = cur.next;
            }
        }
        return dummy.next;
    }
}
~~~

### 删除有序链表中重复的元素（重复的元素不保留）

~~~java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode pre = dummy, cur = head;
        while (cur != null) {
            if (cur.next != null && cur.next.val == cur.val) {
                while (cur.next != null && cur.next.val == cur.val) {
                    cur = cur.next;
                }
                cur = cur.next;  // 与保留一个元素那题唯一的区别！！！
                pre.next = cur;
            } else {
                pre = cur;
                cur = cur.next;
            }
        }
        return dummy.next;
    }
}
~~~



### 判断回文字符串

~~~java
public boolean validPalindrome(String s, int i, int j) {
    for (int low = i, high = j; low < high; low++, high--) {
        if (s.charAt(low) != s.charAt(high)){
            return false;
        }
    }
    return true; 
    // while( i < j && s.charAt(i) == s.charAt(j)){
    //     i++;
    //     j--;
    // } 
    // return i >= j;  //若i>=j,说明顺利的遍历完了,说明都符合条件
}
~~~

### 二分查找

~~~java
/**
1.mid可以根据实际情境设计
2.check()是核心，规范了二分的边界，
**/

boolean check(int x) {/* ... */} // 检查x是否满足某种性质

// 相同条件下取左边 --> 答案在左边区间
// 这里的mid要向下去整，因为在只有两个数的时候，如果向上取整的话mid就等于r，那么下一轮r = mid更新的话l就没动了，陷入了死循环。
// [l, mid], [mid + 1, r]
// 偶数情况下mid取左边
int bsearch_1(int l, int r) {
    while (l < r) {
        int mid = l + r >> 1; //mid属于左边  
        // int mid = l + (r - l) / 2;
        if (check(mid)) l = mid + 1;    // 不把mid包进去
        else r = mid;  // check()判断mid是否满足性质，答案(边界点)在左边[l,mid]中
    }
    return l;
}
// 相同条件下取右边 --> 答案在右边区间
// 这里的mid要向上去整，因为在只有两个数的时候，如果向下取整的话mid就等于l，那么下一轮l = mid更新的话l就没动了，陷入了死循环。
// [l, mid - 1], [mid, r]
// 偶数情况下mid取右边
int bsearch_2(int l, int r) {
    while (l < r) {
        int mid = l + r + 1 >> 1; //mid属于右边
        // int mid = l + (r - l + 1) / 2;
        if (check(mid)) l = mid; //答案(边界点)在右边[mid,r]中  // 把mid包进去
        else r = mid - 1;
    }
    return l;
}

/**
上述两种二分方式的区分方法：  (往右跳的时候把不把mid包括进去)
check()会将所有数/情况分成两个不想交的集合，当mid满足其中一个条件(比如小于目标)使得下一轮要检测右边的区间时，若mid有可能是正确答案而被包括在右边新的检测区间里，则应该选第二种，否则选第一种
*/

// 单调有序重复序列的二分查找：
while (ll <= rr) {
    int mid = ll + ((rr - ll) >> 1);
    if (nums[mid] == target) return mid;
    if (nums[mid] > target) rr = mid - 1;
    else ll = mid + 1;
}
~~~

### 二叉树的高度

~~~java
public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}

//常用套路：
class Solution {
    private int res = xxx;
    public int Method(TreeNode root) {
        maxDepth(root);
        return res;
    }
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        int l = maxDepth(root.left);
        int r = maxDepth(root.right);
        res = xxx;  //在深度遍历过程中更新题目需要知道的状态/答案
        /**
        Eg:
        res = Math.max(res, l + r);
        if (Math.abs(l - r) > 1) res =  false;
        ...
        **/
        return Math.max(l, r) + 1;
    }
}
~~~

### 计算树的节点个数

~~~java
public int count(TreeNode root){
    if (root == null) return 0;
    return 1 + count(root.left) + count(root.right);
}
~~~

### 判断两棵树是不是相同的树

~~~java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) return true;
        if (p == null || q == null) return false;
        if (p.val != q.val) return false;
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
~~~

### BFS

~~~java
class Solution {
    public void bfs(TreeNode root) {
        if (root == null) return;
        Queue<TreeNode> qu = new LinkedList<TreeNode>();
        // Set<String> visited = new HashSet<>(); 通常要有个visited集合或数组来做标记 起到了剪枝的效果
        qu.add(root);
        while(!qu.isEmpty()){
            //len++; //若要求路径长度之类的 应在这里处理
            //下一层有几个元素
            int size = qu.size();
            //这样保证一层的元素在一批弹出操作  如果不需要一层的节点统一操作，可以省去
            for (int i = 0; i < size; i ++) {
                TreeNode tmp = qu.remove();
                /**  
                处理当前节点(判断合法性等)
                */
                // 将相邻节点加入队列
                if (tmp.left != null) qu.add(tmp.left);
                if (tmp.right != null) qu.add(tmp.right);
            }
        }
    }
}

class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        // 特判
        /**
        if (!wordList.contains(endWord)) return 0;
        */
        Queue<String> qu = new LinkedList<>();
        qu.offer(beginWord);
        Set<String> visited = new HashSet<>();
        // BFS一般用来求类似最短路径的问题
        int len = 1;
        while (!qu.isEmpty()) {
            // 获取当前层节点个数
            int size = qu.size();
            // 遍历当前层所有节点
            for (int i = 0; i < size; i++) {
                // 取出一个
                String curWord = qu.poll();
                // 遍历其所有邻节点
                for (String word : wordList) {
                    // 对邻节点进行处理或判断
                    /**
                    if (visited.contains(word)) continue;
                    if (!onlyOneCheck(word, curWord)) continue;
                    if (word.equals(endWord)) return len + 1;  // 在下一层遇到了解
                    */
                    // 将符合条件的邻节点加入队列并标记已访问过
                    qu.add(word);
                    visited.add(word);
                }
            }
            // 开始下一层
            len ++;
        }
        return 0;
    }
}
~~~

### 递归三部曲

~~~
1.确定递归函数的参数以及返回值
2.确定终止条件
3.确定单层递归的逻辑
~~~

### 回溯的框架

~~~java
// 结果集
T[] result = []
public void backtrack(路径, 候选集) {  // 路径(已选的), 候选集(可以由多个参数构成)
    // 递归出口
    if (满足条件) {  
        res.add(路径);
        return;
    }
    for (选择 : 候选集) {
        做选择，将选择加入当前路径
        backtrack(路径, 新的候选集);
        撤销选择  // 这里撤销的就是上上步加入路径的元素，因为后面的递归退出的时候都把后面加入的选择给撤销了
    }
}
// eg:
public void backtrack(StringBuffer sb, String digits, int index) {
    if (sb.length() == digits.length()) {
        res.add(sb.toString());
        return;
    }
    String str = map[digits.charAt(index) - '0'];  // 2 : abc
    for (char ch : str.toCharArray()) {
        sb.append(ch);
        backtrack(sb, digits, index + 1);
        sb.deleteCharAt(sb.length() - 1);
    }
}
~~~



### 前、中、后序遍历树

~~~java
public void preOrder(TreeNode root, List<Integer> list) {
    if (root == null) return;
    list.add(root.val);
    preOrder(root.left, list);
    preOrder(root.right, list);
}
public void inOrder(TreeNode root, List<Integer> list) {
    if (root == null) return;
    inOrder(root.left, list);
    list.add(root.val);
    inOrder(root.right, list);
}
public void postOrder(TreeNode root, List<Integer> list) {
    if (root == null) return;
    postOrder(root.left, list);
    postOrder(root.right, list);
    list.add(root.val);
}
~~~

### 统计二进制中1的个数

~~~java
public int bitCount(int x) {
    int cnt = 0;
    while (x != 0) {
        if ((x & 1) == 1) cnt ++;
        x = x >> 1;
    }
	return cnt;
}
// 或者直接调用API： Integer.bitCount(x)
~~~



### 双指针

~~~java
while (i < j) {
    while (i < arr.length && (!list.contains(arr[i]))) i++;
    while (j >= 0 && (!list.contains(arr[j]))) j--;
    if (i < j) {
        char tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
        // important!!!!
        i++;
        j--;
    }
}
~~~



### 快速排序

-   思路：先对整串做一次划分，返回归位的元素下标，然后对归位元素两边的子串分别做快排。

~~~java
public void quickSort(int[] nums, int left, int right) {
    // 先调用partition函数使得某元素归位, 再递归地排序归位元素的左边和右边
    if (right <= left) {
        return;
    }
    int partition_index = partitionRandom(nums, left, right);
    partitionRandom(nums, left, partition_index - 1);
    partitionRandom(nums, partition_index + 1, right);
}
public int partitionRandom(int[] nums, int left, int right) {
    int randomIndex = left + new Random().nextInt(right - left + 1);
    swap(nums, randomIndex, left);
    return partition(nums, left, right);
}
public int partition(int[] nums, int left, int right) {
    // 归位nums[left, right] 范围内的某一个元素, 一般归位的是nums[left], 不过也可以随机化归位元素(将那个随机的元素换个left位置即可)
    // 返回归位元素的下标 index
    int pivot_index = left;
    int pivot = nums[pivot_index];
    while (left < right) {
        while (left < right && nums[right] >= pivot)
            right--;
        while (left < right && nums[left] <= pivot)
            left++;
        if (left < right)
            swap(nums, left, right);
    }
    swap(nums, pivot_index, left);
    return left;
}
public void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
~~~

### 归并与归并排序

~~~java
// 数组归并模板
public void mergeTempl(int[] nums1, int l1, int r1, int[] nums2, int l2, int r2) {
    int i = l1;
    int j = l2;
    int cnt = (r1 - l1 + 1) + (r2 - l2 + 1);
    int[] nums = new int[cnt];
    int idx = 0;
    while (i <= r1 && j <= r2) {
        if (nums1[i] <= nums2[j]) nums[idx++] = nums1[i++];
        else nums[idx++] = nums2[j++];
    }
    while (i <= r1) nums[idx++] = nums1[i++];
    while (j <= r2) nums[idx++] = nums2[j++];
    // 视返回值要求将归并后的结果归位
    // 这题是要用nums1[]接结果 如果带返回值，则可以直接返回nums[]
    for (int k = 0; k < cnt; k++) {
        nums1[k + l1] = nums[k];
    }
}
// 链表归并模板 - 遍历
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode p1 = l1;
        ListNode p2 = l2;
        ListNode head = new ListNode(-1);
        ListNode p = head;
        while (p1 != null && p2 != null) {
            if (p1.val <= p2.val) {
                p.next = p1;
                p = p.next;
                p1 = p1.next;
            }
            else {
                p.next = p2;
                p = p.next;
                p2 = p2.next;
            }
        }
        while (p1 != null) {
            p.next = p1;
            p = p.next;
            p1 = p1.next;
        }
        while (p2 != null) {
            p.next = p2;
            p = p.next;
            p2 = p2.next;
        }
        return head.next;

    }
}
// 链表归并模板 - 递归
private ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1,l2.next);
            return l2;
        }
    }
// 归并排序模板
public void mergeSort(int[] nums, int l, int r) {
    if (l >= r) return;
    int mid = (l + r) >>> 1;
    mergeSort(nums, l, mid);
    mergeSort(nums, mid + 1, r);
    mergeTempl(nums, l, mid, nums, mid + 1, r);
}
~~~

### 生成平方数

~~~java
public List<Integer> generateSquares(int n) {
    List<Integer> squares = new ArrayList<>();
    int square = 1;
    int diff = 3;
    while (square <= n) {
        squares.add(square);
        square += diff;
        diff += 2;
    }
    return squares;
}
~~~

### 并查集

~~~java
int[] father;
for (int i = 0; i < n; i++) {
    father[i] = i;  // 初始化 自己指向自己
}
public int find(int a) {
    while (father[a] != a) a = father[a];
    return a;
}
public void union (int a, int b) {   // 将a的根节点挂到b的根节点上
    father[find(a)] = find(b); 
}
~~~

### 单调栈

-   套路：先把边界值压入栈；外层while循环控制遍历的边界；内层压入一个元素前，先根据要求的单调性将栈内与当前元素冲突的元素全部出栈，然后根据栈顶元素（一般就是下一个最大/最小的元素）和当前元素的位置关系得到相应的结果（如相隔天数）（这里一般要判断这一趟操作后栈是不是空了，若空了要做特殊处理，比如温度那题，若栈空了说明后面的天里没有温度更高的，因此将它对应的结果设为0）；然后再把当前元素压入栈。

~~~java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        Stack<Integer> stack = new Stack<>();
        int[] res = new int[n];
        stack.push(n - 1);
        for (int i = n - 1; i >= 0; i--) {
            // 将小于等于今天温度的全都出栈
            while (!stack.isEmpty() && temperatures[i] >= temperatures[stack.peek()]) {
                stack.pop();
            }
            // 之前的全都被出栈了 说明今天的温度是目前最高的
            if (stack.isEmpty()) {
                res[i] = 0;
            } else {
                res[i] = stack.peek() - i;
            }
            stack.push(i);
        }
        return res;
    }
}
~~~



### 滑动窗口

-   套路：外层while循环控制右指针边界；内层先将加入一个元素到窗口中，然后将右指针右移一位，并且要根据题意对加进来的元素做相应操作(如计数、翻转等)；然后判断新窗口是否满足约束条件，若不满足条件则用内层while循环持续将左指针左移，直到符合约束；这样以后一个新的有效的窗口变形成了，此时判断是否需要更新所求的值(一般是最大长度、最短长度等)。

    适合求最大/最小的问题，即在约束条件要求下，每个解的左右边界是确定的；像那种求满足条件的个数有多少，比如一段区间内奇数的个数为k，求这样的区间有多少个，这种情况下同一个k的情况下左右边界可以左右伸展，所以不好用滑动窗口。

~~~java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int l = 0, r = 0;
        int n = s.length();
        // Map<Character, Integer> map = new HashMap<>();
        int maxLen = 0;
        while (r < n) {
            // do something...
            /**
            char c = s.charAt(r++);
            map.put(c, map.getOrDefault(c, 0) + 1);
            **/
            // until against the rule...
            while (map.get(c) > 1) {  
                // recover the window to meet the rule
                /**
                char cc = s.charAt(l++); 
                map.put(cc, map.get(cc) - 1);
                **/
            }
            // update answer....
            maxLen = Math.max(maxLen, r - l);
        }
        return maxLen;
    }
}

// eg2:
class Solution {
    public int longestOnes(int[] nums, int k) {
        int l = 0, r = 0;
        int n = nums.length;
        int maxLen = 0;
        while (r < n) {
            // 三步走：先加入nums[r]到窗口(代码中无需体现)；再判断需不需要反转；再移动r
            if (nums[r++] == 0) k--;
            // k--;
            // 判断是否合法
            while (k < 0) {
                if (nums[l++] == 0) k++;
            }
            maxLen = Math.max(maxLen, r - l);
        }
        return maxLen;
    }
}
~~~





## 手撕数据结构系列

### 用数组实现堆

~~~java
public void heapSort(int[] nums) {
    buildMaxHeap(nums);
    for (int i = 0; i < nums.length; i++) {
        swap(nums, 0, nums.length - 1 - i);
        // [0,i]共i+1个元素被换到最后去了，还剩n-(i+1)=n-i-1个
        maxHeapify(nums, 0, nums.length - i - 1);  
    }
}
// 建堆(自底向上逐个下沉)
public void buildMaxHeap(int[] nums){
    for (int i = nums.length / 2 - 1; i >= 0; i--) {
        maxHeapify(nums, i, nums.length);
    }
}
// 向下调整
public void maxHeapify(int[] nums, int i, int heapSize) {
    int mid = i;
    int left = 2 * mid + 1;
    int right = 2 * mid + 2;
    if (left < heapSize && nums[mid] < nums[left]) {
        mid = left;
    }
    if (right < heapSize && nums[mid] < nums[right]) {
        mid = right;
    }
    if (mid != i) {
        swap(nums, i, mid);
        maxHeapify(nums, mid, heapSize);
    }
}
public void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
~~~

### 用栈实现队列

~~~java
class CQueue {
    public Stack<Integer> in;
    public Stack<Integer> out;
    public CQueue() {
        in = new Stack<>();
        out = new Stack<>();
    }
    public void appendTail(int value) {
        in.push(value);
    }
    public int deleteHead() {
        if (in.isEmpty() && out.isEmpty()) return -1;
        if (!out.isEmpty()) return out.pop();
        else {
            while (!in.isEmpty()) {
                out.push(in.pop());
            }
            return out.pop();
        }
    }
}
~~~

### 用队列实现栈

~~~java
// 双队列
class MyStack {
    private Queue<Integer> q1;
    private Queue<Integer> q2;

    public MyStack() {
        q1 = new LinkedList<Integer>();
        q2 = new LinkedList<Integer>();
    }
    public void push(int x) {
        q1.add(x);

    }
    public int pop() {
        while (q1.size() > 1) {
            q2.add(q1.remove());
        }
        int res = q1.remove();
        while (!q2.isEmpty()) {
            q1.add(q2.remove());
        }
        return res;
    }
    public int top() {
        while (q1.size() > 1) {
            q2.add(q1.remove());
        }
        int res = q1.remove();
        q2.add(res);
        while (!q2.isEmpty()) {
            q1.add(q2.remove());
        }
        return res;
    }
    public boolean empty() {
        return (q1.isEmpty());
    }
}
// 单队列
class MyStack {
    private Queue<Integer> queue;
    public MyStack() {
        queue = new LinkedList<>();
    }
    public void push(int x) {
        queue.add(x);
        int cnt = queue.size();
        while (cnt-- > 1) {
            queue.add(queue.poll());
        }
    }
    public int pop() {
        return queue.remove();
    }
    public int top() {
        return queue.peek();
    }
    public boolean empty() {
        return queue.isEmpty();
    }
}
~~~







-------------------------------------------------------------------------------------------------------------------

## 题解

## 数据结构部分

### LC [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

**方法一：哈希集合**

-   思路：将链表A存入set中，第一个相同的节点就是重合的节点，如果链表headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回null。

-   复杂度：时间复杂度`O(m+n)`，m、n分别是两个链表的长度，空间复杂度`O(m)`

~~~java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode tmp = headA;
        Set<ListNode> set = new HashSet<ListNode>();
        while(tmp != null){
            set.add(tmp);
            tmp = tmp.next;
        }
        tmp = headB;
        while(tmp != null){
            if (set.contains(tmp))
                return tmp;
            tmp = tmp.next;
        }
        return null;
    }
}
~~~

*小结：链表包含了val和next，因此两个链表在某个位置的节点相同，意味着地址相同，意味着后面的节点也都相同*

**方法二：双指针**

-   思路：用双指针pA 、pB循环俩个链表，链表A循环结束就循环链表B，链表A循环结束就循环链表B，当`pA == pB`时就是交点，因为两个指针移动的步数一样

可以理解为走了两个新的链表，长度分别是m+n和n+m。

-   复杂度：时间复杂度`O(m+n)`，m、n分别是两个链表的长度，空间复杂度`O(1)`

~~~java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode pA = headA, pB = headB;
        if (headA == null || headB == null) return null;

        while (pA != pB){  
            if (pA != null)
                pA = pA.next;
            else pA = headB;
            if (pB != null)  
            //错误写法：if (pB.next != null)  这样若没有相交的，当两个指针通知到达尾部空节点时，又被指向了另一个链表的头部，造成了死循环
                pB = pB.next;
            else pB = headA;
        }
        if (pA == null)
            return null;
        else
            return pA;
    }
}
~~~

*小结：不要把尾部的空节点忽略了*

### 对比: LC [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

~~~java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode pA = headA, pB = headB;
        while(pA != pB) {
            pA = pA == null ? headB : pA.next;
            pB = pB == null ? headA : pB.next;
        }
        // if (pA != null) return pA;
        else return null;
    }
}
~~~



### **LC [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

**方法一：双指针迭代**

<img src="alg-img/反转链表-双指针.png" width="650px">

~~~java
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null) return null;
        ListNode pre = null, cur = head;
        ListNode tmp = null;  //要用一个临时节点来存放cur下一个节点的地址 不然cur.next连到前面后原本下一个节点就丢失了
        while (cur != null) {
            tmp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
}
~~~



**方法二：递归**

递归和迭代方法是可以相互转化的，因此整体思想也是差不多的

<img src="alg-img/反转链表-递归.png" width="550px">

~~~java
class Solution {
    public ListNode reverseList(ListNode head) {
        return reverse(null, head);
    }

    public ListNode reverse(ListNode pre, ListNode cur){
        if (cur == null) return pre;  //表面上有两个return 其实返回的都是最内层pre的这个节点
        ListNode tmp = cur.next;
        cur.next = pre;

        return reverse(cur, tmp);  
    }
}
~~~



### LC [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

**方法一： 迭代**

-   思路：

    使用一节点flag连接着头结点，方便返回头节点；

    使用一节点cur来记录目前已经加到最终有序合并链表中的最后一个节点，初始指向flag；

    使用一节点min来记录为加到最终有序链表中的最小的节点，判断 p1 和 p2 哪个更小，将min指向小的那个；

    将min连到cur后面，更新cur，然后将刚刚拿走的更小的 p1 或 p2 向后移动；

    直到有一边为 null ，即可将另一边剩余的都接上

~~~java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if (list1 == null) return list2;
        if (list2 == null) return list1;
        ListNode p1 = list1, p2 = list2;
        ListNode flag = new ListNode(-1);
        ListNode cur = flag;
        ListNode min;
        while (p1 != null && p2 != null) {
            min = p1.val < p2.val ? p1: p2;
            cur.next = min;
            cur = cur.next;
            if(min == p1) p1 = p1.next;
            else p2 = p2.next;
        }
        if(p1 != null) cur.next = p1;
        if(p2 != null) cur.next = p2;

        return flag.next;
    }
}
~~~

**方法二： 递归**

~~~java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if (list1 == null) return list2;
        if (list2 == null) return list1;
        if (list1.val < list2.val) {
            list1.next =  mergeTwoLists(list1.next, list2);
            return list1;
        }
        else {
            list2.next =  mergeTwoLists(list1, list2.next);
            return list2;
        }    
    }
}
~~~



### 对比：合并两个有序数组

~~~

~~~



### LC [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

**版本一：**

~~~java
//二次遍历
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode pre = head, cur = head;
        while(pre != null){  //最外层循环不要忘了 不然cur第一遍走到最后就结束了
            while(cur != null && cur.val == pre.val){
                cur = cur.next;
            }
            pre.next = cur;
            pre = cur;
        }
        return head;
    }
}
//一次遍历
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) return null;  //要特判
        ListNode cur = head;
        while(cur.next != null){  //否则这里会出现空指针异常
            if (cur.next.val == cur.val){
                cur.next = cur.next.next;
            }
            else{
                cur = cur.next;
            }
        }
        return head;
    }
}
~~~

**版本二：套用LC-82总结的模板**

~~~java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode pre = dummy, cur = head;
        while (cur != null && cur.next != null) {
            if (cur.next.val == cur.val) {
                while (cur.next != null && cur.next.val == cur.val) {
                    cur = cur.next;
                }
                // cur = cur.next;
                pre.next = cur;
            } else {
                pre = cur;
                cur = cur.next;
            }
        }
        return dummy.next;
    }
}
~~~



### 对比：LC [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

~~~java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode pre = dummy, cur = head;
        while (cur != null && cur.next != null) {
            if (cur.next.val == cur.val) {
                while (cur.next != null && cur.next.val == cur.val) {
                    cur = cur.next;
                }
                cur = cur.next;
                pre.next = cur;
            } else {
                pre = cur;
                cur = cur.next;
            }
        }
        return dummy.next;
    }
}
~~~





### LC [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

slow和fast指针起始时候都在head节点上，fast每走一步cnt加一(初始为0)，当cnt最后最后一个空节点时，cnt即为链表的长度

~~~java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        //删除倒数第n个，则只要找到倒数第n+1个节点即可
        //快慢指针 当快指针走n步后 慢指针再走
        if (head.next == null) return null;
        ListNode slow = head, fast = head;
        int cnt = 0;
        while(fast != null){
            fast = fast.next;
            cnt ++;
            if (fast != null && cnt > n)
                slow = slow.next;
        }
        //此时fast已经走到了最后，共走了n步，说明链表长度为n，若cnt==n则意味着删掉的是第一个节点
        if(cnt  == n) return head.next;  
        else {
            slow.next = slow.next.next;
            return head;
        }

    }
}
~~~





### LC [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

**方法一 <1>： 迭代**

-   思路：

    两个两个的去看节点，当两个节点都不为空时，反转这对节点的前后关系，其中要有第一第三方节点，来记录后一个节点的位置，该节点还总是在上一对节点反转后的后一个节点的位置，这样两队节点都反转后就连起来了。

~~~java
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode  pre = new ListNode(-1, head);
        boolean flag = false;
        ListNode front = head;
        ListNode rear;
        while(front != null && front.next != null) {
            rear = front.next;
            //反转前后节点
            pre.next = rear;
            front.next = rear.next;
            rear.next = front;
            //反转完成
            if (flag == false){
                head = rear;
                flag = true;
            }
            pre = front;
            front = front.next;
        }

        return head;
    }
}
~~~

*小结：交换节点这里和反转链表中的方法一样，都需要三个指针，一个为当前节点，一个为后继(即要比较的对象)，一个为前驱(交换后连接到该对节点的前一个节点)*

**方法一 <2> : 迭代<精简版>**

~~~java
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode  flag = new ListNode(-1, head);
        // boolean flag = false;
        ListNode front = head;
        ListNode rear;
        ListNode pre = flag;
        while(front != null && front.next != null) {
            rear = front.next;
            //反转前后节点
            pre.next = rear;
            front.next = rear.next;
            rear.next = front;
            //反转完成
            // if (flag == false){
            //     head = rear;
            //     flag = true;
            // }
            pre = front;
            front = front.next;
        }

        return flag.next;
    }
}
~~~



**方法二： 递归**

-   思路：

    终止条件：当前节点为null，或者下一个节点为 null
    函数内：将后一个节点指向前一个节点，前一个节点指向下一层的递归函数的返回结果(即后面一对节点中原本的后一个节点)，最后返回第一对节点的后一个节点。

    (思路参考LC题解，已收藏：https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/dong-hua-yan-shi-24-liang-liang-jiao-huan-lian-bia/)

~~~java
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode rear = head.next;  //这里head肯定非空 rear也非空
        head.next = swapPairs(rear.next);
        rear.next = head;
        return rear;
    }
}
~~~



### LC [445. 两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/)

**方法一： 栈**

~~~java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if(l1.val == 0) return l2;
        if(l2.val == 0) return l1;
        ListNode p = null;
        Stack<ListNode> s1 = new Stack<>();
        Stack<ListNode> s2 = new Stack<>();
        ListNode p1 = l1, p2 = l2;
        int flag = 0;
        while(p1 != null) {
            s1.push(p1);
            p1 = p1.next;
        }
        while(p2 != null) {
            s2.push(p2);
            p2 = p2.next;
        }
        /**  原来自己写的 可以简化
        while(s1.size() > 0 && s2.size() > 0){
            p1 = s1.pop();
            p2 = s2.pop(); 
            int val = (p1.val + p2.val + flag) % 10;
            ListNode tmp = new ListNode(val, p);
            flag = (p1.val + p2.val + flag) / 10;

            p = tmp;
        }
        while (s1.size() > 0){
            p1 = s1.pop();
            int val = (p1.val + flag) % 10;
            ListNode tmp = new ListNode(val, p);
            flag = (p1.val + flag) / 10;
            p = tmp;
        }
        while (s2.size() > 0){
            p2 = s2.pop();
            int val = (p2.val + flag) % 10;
            ListNode tmp = new ListNode(val, p);
            flag = (p2.val + flag) / 10;
            p = tmp;
        }
        if (flag > 0) {
            ListNode tmp = new ListNode(flag, p);
            p = tmp;
        }
        **/
        //上面三个while()循环可以简化成下面一个while()循环
        while(s1.size() > 0 || s2.size() > 0 || flag > 0){
            int val1 = s1.isEmpty() ? 0 : s1.pop().val;
            int val2 = s2.isEmpty() ? 0 : s2.pop().val; 
            int val = (val1 + val2 + flag) % 10;
            ListNode tmp = new ListNode(val, p);

            flag = (val1 + val2 + flag) / 10;

            p = tmp;
        }
        return p;
    }
}
~~~

*小结：当进到某一位时，其中一个链表已经没有值了，这时候可以看作他的值是0 ==> 最好将特殊情况转化为一般情况*

**方法二： 两次反转链表(反转链表+头插法)**

~~~java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        l1 = reverse(l1);
        l2 = reverse(l2);
        ListNode p1 = l1, p2 = l2;
        ListNode h = new ListNode(-1, null);
        int flag = 0;
        while(p1 != null || p2 != null || flag > 0) {
            int val1 = p1 == null ? 0 : p1.val;
            int val2 = p2 == null ? 0 : p2.val;
            int val = (val1 + val2 + flag) % 10;
            flag = (val1 + val2 + flag) / 10;
            ListNode tmp = new ListNode(val);
            tmp.next = h.next;
            h.next = tmp;
            if (p1 != null) p1 = p1.next;
            if (p2 != null) p2 = p2.next;
        }
        return h.next;   
    }
    public ListNode reverse(ListNode head) {
        if (head == null) return null;
        ListNode pre = null, cur = head;
        ListNode tmp = null;
        while(cur != null) {
            tmp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
}
~~~





### LC [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

**方法一： 双指针-首尾指针**

-   复杂度： 时间复杂度：O(n) + *O*(*n*/2) = O(n) + O(n) = O(2n)  = O(n) ; 

    ​			    空间复杂度：O(n)，其中 n指的是链表的元素个数，我们使用了一个数组列表存放链表的元素值。

~~~java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode p = head;
        List<Integer> list = new ArrayList<>();
        while(p != null){
            list.add(p.val);
            p = p.next;
        }
        for (int i = 0, j = list.size() - 1; i < j; i++, j--) {
            if (list.get(i) != list.get(j)) return false;
        }
        return true;
    }
}
~~~

**方法二： 双指针-快慢指针**

-   思路：利用快慢指针将链表分为前后两部分，然后将链表的后半部分反转，然后从前半部分和后半部分的首节点分别往后遍历，节点的值应该一直是相同的
-   复杂度：

~~~java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode flag = new ListNode(-1, head);
        ListNode p1  = flag, p2 = flag;
        //p1一次走一步，p2一次走两步  将链表分为前后两部分
        //若链表长度为偶数，前后一样长；若为奇数，中间一个节点不用考虑，前后还是一样长
        while(p2 != null && p2.next != null){
            p1 = p1.next;
            p2 = p2.next.next;
        }
        p1.next = reverse(p1.next); //将后半部分反转
        p2 = p1.next;//  后半部分的起点
        p1 = flag.next;  //前半部分的起点
        while(p2 != null) {  //由于后半部分的长度等于前半部分的，所以利用p2遍历即可
            if(p1.val != p2.val) return false;
            p1 = p1.next;
            p2 = p2.next;
        }
        return true;
    }

    public ListNode reverse(ListNode head) {
        if (head == null) return null;
        ListNode pre = null;
        ListNode cur = head;
        ListNode tmp;
        while(cur != null) {
            tmp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
}
~~~

### 对比：LC  [680. 验证回文字符串 Ⅱ](https://leetcode-cn.com/problems/valid-palindrome-ii/)

-   思路： 这题比较特殊，可以允许删一个字母；那么可以先按照简单的判断回文字符串的方法遍历，当遇到low和high位置的值不相等时，可以允许前后各尝试一次删掉一个字母，即low往前进一个或者high往后退一个。

~~~java
class Solution {
    public boolean validPalindrome(String s) {
        for (int low = 0, high = s.length() - 1; low < high; low++, high--) {
            if (s.charAt(low) != s.charAt(high)){
                return judge(s, low, high - 1) || judge(s, low + 1, high);  //允许前后各试错一次
                //由于从这里就进入了递归函数中(递归函数为传统的严格的判断方法，不允许试错)，因此只有一次试错机会。
            }
        }
        return true;
    }
    public boolean validPalindrome(String s, int i, int j) {
        for (int low = i, high = j; low < high; low++, high--) {
            if (s.charAt(low) != s.charAt(high)){
                return false;
            }
        }
        return true; 
        // while( i < j && s.charAt(i) == s.charAt(j)){
        //     i++;
        //     j--;
        // } 
        // return i >= j;  //若i>=j,说明顺利的遍历完了,说明都符合条件
    }
}
~~~



### LC [725. 分隔链表](https://leetcode-cn.com/problems/split-linked-list-in-parts/)

-   思路：先求出所有节点个数，然后平分给k个；还有结余的从第一个位置开始往后，每个再分一个。

-   复杂度： 

    ​	时间复杂度：O(n)，其中 nn 是链表的长度。需要遍历链表两次，得到链表的长度和分隔链表。

    ​	空间复杂度：O(1)。只使用了常量的额外空间，注意返回值不计入空间复杂度。

~~~java
class Solution {
    public ListNode[] splitListToParts(ListNode head, int k) {
        ListNode[] output = new ListNode[k];
        ListNode cur = head;
        int cnt = 0;
        while(cur != null) {
            cur = cur.next;
            cnt ++;
        }
        //剩余re个，前re个位置 每个分一个
        int size = cnt / k, re = cnt % k;
        cur = head;
        for (int i = 0; i < k && cur != null; i++) {
            int total = size + (i < re ? 1 : 0);
            output[i] = cur;
            for(int j = 1; j < total; j++){ 
                cur = cur.next;
            }
            ListNode next = cur.next;  //下一组的起点
            cur.next = null;  //处理尾结点
            cur = next;
        }
        return output;
    }
}
~~~

### LC [328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)

-   思路： 将奇数位置和偶数位置的节点分别提取出来，然后再将偶数链表接到奇数链表后面。

-   复杂度： 时间复杂度：O(n) ；空间复杂度：O(1)O(1)，只需要维护有限的指针。

    <img src="alg-img/奇偶索引分离链表.png" width="500px">

~~~java
class Solution {
    public ListNode oddEvenList(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode evenHead = head.next;
        ListNode odd = head, even = evenHead;
        while(even != null && even.next != null) {
            odd.next = even.next;
            odd = odd.next;
            even.next = odd.next;
            even = even.next;
        } 
        odd.next = evenHead;
        return head;
    }
}
~~~



### LC [283. 移动零到数组的末尾](https://leetcode-cn.com/problems/move-zeroes/)

**方法一： 双指针**

-   思路：我们创建两个指针i和j，第一次遍历的时候指针j用来记录当前有多少非0元素。即遍历的时候每遇到一个非0元素就将其往数组左边挪，第一次遍历完后，j指针的下标就指向了最后一个非0元素下标。

~~~java
// 参考题解后修改版：
class Solution {
    public void moveZeroes(int[] nums) {
        // int left = 0, right = 0;
        for(int left = 0, right = 0; right < nums.length; right ++){
            if (nums[right] != 0){
                int tmp = nums[right];
                nums[right] = nums[left];
                nums[left] = tmp;
                left ++;
            }  
        }
    }
}
~~~

~~~java
// 原来自己的
class Solution {
    public void moveZeroes(int[] nums) {
        if (nums.length == 1) return;
        int isZero = 0, notZero = 0;
        while (isZero < nums.length && notZero < nums.length) {
            //找一个是0的位置idx
            while (isZero < nums.length && nums[isZero] != 0){  
                isZero ++;
            }
            //从idx后面找一个非0的位置
            notZero = isZero + 1;
            while (notZero < nums.length && nums[notZero] == 0) {  
                notZero ++;
            }
            if (isZero < nums.length && notZero < nums.length) {
                int tmp = nums[isZero];
                nums[isZero++] = nums[notZero];
                nums[notZero++] = tmp;
            } 
        }
    }
}
~~~

**方法二： 单指针**

-   思路：把非0的放在前面，后面的都补0。

~~~java
public void moveZeroes(int[] nums) {
    int idx = 0;
    for (int num : nums) {
        if (num != 0) {
            nums[idx++] = num;
        }
    }
    while (idx < nums.length) {
        nums[idx++] = 0;
    }
}
~~~

### LC [566. 重塑矩阵](https://leetcode-cn.com/problems/reshape-the-matrix/)

~~~java
class Solution {
    public int[][] matrixReshape(int[][] mat, int r, int c) {
        int m = mat.length;
        int n = mat[0].length;
        if (m * n != r * c) return mat;
        int[][] new_mat = new int[r][c];
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                // 第(i,j)个
                int idx = i * n + j;
                int row = idx / c;
                int col = idx % c;
                new_mat[row][col] = mat[i][j];
            }
        }
        return new_mat;
    }
}
~~~

### LC [485. 最大连续 1 的个数](https://leetcode-cn.com/problems/max-consecutive-ones/)

~~~java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int cnt = 0;
        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            cnt = nums[i] == 1 ? cnt + 1 : 0;
            res = Math.max(cnt, res);
        }
        return res;
    }
}
~~~

### LC [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

-   思路： 数组从左到右和从上到下都是升序的，如果从右上角出发每次都是向左数字会变小，向下数字会变大，有点和二分查找树相似，所以我们可以把 target 和当前值比较：
    -   如果相等的话，直接返回 true 。
    -   如果 target 的值小于当前值，那么就向左走。
    -   如果 target 的值大于当前值，那么就向下走。

~~~java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int i = 0, j = matrix[0].length - 1;
        while(i < matrix.length && j >= 0) {
            if (matrix[i][j] == target) return true;
            if (matrix[i][j] > target) j--;
            else  i++;
        }
        return false;
        
    }
}
~~~





### LC [378. 有序矩阵中第 K 小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)

**方法一： Z型搜索+二分搜索**

<img src="alg-img/矩阵z型搜索与二分.png" width="400px">

~~~java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int n = matrix.length;
        int l = matrix[0][0], r = matrix[n - 1][n - 1];
        while (l < r) {
            int mid = l + ((r - l) >> 1);  //可以换成 int mid = l + r >> 1;
            // System.out.println(mid);
            if (check(matrix, mid, k)) r = mid;
            else l = mid + 1;
        }
        return l;
    }
    public boolean check(int[][] matrix, int mid, int k) {
        int i = 0, j = matrix.length - 1;
        int cnt = 0;
        while(i < matrix.length && j >= 0) {
            if (matrix[i][j] <= mid) {  //说明这一行前面的j+1个都小于mid
                cnt += j + 1;
                i++;
            }
            else{
                j--;
            }
        }
        return cnt >= k;  //左上半部分大于mid的数字个数大于等于k  答案在左上边
    }
}
~~~

**方法二： 重塑成一行数组+排序**

~~~java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int n = matrix.length;
        int[] tmp = new int[n * n];
        int idx = 0;
        for (int[] row : matrix){
            for (int num : row){
                tmp[idx ++] = num;
            }
        }
        Arrays.sort(tmp);
        // System.out.print(tmp[k]);
        return tmp[k - 1];
    } 
}
~~~





### LC [645. 错误的集合](https://leetcode-cn.com/problems/set-mismatch/) 

**方法一： 暴力法-数组**

-   思路：先将数组中的数组都加到新的长度为n+1数组中，然后[1,n+1]遍历一遍数组，cnt[i] 表示出现的次数，因此值为0的为漏掉的，值为2的为重复的

~~~java
class Solution {
    public int[] findErrorNums(int[] nums) {
        int n = nums.length;
        int[] cnt = new int[n + 1];
        for (int x : nums) cnt[x]++;
        int[] ans = new int[2];
        for (int i = 1; i <= n; i++) {
            if (cnt[i] == 0) an[1] = i;
            if (cnt[i] == 2) an[0] = i;
        }
        return ans;
    }
}
~~~

**方法二： 位运算**

-   思路： 

    -   将{1,2...n}和nums混到一起，然后做一轮异或运算，由于lost的值只有1个，dupli的值有3个，其他数字有2个，其他数字都被抵消了，可以得到lost和dupli的异或值xor，xor可以反映lost和dupli在哪些位置上不相同；

    -   根据其异或值的lowbit值，将{1,2...n, nums[] }分成两组，其中lost和dupli一定分别分在两组里；

    -   再分别和两组做异或运算，由于lost的值只有1个，dupli的值有3个，其他数字有2个，因此两轮异或运算只有得到的两个值a和b，一个是lost，一个是dupli；

    -   再遍历一下原数组，若原数组中存在a，则其为dupli，反则b为dupli。

~~~java
class Solution {
    public int[] findErrorNums(int[] nums) {
        int n = nums.length;
        int xor = 0;
        for (int num : nums) {
            xor ^= num;
        }
        for (int i = 1; i <= n; i++) {
            xor ^= i;
        }
        // xor == lost ^ dupli
        int lowbit = xor & (-xor);  //最后一位1的位置(最后一个1的位置上的值为1,其他位置都为0)
        //lost和dupli在该位置上的值不相同,可以借此来区分lost和dupli
        //根据lowbit位是0还是1将nums[]与[1-n]分成两组，其中lost和dupli一定分别分在两组
        int num1 = 0, num2 = 0;
        for (int num : nums) {
            if ((num & lowbit) == 0) {
                num1 ^= num;
            } else {
                num2 ^= num;
            }
        }
        for (int i = 1; i <= n; i++) {
            if ((i & lowbit) == 0) {  //与最后一位不是1的异或
                num1 ^= i;
            } else {  //与最后一位是1的异或
                num2 ^= i;
            }
        }
        //由于其他数字都是两个，所以最后的结果一个是lost, 一个是dupli
        for (int num : nums) {
            if (num == num1) {  //原数组中存在num1 则num1为重复的
                return new int[]{num1, num2};
            }
        }
        //原数组中不存在num1 则num2为重复的
        return new int[]{num2, num1};
    }
}
~~~

*总结：遇到查重和查漏的问题通常可以考虑用位运算来做*

### 对比： LC [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)-位运算

~~~java
class Solution {
    public int singleNumber(int[] nums) {
        int xor = 0;
        for (int num : nums) {
            xor ^= num;
        }
        return xor;
    }
}
~~~

### 对比： LC [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)-位运算

-   思路：

    使用一个长度为 32 的数组 cnt[] 记录下所有数值的每一位共出现了多少次 1，再对 cnt[] 数组的每一位进行 mod 3 操作，重新拼凑出只出现一次的数值。

    举个栗子，考虑样例 [1,1,1,3]，1 和 3 对应的二进制表示分别是 00..001 和 00..011，存入 cnt[] 数组后得到 [0,0,...,0,1,4]。进行 mod 3 操作后得到 [0,0,...,0,1,1]，再转为十进制数字即可得「只出现一次」的答案 3。


~~~java
//自己代码：
class Solution {
    public int singleNumber(int[] nums) {
        int[] cnt = new int[32];
        for (int num : nums) {
            for (int i = 0; i < 32; i++) {
                cnt[i] += ((num >> i & 1) == 1) ? 1 : 0;
            }
        }
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            if (cnt[i] % 3 == 1) {
                ans += (1 << i);  // ans |= (1 << i);
            }
        }
        return ans;   
    }
}

//参考代码：
class Solution {
    public int singleNumber(int[] nums) {
        int[] cnt = new int[32];
        for (int x : nums) {  //对于数组中的每一个数字
            for (int i = 0; i < 32; i++) {  //对于数字的每一位
                if (((x >> i) & 1) == 1) {  //看x的第i位是不是1  ==》 x >> k & 1 //看x的第k位是0还是1
                    cnt[i]++;
                }
            }
        }
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            if (cnt[i] % 3 == 1) {  //这些位置上的1的个数不是3的倍数 说明是ans在该位置上的值为1
                ans += (1 << i);
            }
        }
        return ans;
    }
}
~~~



### 对比 LC 260. [只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)-位运算

~~~java
class Solution {
    public int[] singleNumber(int[] nums) {
        int xor = 0;
        for (int num : nums) {
            xor ^= num;
        }
        // Integer.MIN_VALUE:1000 0000 0000 0000 0000 0000 0000 0000 
        // 防止溢出 Integer.MIN_VALUE的反码是32个1，会溢出
        // 因为二进制有正负0，负零用于多表示一位负数，这个负数如果取相反数，会产生溢出，所以不能用 a & (-a) 取最低有效位
        // 负0的特点是第一位是1，其余位是0，所以它的最低有效位就是自己
        int lowbit = (xor == Integer.MIN_VALUE ? xor : xor & (-xor));
        int xor1 = 0, xor2 =0;
        for (int num : nums) {
            if ((num & lowbit) == 0 ){
                xor1 ^= num;
            }
            else {
                xor2 ^= num;
            }
        }
        return new int[]{xor1, xor2};
    }
}
~~~



### LC [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

**方法一： 快慢指针-Floyd判圈法**

<img src="alg-img/寻找重复数-快慢指针.png" width="550px">

>**参考题解：**
>
>将这个题目给的特殊的数组当作一个链表来看，数组的下标就是指向元素的指针，把数组的元素也看作指针。如 0 是指针，指向 nums[0]，而 nums[0] 也是指针，指向 nums[nums[0]].
>
>假设有这样一个样例：[1,2,3,4,5,6,7,8,9,5]。如果我们按照上面的循环下去就会得到这样一个路径: 1 2 3 4 5 [6 7 8 9] [6 7 8 9] [6 7 8 9] . . .这样就有了一个环，也就是6 7 8 9。point 会一直在环中循环的前进。
>这时我们设置两个一快(fast)一慢(slow)两个指针，一个每次走两步，一个每次走一步，这样让他们一直走下去，直到他们在重复的序列中相遇，如上图，slow和fast会在环中相遇，先假设一些量：起点到环的入口长度为m，环的周长为c，在fast和slow相遇时slow走了n步。则fast走了2n步，fast比slow多走了n步，而这n步全用在了在环里循环（n%c==0）。
>当fast和last相遇之后，我们设置第三个指针finder，它从起点开始和slow(在fast和slow相遇处)同步前进，当finder和slow相遇时，就是在环的入口处相遇，也就是重复的那个数字相遇。
>
>为什么 finder 和 slow 相遇在入口
>fast 和 slow 相遇时，slow 在环中行进的距离是n-m，其中 n%c==0。这时我们再让 slow 前进 m 步——也就是在环中走了 n 步了。而 `n%c==0`  即 slow 在环里面走的距离是环的周长的整数倍，就回到了环的入口了，而入口就是重复的数字。
>我们不知道起点到入口的长度m，所以弄个 finder 和 slow 一起走，他们必定会在入口处相遇。
>
>作者：zjczxz
>链接：https://leetcode-cn.com/problems/find-the-duplicate-number/solution/kuai-man-zhi-zhen-de-jie-shi-cong-damien_undoxie-d/
>来源：力扣（LeetCode）
>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

-   复杂度
    -   时间复杂度：O(n))。「Floyd 判圈算法」时间复杂度为线性的时间复杂度。
    -   空间复杂度：O(1)。我们只需要常数空间存放若干变量。

~~~java
class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0, fast = 0;
        while (true) {
            slow = nums[slow];
            fast = nums[nums[fast]];
            if (slow == fast) break;
        }
        //相遇了
        int tmp = 0;
        while (true) {
            tmp = nums[tmp];
            slow = nums[slow];
            if (tmp == slow) break;
        }
        return tmp;
    }
}
~~~

**方法二： 二分查找+抽屉原理**

-   思路：二分查找的思路是先猜一个数（有效范围 `[left..right]` 里位于中间的数 `mid`），然后统计原始数组中 **小于等于** `mid` 的元素的个数 `cnt`：

    ​			* 如果 `cnt` **严格大于** `mid`。根据抽屉原理，重复元素就在区间 `[left..mid]` 里；

    ​			* 否则，重复元素就在区间 `[mid + 1..right]` 里。

-   复杂度： 
    -   时间复杂度：O(nlogn)，其中 n 为nums数组的长度。二分查找最多需要二分O(logn) 次，每次判断的时候需要O(n)遍历 nums 数组求解小于等于 mid 的数的个数，因此总时间复杂度为O(nlogn)。
    -   空间复杂度：O(1)。我们只需要常数空间存放若干变量。

~~~java
class Solution {
    public int findDuplicate(int[] nums) {
        int l = 1, r = nums.length - 1;
        while (l < r) {
            int mid = l + r >> 1;
            if (check(mid, nums)) r = mid;  // [1, mid]当中一定有重复的数字,答案在左边区间
            else l = mid + 1;
        }
        return l;
    }

    public boolean check (int mid, int[] nums) {
        int cnt = 0;
        for (int num : nums) {
            if (num <= mid){  //统计数组中小于等于mid的个数
                cnt ++;
            }
        }
        if (cnt > mid) return true;  //如果小于等于mid的个数大于mid，那么[1, mid]当中一定有重复的数字
        else return false;
    }
}
~~~

**方法三： 位运算**

-   思路：二进制，即分别统计32个比特位上，1出现的次数，与1~n这n个数中出现的1的次数比较，前者大于后者时，则说明重复数字在该比特位上为1.时间O(nlgn)
-   复杂度：
    -   时间复杂度：O(nlogn)，其中 nn 为nums 数组的长度。O(logn) 代表了我们枚举二进制数的位数个数，枚举第 i位的时候需要遍历数组统计 x 和 y 的答案，因此总时间复杂度为O(nlogn)。
    -   空间复杂度：O(1)。我们只需要常数空间存放若干变量。

~~~java
class Solution {
    public int findDuplicate(int[] nums) {
        int n = nums.length, ans = 0;
        int num_max = n - 1;
        int bit_max = 31;
        // 获取num_max的二进制形式的最高位
        while (num_max >> bit_max == 0) {
            bit_max --;
        }
        for (int bit = 0; bit <= bit_max; bit ++) {
            //x用来统计num[0:n-1]数组中有多少数字在第bit位上是1， y用来统计[1:n-1]中有多少数字在第bit位上是1
            int x = 0, y = 0;  
            for (int i = 0; i < n; i++) {
                if ((nums[i] & (1 << bit)) != 0){
                    x++;
                }
                if (((i & (1 << bit)) != 0) && i >=1 ) {
                    y++;
                }
            }
            if (x > y) {  //如果第bit位数组中的1更多，这里多出来的1是重复的数提供的，将其加到答案中
                ans |= 1 << bit;
            }
        }
        return ans;
    }
}
~~~



### LC [667. 优美的排列 II](https://leetcode-cn.com/problems/beautiful-arrangement-ii/)

-   思路： 让前 k+1 个元素构建出 k 个不相同的差值，序列为：1 k+1 2 k 3 k-1 ... k/2 k/2+1.后n-k-1个则是将[k+2,n]从小到大排序

<img src="alg-img/优美的排列2.png" width="400px">

~~~java
class Solution {
    public int[] constructArray(int n, int k) {
        int[] res = new int[n];
        //让前 k+1 个元素构建出 k 个不相同的差值
        res[0] = 1;
        for (int i = 1, interval = k; i <= k; i++, interval--) {
            res[i] = i % 2 == 1 ? res[i - 1] + interval : res[i - 1] - interval;
        }
        //后n-k-1个则是将[k+2,n]从小到大排序
        for (int i = k + 1; i < n; i++) {
            res[i] = i + 1;
        }
        return res;
    }
}
~~~





### LC [697. 数组的度](https://leetcode-cn.com/problems/degree-of-an-array/)

**方法一： 暴力**

~~~java
class Solution {
    public int findShortestSubArray(int[] nums) {
        if (nums.length == 1) return 1;
        int[] mat = new int[50010];
        for (int num : nums) {
            mat[num] ++;
        }
        Set<Integer> flag = new HashSet<>();
        int max = 0;
        for (int i = 0; i < 50010; i++) {
            if (mat[i] > max) {
                max = mat[i];
                flag.clear();
                flag.add(i);
            }
            if (mat[i] == max) {
                flag.add(i);
            }
        }
        int ans = Integer.MAX_VALUE;
        for (int i : flag){
            int l = 0, r = nums.length - 1;
            while (nums[l] != i && l < nums.length) l++;
            while (nums[r] != i && r > 0) r--;
            ans = Math.min(ans, r - l + 1);
        }
        return ans;
    }
}
~~~



**方法二： Map优化**

~~~java
class Solution {
    public int findShortestSubArray(int[] nums) {
        Map<Integer, Integer> numsCnt = new HashMap<Integer, Integer>();  //用来记录num出现的次数
        Map<Integer, Integer> numsLeft = new HashMap<Integer, Integer>();  //用来记录num第一次出现的位置
        Map<Integer, Integer> numsRight = new HashMap<Integer, Integer>();  //用来记录num最后一次出现的位置
        for (int i = 0; i < nums.length; i++) {
            numsCnt.put(nums[i], numsCnt.getOrDefault(nums[i], 0) + 1);
            numsRight.put(nums[i], i);
            if (!numsLeft.containsKey(nums[i])) {
                numsLeft.put(nums[i], i);
            }
        }
        int max = 0;
        for (int num: nums) {
            max = Math.max(max, numsCnt.get(num));
        }
        int res = nums.length;
        for (int num : nums) {
            if (numsCnt.get(num) == max) {  //出现次数的数字不一定只有一个
                res = Math.min(res, (numsRight.get(num) - numsLeft.get(num) + 1));
            }
        }
        return res;
    }
}
~~~



### LC [766. 托普利茨矩阵](https://leetcode-cn.com/problems/toeplitz-matrix/)

-   每个元素和其右下角的比对即可。

~~~java
class Solution {
    public boolean isToeplitzMatrix(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        for (int i = 0; i < m - 1; i ++) {
            for (int j = 0; j < n - 1; j ++) {
                if (matrix[i][j] != matrix[i+1][j+1]) return false;
            }
        }
        return true;
    }
}
~~~



### LC [565. 数组嵌套](https://leetcode-cn.com/problems/array-nesting/)

**方法一： 判环**

-   思想： 以链表的思维理解该数组，数组中的节点可以组成若干个环，则找出所有的环，并比较环中的节点个数。
-   复杂度：
    -   时间复杂度：O(n). nums数组的每个元素最多只考虑一次。
    -   空间复杂度：O(n). 使用的 visited是大小为 n的数组。

~~~java
class Solution {
    public int arrayNesting(int[] nums) {
        int n = nums.length;
        if (n == 1) return 1;
        boolean[] visited = new boolean[n];
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (!visited[i]) {  //如果该点还没加入到环中
                int begin = i, idx = begin;
                int cnt = 1;  
                while (nums[nums[idx]] != nums[begin] ) {
                    visited[idx] = true;
                    idx = nums[idx];
                    cnt ++;
                }
                ans = Math.max(ans, cnt);
            }
            
        }
        return ans;
    }
}
~~~

*优化方法：可以不开visited[]数组，而是将原数组中访问过的节点值修改为MAX_VALUE作为标记。*

### LC [769. 最多能完成排序的块](https://leetcode-cn.com/problems/max-chunks-to-make-sorted/)

-   思路：遍历数组，计算到第i个元素时[0, i]这一段的最大值，若最大值等于i且数组中无重复元素，说明[0, i-1]元素都是由0~i-1填放的，则[0，i]这一段排序后是0~I的有序序列，可以单独分块；以此类推继续遍历；两次符合条件的索引之间的元素可以划成一块。

<img src="alg-img/最多能完成排序的块.png" width="450px">

~~~java
class Solution {
    public int maxChunksToSorted(int[] arr) {
        int cnt = 0;
        int max = 0;
        for (int i = 0; i < arr.length; i++) {
            max = Math.max(max, arr[i]);
            if (max == i) cnt ++;
        }
        return cnt;
    }
}
~~~



### LC [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

~~~java
class MyQueue {
    private Stack<Integer> s1 ;
    private Stack<Integer> s2 ;

    public MyQueue() {
        s1 = new Stack<>();
        s2 = new Stack<>();
    }
    
    public void push(int x) {
        s1.push(x);

    }
    
    public int pop() {
        while(!s1.isEmpty()) {
            s2.push(s1.pop());
        }
        int res = s2.pop();
        while(!s2.isEmpty()) {  // 其实不用每次都再放回去
            s1.push(s2.pop());
        }
        return res;
    }
    /**  优化版:
    public int pop() {
        in2out();
        return out.pop();
    }
    public int peek() {
        in2out();
        return out.peek();
    }
    public boolean empty() {
        return in.isEmpty() && out.isEmpty();
    }
    private void in2out() {
        if (out.isEmpty()) {
            while (!in.isEmpty()) {
                out.push(in.pop());
            }
        }
    }
    **/
    
    public int peek() {
        while(!s1.isEmpty()) {
            s2.push(s1.pop());
        }
        int res = s2.peek();
        while(!s2.isEmpty()) {
            s1.push(s2.pop());
        }
        return res;
    }
    
    public boolean empty() {
        return s1.isEmpty();
    }
}
~~~





### LC [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

**双队列： **

~~~java
class MyStack {
    private Queue<Integer> q1;
    private Queue<Integer> q2;

    public MyStack() {
        q1 = new LinkedList<Integer>();
        q2 = new LinkedList<Integer>();

    }
    public void push(int x) {
        q1.add(x);

    }
    public int pop() {
        while (q1.size() > 1) {
            q2.add(q1.remove());
        }
        int res = q1.remove();
        while (!q2.isEmpty()) {
            q1.add(q2.remove());
        }
        return res;
    }
    public int top() {
        while (q1.size() > 1) {
            q2.add(q1.remove());
        }
        int res = q1.remove();
        q2.add(res);
        while (!q2.isEmpty()) {
            q1.add(q2.remove());
        }
        return res;
    }
    public boolean empty() {
        return (q1.isEmpty());
    }
}
~~~

**单队列： **

~~~java
/**
在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。
**/
class MyStack {
    private Queue<Integer> queue;
    public MyStack() {
        queue = new LinkedList<>();
    }
    public void push(int x) {
        queue.add(x);
        int cnt = queue.size();
        while (cnt-- > 1) {
            queue.add(queue.poll());
        }
    }
    public int pop() {
        return queue.remove();
    }
    public int top() {
        return queue.peek();
    }
    public boolean empty() {
        return queue.isEmpty();
    }
}
~~~



### LC [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

~~~java
class MinStack {
    private Stack<Integer> s;
    private Stack<Integer> sMin;
    private int min = Integer.MAX_VALUE;

    public MinStack() {
        s = new Stack<Integer>();
        sMin = new Stack<>();
    }
    
    public void push(int val) {
        s.push(val);
        min = Math.min(min, val);
        sMin.push(min);
    }
    
    public void pop() {
        s.pop();
        sMin.pop();
        min = sMin.isEmpty() ? Integer.MAX_VALUE : sMin.peek();
    }
    
    public int top() {
        return s.peek();
    }
    
    public int getMin() {
        return sMin.peek();
    }
}
~~~



### LC [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

~~~java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);
            if (ch =='(' || ch =='[' || ch =='{') {
                stack.push(ch);
            }
            if (ch ==')') {
                if (stack.isEmpty()|| stack.pop() != '(') return false;
            }
            if (ch ==']') {
                if (stack.isEmpty()|| stack.pop() != '[') return false;
            }
            if (ch =='}') {
                if (stack.isEmpty()|| stack.pop() != '{' ) return false;
            }
        }
        if (!stack.isEmpty()) return false;
        return true;
    }
}
~~~



### LC [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

**方法一： 暴力法**

~~~java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] ans = new int[n];
        for (int i = 0; i < n; i ++) {
            int j = i + 1;
            while (j < n && temperatures[j] <= temperatures[i]) j++;
            if (j == n) ans[i] = 0;
            else ans[i] = j - i;
        }
        return ans;
    }
}
~~~

**方法二： 单调栈-逆序遍历**

~~~java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] ans = new int[n];
        Stack<Integer> stack = new Stack<>();
        for (int i = n - 1 ; i >= 0; i --) {
            if (stack.isEmpty()) {
                ans[i] = 0;
                stack.push(i);
            }
            else {  //非空
                if (temperatures[stack.peek()] > temperatures[i]) {  //下一个就比他大
                    ans[i] = 1;
                    stack.push(i);
                }
                else {
                    while (!stack.isEmpty() &&  temperatures[stack.peek()] <= temperatures[i]) {  //将小于等于他的弹出
                        stack.pop();
                    }
                    if (stack.isEmpty()) {  //弹光了 说明栈里的都比他小
                        ans[i] = 0;
                    }
                    else {
                        ans[i] = stack.peek() - i;
                    }
                    stack.push(i);
                }     
            }
        }
        return ans;
    }
}
~~~

**方法三： 单调栈-正序**

-   思路： 使用单调递减栈存放索引；不断查看当前温度是否大于栈顶元素的温度，若大于，说明找到了第一个高温的天气，栈顶元素出栈，马上更新栈顶元素对应的「后一个更高温度天数」；若栈中元素一直没出栈，说明后面没有气温比它还高了，保持初始值0即可

~~~java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] ans = new int[n];
        Stack<Integer> stack = new Stack<>();
        for (int i = 0 ; i < n; i ++) {
            if (stack.isEmpty()) {
                stack.push(i);  //总是要做的
            }
            else {
                if (temperatures[i] <= temperatures[stack.peek()]) {
                    stack.push(i);  //总是要做的
                }
                else {  //栈顶元素迎来了他的解放军
                    while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) { 
                        int idx = stack.pop();
                        ans[idx] = i - idx;
                    }
                    stack.push(i);  //总是要做的
                }
            }
        }
        while (!stack.isEmpty()) {
            int idx = stack.pop();
            ans[idx] = 0;
        }
        return ans;
    }
}

//简化版
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] ans = new int[n];
        Stack<Integer> stack = new Stack<>();
        //int cnt = 0;
        for (int i = 0 ; i < n; i ++) {
            while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
                int idx = stack.pop();
                ans[idx] = i - idx;
            }
            stack.push(i);

        }
        while (!stack.isEmpty()) {
            int idx = stack.pop();
            ans[idx] = 0;
        }
        return ans;
    }
}
~~~



### LC [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)

**方法一： 单调栈**

~~~java
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) ans[i] = Integer.MIN_VALUE;
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < 2*n; i++) {
            int j = i % n;
            while (!stack.isEmpty() && nums[j] > nums[stack.peek()]) {
                int idx = stack.pop();
                if (ans[idx] == Integer.MIN_VALUE) {
                    ans[idx] = nums[j];
                }  
            }
            stack.push(j);
        }
        while (!stack.isEmpty()) {
            int idx = stack.pop();
            if (ans[idx] == Integer.MIN_VALUE) {
                ans[idx] = -1;
            }  
        }
        return ans;
    }
}

// 简化版
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];
        Arrays.fill(ans, -1);
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < 2*n; i++) {
            int j = i % n;
            while (!stack.isEmpty() && nums[j] > nums[stack.peek()]) {
                int idx = stack.pop();
                ans[idx] = nums[j];
            }
            if (i < n)  // 栈中放的都是需要找到解放军的元素 因此只有第一遍遍历时需要将元素放入栈
                stack.push(j);
        }
        //栈中剩余没有被解放的元素保持默认值为-1 
        return ans;
    }
}
~~~



### LC [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

~~~java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
~~~



### LC [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

**方法一： 两次深度遍历**

~~~java
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) return true;
        int l = maxDepth(root.left);
        int r = maxDepth(root.right);
        if (Math.abs(l - r) > 1) return false;
        return isBalanced(root.left) && isBalanced(root.right);
    }
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
~~~

**方法二： 一次深度遍历+引入全局变量**

~~~java
class Solution {
    private boolean res = true;
    public boolean isBalanced(TreeNode root) {
        maxDepth(root);
        return res;
    }
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        int l = maxDepth(root.left);
        int r = maxDepth(root.right);
        if (Math.abs(l - r) > 1) res =  false;
        return Math.max(l, r) + 1;
    }
}
~~~

*总结：递归问题中，对于返回值不太确定的，可以引入一个全局变量作为答案*



### LC [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

-   思路：最大直径=左子树高度+右子树高度，并且使得每个节点都成为一次根节点（这条路径可能穿过也可能不穿过根结点）

**方法一： 两次深度遍历**

~~~java
class Solution {
    private int res = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        if (root == null) return 0;
        int l = maxDepth(root.left);
        int r = maxDepth(root.right);
        res = Math.max(res, l + r);
        diameterOfBinaryTree(root.left);
        diameterOfBinaryTree(root.right);
        return res;
    }
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
~~~

**方法二：一次深度遍历+引入全局变量 **

~~~java
// Best !!!
class Solution {
    private int res = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        maxDepth(root);
        return res;
    }
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        int l = maxDepth(root.left);
        int r = maxDepth(root.right);
        res = Math.max(res, l + r);
        return Math.max(l, r) + 1;
    }
}
~~~



### LC [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

**方法一： 递归函数不带返回值-自顶向下**

~~~java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        invert(root);
        return root;
    }
    public void invert(TreeNode root) {
        if (root == null) return;
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        invert(root.left);
        invert(root.right);
    }
}
~~~

**方法二： 递归函数带返回值-自底向上**

~~~java
// 写法一：
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return null;
        TreeNode left = root.left;
        root.left = invertTree(root.right);
        root.right = invertTree(left);
        return root;
    }
}
// 写法二：
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return null;
        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);
        root.left = right;
        root.right = left;
        return root;
    }
}
~~~



### LC [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

~~~java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null && root2 == null) return null;
        if (root1 == null) return root2;
        if (root2 == null) return root1;
        int val = root1.val + root2.val;
        TreeNode new_root = new TreeNode(val);
        new_root.left = mergeTrees(root1.left, root2.left);
        new_root.right = mergeTrees(root1.right, root2.right);
        return new_root;

    }
}
~~~



### LC [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

**方法一： **

~~~java
class Solution {
    private int sum = 0;
    private boolean res = false;
    public boolean hasPathSum(TreeNode root, int targetSum) {
        check(root, targetSum);
        return res;
    }
    public void check(TreeNode root, int targetSum) {
        if (root == null) return;
        sum += root.val;
        if (sum == targetSum && root.left == null && root.right == null) {
            res = true;
            return;
        }
        check(root.left, targetSum);
        check(root.right, targetSum);
        sum -= root.val;
    }
}
~~~

**方法二： (参考解答)**

-   思路： 询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。

~~~java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) return false;
        if (root.left == null && root.right == null && root.val == targetSum) return true;
        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);
    }
}
~~~



### LC [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

**方法一： DFS**

-   复杂度： 
    -   时间复杂度：O(N^2)，其中 N为该二叉树节点的个数。对于每一个节点，求以该节点为起点的路径数目时，则需要遍历以该节点为根节点的子树的所有节点，因此求该路径所花费的最大时间为 O(N)，我们会对每个节点都求一次以该节点为起点的路径数目，因此时间复杂度为 O(N^2)。
    -   空间复杂度：O(N)，考虑到递归需要在栈上开辟空间。

~~~java
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        if (root == null) return 0;
        /**
        答案由三部分构成：
        	以root为根、targetSum为目标做dfs搜索出来的结果；
        	以root.left为根、targetSum为目标做dfs搜索出来的结果；
        	以root.right为根、targetSum为目标做dfs搜索出来的结果；
        **/
        return dfs(root, targetSum) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum);
    }
    //dfs()单纯以root为起点做深度遍历，遍历过程中计算到起始节点到当前访问节点的和是不是等于答案，等于话满足条件的路径加1。
    public int dfs(TreeNode root, int targetSum) {
        if (root == null) return 0;
        int res = root.val == targetSum ? 1 : 0;
        //int res = 0;
        //if (root.val == targetSum) {  //这里不再限制终止节点为叶子节点
        //    res ++;
        //}
        res += dfs(root.left, targetSum - root.val) + dfs(root.right, targetSum- root.val);
        return res;
    }
}
~~~

**方法二： 前缀和**

<img src="alg-img/路径总和-前缀和.png" width="550px">

-   复杂度：
    -   时间复杂度：O(N)，其中 N为二叉树中节点的个数。利用前缀和只需遍历一次二叉树即可。
    -   空间复杂度：O(N)。

~~~java
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        Map<Integer, Integer> preSum = new HashMap<>();
        preSum.put(0, 1);
        return dfs(root, targetSum, preSum, 0);
    }
    public int dfs(TreeNode root, int targetSum, Map<Integer, Integer> preSum, int curSum) {
        if (root == null) return 0;
        int res = 0;
        curSum += root.val;
        // 先找有没有符合条件的
        res += preSum.getOrDefault(curSum - targetSum, 0);
        // 后把当前节点加进去
        preSum.put(curSum, preSum.getOrDefault(curSum, 0) + 1);  //将当前节点的前缀和加入Map
        res += dfs(root.left, targetSum, preSum, curSum) + dfs(root.right, targetSum, preSum, curSum);
        preSum.put(curSum, preSum.get(curSum) - 1);
        return res;
    }
}
~~~





### [总结文章：一篇文章解决所有二叉树路径问题](https://leetcode-cn.com/problems/path-sum-iii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-smch/)

~~~java
二叉树路径的问题大致可以分为两类：
1、自顶向下：
顾名思义，就是从某一个节点(不一定是根节点)，从上向下寻找路径，到某一个节点(不一定是叶节点)结束
具体题目如下：
257. 二叉树的所有路径
面试题 04.12. 求和路径
112. 路径总和
113. 路径总和 II
437. 路径总和 III
988. 从叶结点开始的最小字符串
而继续细分的话还可以分成一般路径与给定和的路径
2、非自顶向下：
就是从任意节点到任意节点的路径，不需要自顶向下
124. 二叉树中的最大路径和
687. 最长同值路径
543. 二叉树的直径
~~~



### LC [572. 另一棵树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)

**方法一：DFS**

-   思路：先判断root和subRoot是不是相同的树；若不是的话再判断root.left或者root.right和subRoot是不是相同的树。

~~~java
class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        if (subRoot == null) return true;  //子书根节点为空
        if (root == null) return false;  //子树根节点不为空  大树的根节点为空
        //先判断root和subRoot是不是相同的树；若不是的话再判断root.left或者root.right和subRoot是不是相同的树。
        return isSameTree(root, subRoot) || isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);
    }
    public boolean isSameTree(TreeNode root, TreeNode subRoot) {
        if (root == null && subRoot == null) return true;  //两者都为空
        if (root == null || subRoot == null) return false;  //两者有一个空
        if (root.val != subRoot.val) return false;  //都不空 但值不相等
        return isSameTree(root.left, subRoot.left) && isSameTree(root.right, subRoot.right);
    }
}
~~~

#### 待续 kmp

### 方法二：深度优先搜索序列上做KMP串匹配

~~~java
//待续
~~~



### 对比 LC [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

~~~java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) return true;
        if (p == null || q == null) return false;
        if (p.val != q.val) return false;
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
~~~



### LC [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

**方法一： 递归**

~~~java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) return true;
        return check(root.left, root.right);
    }

    public boolean check(TreeNode l, TreeNode r) {
        if (l == null && r == null) return true;
        if (l == null || r == null) return false;
        // return l.val == r.val && check(l.left, l.right) && check(r.left, r.right); //错误写法！！
        //应该是和全局的比而不是自己节点的左右子节点比
        return l.val == r.val && check(l.left, r.right) && check(l.right, r.left);

    }
}
~~~

**方法二： 迭代-队列-类广度遍历**

-   思路： 每次放入一对节点，这一对节点在二叉树中的位置是对称的，然后比较他们是否相等；相等的话再把它们的四个子节点放入队列，也要按照对称顺序放入，即假设有1，2，3，4，先放1和4，再放2和3；这样下次从队列中取元素时，只要像前面说的一对一对的取就行了。

~~~java
class Solution {
    private Queue<TreeNode> qu = new LinkedList<TreeNode>();
    public boolean isSymmetric(TreeNode root) {
        if (root == null || root.left == null && root.right == null) return true;
        qu.add(root.left);
        qu.add(root.right);
        while (qu.size() > 0) {
            TreeNode l = qu.remove();
            TreeNode r = qu.remove();
            if (l == null && r == null) continue;
            if (l == null || r == null) return false;
            if (l.val != r.val) return false;
            qu.add(l.left);
            qu.add(r.right);
            qu.add(l.right);
            qu.add(r.left);
        }
        return true;
    }
}
~~~



### LC [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

**方法一： DFS**

~~~java
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        int l = minDepth(root.left);
        int r = minDepth(root.right);
        // 叶子节点 返回为节点自己的高度1
        if (root.left == null && root.right == null) return 1;
        // 非叶子节点
        // 有一个孩子为空 则该子树的高度为0 因此返回l + r + 1实际就是返回另一子树的高度加本节点的高度 这里不能用Math.min(l, r) + 1哦，因为Math.min(l, r)为0
        if (root.left == null || root.right == null) {
            return l + r + 1;
        }
        // 左右子节点都不为空 返回高度矮的那个
        return Math.min(l, r) + 1;
    }
}

//合并简化版
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        int l = minDepth(root.left);
        int r = minDepth(root.right);
        // 包含了两种情况：0+0+1(左右子树都为空)以及x+0+1(有一个子树为空)
        if (root.left == null || root.right == null) {
            return l + r + 1;
        }
        // 左右子节点都不为空 返回高度矮的那个
        return Math.min(l, r) + 1;
    }
}
~~~

**对比：二叉树的最大深度、左叶子之和**

~~~java
//最大深度
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        int l = maxDepth(root.left);
        int r = maxDepth(root.right)
        return Math.max(l, r) + 1;
    }
}
//最小深度
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        int l = minDepth(root.left);
        int r = minDepth(root.right);
        //差异start
        // 增加一个递归终止条件
        // 包含了两种情况：0+0+1(左右子树都为空)以及x+0+1(有一个子树为空)
        if (root.left == null || root.right == null) {
            return l + r + 1;
        }
        //差异end
        return Math.min(l, r) + 1;
    }
}
~~~



**方法二： BFS**

~~~java
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        int depth = 0;
        Queue<TreeNode> qu = new LinkedList<TreeNode>();
        qu.add(root);
        while(!qu.isEmpty()){
            depth += 1;
            //下一层有几个元素
            int size = qu.size();
            //这样保证一层的元素在一批弹出操作
            for (int i = 0; i < size; i ++) {
                TreeNode tmp = qu.remove();
                if (tmp.left == null && tmp.right == null) return depth;
                if (tmp.left != null) qu.add(tmp.left);
                if (tmp.right != null) qu.add(tmp.right);
            }
        }
        return depth;
    }
}
~~~



### LC [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

**方法一： DFS**

-   DFS过程中判断节点是不是叶子节点+左节点，是的话返回该节点的值

~~~java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) return 0;
        return dfs(root.left, true) + dfs(root.right, false);   

    }
    public int dfs(TreeNode root, boolean isLeft) {
        if (root == null) return 0;
        // 只将左叶子的值加起来
        if (root.left == null && root.right == null && isLeft) {
            return root.val;
        }
        int l = dfs(root.left, true);
        int r = dfs(root.right, false);
        return l + r;
    }
}
~~~

**方法二： DFS**

-   思路：DFS过程中判断节点的左孩子是不是叶子节点，是的话返回左孩子节点的值和右子树的结果

~~~java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) return 0;
        if (isLeaf(root.left)) return root.left.val + sumOfLeftLeaves(root.right);
        return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);
    }
    public boolean isLeaf(TreeNode root) {
        if (root == null) return false;
        return root.left == null && root.right == null;
    }
}
~~~



### LC [687. 最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path/)

-   思路： 与「二叉树的直径」这题思路几乎一样，区别在于算左右子树的路径长度(深度)时加一个判定条件，即子节点的值要与根节点的值相等。

~~~java
class Solution {
    private int res = 0;
    public int longestUnivaluePath(TreeNode root) {
        maxDepth(root);
        return res;
    }
    public int longestPath(TreeNode root) {
        if (root == null) return 0;
        int leftPath = longestPath(root.left);
        int rightPath = longestPath(root.right);
        /** 错误写法
        int l = (root.left!= null && root.left.val == root.val) ? maxDepth(root.left) : 0;
        int r = (root.right!= null && root.right.val == root.val) ? maxDepth(root.right) : 0;
        这样的话只有根节点左边的值和根节点值相等时才去递归地计算左儿子节点
        **/
        int l = root.left != null && root.left.val == root.val ? leftPath : 0;
        int r = root.right != null && root.right.val == root.val ? rightPath : 0; 
        res = Math.max(res, l + r);
        return Math.max(l, r) + 1;
    }
}
~~~

**对比-二叉树的直径**

~~~java
class Solution {
    private int res = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        maxDepth(root);
        return res;
    }
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        int l = maxDepth(root.left);
        int r = maxDepth(root.right);
        res = Math.max(res, l + r);
        return Math.max(l, r) + 1;
    }
}
~~~





### LC [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

**方法一： 暴力DFS  ——超时**


~~~java
class Solution {
    public int rob(TreeNode root) {
        if (root == null) return 0;
        //selected表示root偷 那么root的儿子就不能偷了 root的孙子才可以偷
        int selected = root.val;
        if (root.left != null) {
            selected += (rob(root.left.left) + rob(root.left.right));
        }
        if (root.right != null) {
            selected += (rob(root.right.left) + rob(root.right.right));
        }
        //notSelected表示root不偷 那么root的儿子可以偷 孙子不可以偷
        int notSelected = rob(root.left) + rob(root.right);
        return Math.max(selected, notSelected);
    }
}
~~~

**方法二： DFS+记忆化搜索**

~~~java
class Solution {
    private HashMap<TreeNode, Integer> map = new HashMap<>();
    public int rob(TreeNode root) {
        if (root == null) return 0;
        if (map.containsKey(root)) return map.get(root);  //
        int selected = root.val;
        if (root.left != null) {
            selected += (rob(root.left.left) + rob(root.left.right));
        }
        if (root.right != null) {
            selected += (rob(root.right.left) + rob(root.right.right));
        }
        int notSelected = rob(root.left) + rob(root.right);
        int res =  Math.max(selected, notSelected);
        map.put(root, res);  //
        return res;
    }
}
~~~

*总结：相较于方法一，引入HashMap实现中间结果存储，减少了一些重复的dfs*

**方法三： DFS+树形DP**

-   思路：

      每个节点可选择偷或者不偷两种状态，根据题目意思，相连节点不能一起偷

    -   当前节点选择偷时，那么两个孩子节点就不能选择偷了
    -   当前节点选择不偷时，两个孩子节点只需要拿最多的钱出来就行(两个孩子节点偷不偷没关系)

    使用一个大小为 2 的数组来表示 int[] res = new int[2]， 0 代表不偷，1 代表偷，任何一个节点能偷到的最大钱的状态可以定义为：

    -   当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱
    -   当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数

~~~java
class Solution {
    public int rob(TreeNode root) {
        int[] result = dfs(root);
        return Math.max(result[0], result[1]);
    }
    public int[] dfs(TreeNode root) {
        if (root == null) return new int[]{0,0};
        int[] left = dfs(root.left);
        int[] right = dfs(root.right);
        int[] res = new int[2];
        //root不偷-->不具体地关心左右子节点是偷还是不偷
        res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        //root偷-->左右子节点不能偷
        res[1] = root.val + left[0] + right[0];
        return res;
    }
}
~~~

*总结：上面两种解法用到了孙子节点，计算爷爷节点能偷的钱还要同时去计算孙子节点投的钱，虽然有了记忆化，但是还是有性能损耗。*



### LC [671. 二叉树中第二小的节点](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/)

**方法一： **

-   思路：易知根节点是全局最小值点，那么知道遍历一遍树，找到不同于根节点值的最小点即可。

~~~java
class Solution {
    private int ans = -1;
    public int findSecondMinimumValue(TreeNode root) {
        if (root == null) return -1;
        dfs(root, root.val);
        return ans;
    }
    public void dfs(TreeNode root, int cur) {
        if (root == null) return;
        if (root.val != cur) {
            ans = ans == -1 ? root.val : Math.min(ans, root.val);
        }
        dfs(root.left, cur);
        dfs(root.right, cur);
    }
}
~~~

**方法二：**

~~~java
class Solution {
    //该函数的作用是求根节点的左右子树中异于根节点值的最小值，然后比较
    public int findSecondMinimumValue(TreeNode root) {
        // if (root == null) return -1;
        if (root.left == null && root.right == null) return -1;
        int left = root.left.val;
        int right = root.right.val;
        //与root值相等的话 一直往下走 直到某节点为叶子节点 或者值与root.val不相等了
        if (left == root.val) left = findSecondMinimumValue(root.left);
        if (right == root.val) right = findSecondMinimumValue(root.right);
        //走到底 都是和root相等的
        if (left == -1) return right;
        if (right == -1) return left;
        return Math.min(left, right);
    }
}
~~~



### LC [637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

~~~java
class Solution {
    public List<Double> averageOfLevels(TreeNode root) {
        Queue<TreeNode> qu = new LinkedList<TreeNode>();
        List<Double> list = new ArrayList<>();
        qu.add(root);
        while(!qu.isEmpty()) {
            int size = qu.size();
            //节点值的范围在32位有符号整数范围内，用int会溢出
            double sum = 0;
            for (int i = 0; i < size; i++) {
                TreeNode tmp = qu.remove();
                sum += tmp.val;
                if (tmp.left != null) qu.add(tmp.left);
                if (tmp.right != null) qu.add(tmp.right);
            }
            //要使得结果是doule，除数和被除数至少有一个是double
            double res = sum / size;  
            list.add(res);
        }
        return list;
    }
}
~~~



### LC [513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

**方法一： DFS+BFS**

-   思路：先通过DFS计算树的深度，然后进行BFS，当遍历到最后一层时输出第一个节点的值。

~~~java
// faster
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        int depth = maxDepth(root);
        if (depth == 1) return root.val;
        Queue<TreeNode> qu = new LinkedList<TreeNode>();
        int cnt = 0;
        qu.add(root);
        while (!qu.isEmpty()) {
            cnt ++;
            int size = qu.size();
            if (cnt == depth) return qu.peek().val;
            for (int i = 0; i < size; i++) {
                TreeNode tmp = qu.remove();
                if (tmp.left != null) qu.add(tmp.left);
                if (tmp.right != null) qu.add(tmp.right);
            }
        }
        return 0; 
    }
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        int l = maxDepth(root.left);
        int r = maxDepth(root.right);
        return Math.max(l, r) + 1;
    }
}
~~~

**方法二：BFS**

-   思路：BFS时记录每层第一个节点的值，将它们压入栈，然后返回栈顶元素即可。

~~~java
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> qu = new LinkedList<TreeNode>();
        Stack<Integer> stack = new Stack<>();
        qu.add(root);
        while (!qu.isEmpty()) {
            int size = qu.size();
            for (int i = 0; i < size; i++) {
                TreeNode tmp = qu.remove();
                if (i == 0) stack.push(tmp.val);
                if (tmp.left != null) qu.add(tmp.left);
                if (tmp.right != null) qu.add(tmp.right);
            }
        }
        return stack.pop(); 
    }
}
~~~

**方法三：改动版BFS**

-   思路：先右后左BFS，这样最后一层的最左节点就是最后遍历到的。

~~~java
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> qu = new LinkedList<TreeNode>();
        qu.add(root);
        TreeNode node = null;
        while (!qu.isEmpty()) {
            node = qu.remove();
            if (node.right != null) qu.add(node.right);
            if (node.left != null) qu.add(node.left);
        }
        return node.val;

    }
}
~~~



### LC [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

**方法一：递归**

~~~java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        preOrder(root, list);
        return list;
    }
    public void preOrder(TreeNode root, List<Integer> list) {
        if (root == null) return;
        list.add(root.val);
        preOrder(root.left, list);
        preOrder(root.right, list);
    }
}
~~~

**方法二： 迭代-栈**

-   思路：首先我们应该创建一个Stack用来存放节点，首先我们想要打印根节点的数据，此时Stack里面的内容为空，所以我们优先将头结点加入Stack，然后打印。之后我们应该先打印左子树，然后右子树。所以先加入Stack的就是右子树，然后左子树。

~~~java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        if (root == null) return new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        List<Integer> list = new ArrayList<>();
        stack.add(root);
        while(!stack.isEmpty()) {
            TreeNode node = stack.pop();
            list.add(node.val);
            if (node.right != null) stack.push(node.right);
            if (node.left != null) stack.push(node.left);
        }
        return list;
    }
}
~~~



### LC [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

**方法一：递归**

~~~java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        postOrder(root, list);
        return list;
    }
    public void postOrder(TreeNode root, List<Integer> list) {
        if (root == null) return;
        postOrder(root.left, list);
        postOrder(root.right, list);
        list.add(root.val);
    }
}
~~~

**方法二：迭代**

-   思路： **先序：根左右**  ----变形---->  **根右左**  ----反转---->  **后序：左右根**

~~~java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        if (root == null) return new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        List<Integer> list = new ArrayList<>();
        stack.add(root);
        while(!stack.isEmpty()) {
            // 先序:根左右 后序:左右根  
            // 因此可以将先序改动一下变成:根右左,再反转成:左右根
            TreeNode node = stack.pop();
            list.add(node.val);
            if (node.left != null) stack.push(node.left);
            if (node.right != null) stack.push(node.right);
        }
        Collections.reverse(list);
        return list;
    }
}
~~~



### LC [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

**方法一：递归**

~~~java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        //左根右
        List<Integer> list = new ArrayList<>();
        inOrder(root, list);
        return list;
    }
    public void inOrder(TreeNode root, List<Integer> list) {
        if (root == null) return;
        inOrder(root.left, list);
        list.add(root.val);
        inOrder(root.right, list);
    }
}
~~~

**方法二：迭代**

~~~java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        if (root == null) return new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        List<Integer> list = new ArrayList<>();
        TreeNode node = root;
        TreeNode cur  = null;
        while(node != null || !stack.isEmpty()) {
            // 中序:左根右
            // 先把左子节点左压入栈
            while (node != null) {
                stack.push(node);
                node = node.left;
            }
            //走到底了，弹出一个处理
            cur = stack.pop();
            list.add(cur.val);
            // 然后指向该节点了右子节点，继续压入右自己点的左儿子
            node = cur.right;
        }
        return list;
    }
}
~~~



### LC [669. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)

-   思路

    递归三部曲：

    1.确定递归函数的参数以及返回值

    因为是要遍历整棵树，做修改，其实不需要返回值也可以，我们也可以完成修剪（其实就是从二叉树中移除节点）的操作，但是有返回值有返回值的话，可以利用返回值完成下层满足条件的节点与其父节点的赋值操作，同时起到了移除节点的作用。

    2.确定终止条件

    修剪的操作并不是在终止条件上进行的，所以就是遇到空节点返回就可以了。

    3.确定单层递归的逻辑

    如果root（当前节点）的元素小于low的数值，那么应该递归右子树，并返回右子树符合条件的头结点；如果root(当前节点)的元素大于high的，那么应该递归左子树，并返回左子树符合条件的头结点。接下来要将下一层处理完左子树的结果赋给root.left，处理完右子树的结果赋给root.right，最后返回root节点。

~~~java
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if (root == null) return null;
        //如果root（当前节点）的元素小于low的数值，则该节点及左子树的节点都小于low,那么修剪后的BST应该在右子树中,因此递归右子树，并返回右子树符合条件的头结点。
        if (root.val < low) return trimBST(root.right, low, high);
        //如果root(当前节点)的元素大于high的，则该节点及右子树的节点都大于high,那么修剪后的BST应该在左子树中,因此递归左子树，并返回左子树符合条件的头结点。
        if (root.val > high) return trimBST(root.left, low, high);
        //根节点符合了,接下来要将下一层处理完左子树的结果赋给root->left，处理完右子树的结果赋给root->right。
        //这里相当于用root.left和root.right把下层找到的符合条件的节点接住，起到了删除节点的作用。
        root.left = trimBST(root.left, low, high);
        root.right = trimBST(root.right, low, high);
        return root;
    }
}
~~~



### LC [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

**方法一：中序遍历**

-   思路：BST的中序遍历序列是递增的，那么只要中序遍历获取前k个，第k个即为答案。

~~~java
class Solution {
    private List<Integer> list  = new ArrayList<>();
    public int kthSmallest(TreeNode root, int k) {
        inOrder(root, k);
        return list.get(k-1);
    }
    public void inOrder(TreeNode root, int k) {
        if (root == null) return;
        inOrder(root.left, k);
        list.add(root.val);
        if (list.size() >= k) return;
        inOrder(root.right, k);
    }
}
~~~

**方法二：递归**

-   思路：答案节点的左子树应该是有k-1个节点

~~~java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        int leftCnt = count(root.left);
        if (leftCnt == k - 1) return root.val;
        else if (leftCnt > k - 1) return kthSmallest(root.left, k);
        //根节点的左子树和根节点已经有leftCnt+1个了，因此在右子树上的答案节点的左子树应该有(k-leftCnt-1)个节点
        else return kthSmallest(root.right, k - leftCnt - 1);
    }
    public int count(TreeNode root){
        if (root == null) return 0;
        return 1 + count(root.left) + count(root.right);
    }
}
~~~



**!!!方法三：记录子树的结点数**

~~~java
//进阶写法，适合经常对BST进行增删的情况
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        MyBst bst = new MyBst(root);
        return bst.kthSmallest(k);
    }
}

class MyBst {
    TreeNode root;
    Map<TreeNode, Integer> nodeNum;

    public MyBst(TreeNode root) {
        this.root = root;
        this.nodeNum = new HashMap<TreeNode, Integer>();
        countNodeNum(root);
    }

    // 返回二叉搜索树中第k小的元素
    public int kthSmallest(int k) {
        TreeNode node = root;
        while (node != null) {
            int left = getNodeNum(node.left);
            if (left < k - 1) {
                node = node.right;
                k -= left + 1;
            } else if (left == k - 1) {
                break;
            } else {
                node = node.left;
            }
        }
        return node.val;
    }

    // 统计以node为根结点的子树的结点数
    private int countNodeNum(TreeNode node) {
        if (node == null) {
            return 0;
        }
        nodeNum.put(node, 1 + countNodeNum(node.left) + countNodeNum(node.right));
        return nodeNum.get(node);
    }

    // 获取以node为根结点的子树的结点数
    private int getNodeNum(TreeNode node) {
        return nodeNum.getOrDefault(node, 0);
    }
}
~~~



### LC [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

-   思路：中序遍历序列是递增的，那么镜像一下得到的就是递减的遍历顺序，即可完成累加操作。

~~~java
class Solution {
    private int sum = 0;
    public TreeNode convertBST(TreeNode root) {
        inOrderRev(root);
        return root;
    }
    public void inOrderRev(TreeNode root) {
        if (root == null) return;
        inOrderRev(root.right);
        sum += root.val;
        root.val = sum;
        inOrderRev(root.left);
    }
}
~~~



### LC [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

-   思路：

    1.若p的值小于root的值，q的值大于根的值，那么root就是最近公共祖先。

    2.若p的值和q的值都小于root的值，那么代表最近祖先一定在root的左子树中

    3.若p的值和q的值都大于root的值，那么代表最近祖先一定在root的右子树中

    2.3情况发生的话，只需要继续递归即可，而 1则是递归出口。

~~~java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root.val < p.val && root.val < q.val)
            return lowestCommonAncestor(root.right, p, q);
        if(root.val > p.val && root.val > q.val)
            return lowestCommonAncestor(root.left, p, q);
        return root;
    }
}
~~~



### LC [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

~~~java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        int len = nums.length;
        return buildBST(nums, 0, len - 1);
    }
    public TreeNode buildBST(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }
        int mid = left + right >> 1;
        // System.out.print(mid);
        TreeNode root = new TreeNode(nums[mid]);
        root.left = buildBST(nums, left, mid - 1);
        root.right = buildBST(nums, mid + 1, right);
        return root;
    }
}
~~~





### LC [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)

~~~java
class Solution {
    public TreeNode sortedListToBST(ListNode head) {
        return buildBST(head);

    }
    public TreeNode buildBST(ListNode head) {
        if (head == null) return null;
        if (head.next == null) return new TreeNode(head.val);
        ListNode preMid = preMid(head); // -3
        ListNode mid = preMid.next;  // 0
        preMid.next = null;
        TreeNode root = new TreeNode(mid.val);
        root.left = buildBST(head);
        root.right = buildBST(mid.next);
        return root;
    }
    public ListNode preMid(ListNode head) {
        ListNode slow = head, fast = head.next;
        ListNode pre = head;
        while (fast != null && fast.next != null) {
            pre = slow;
            slow = slow.next;
            fast = fast.next.next;
        }
        return pre;
    }
}
~~~



### LC [653. 两数之和 IV - 输入 BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)

~~~java
class Solution {
    private List<Integer> list = new ArrayList<>();
    public boolean findTarget(TreeNode root, int k) {
        inOrder(root);
        int i = 0, j = list.size() - 1;
        while (i < j) {
            if (list.get(i) + list.get(j) == k) return true;
            if (list.get(i) + list.get(j) > k) j--;
            if (list.get(i) + list.get(j) < k) i++;
        }
        return false;

    }
    public void inOrder(TreeNode root) {
        if (root == null) return;
        inOrder(root.left);
        list.add(root.val);
        inOrder(root.right);
    }
}
~~~



### LC [530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

**方法一： 一次遍历**

~~~java
class Solution {
    private List<Integer> list = new ArrayList<>();
    public int getMinimumDifference(TreeNode root) {
        inOrder(root);
        int min = Integer.MAX_VALUE;
        for (int i = 0, j = 1; j < list.size(); i++, j++) {
            int num = list.get(j) - list.get(i);
            min = Math.min(min, num);
        }
        return min;
    }
    public void inOrder(TreeNode root) {
        if (root == null) return;
        inOrder(root.left);
        list.add(root.val);
        inOrder(root.right);
    }
}
~~~

**方法二： 两次中序遍历**

~~~java
class Solution {
    private int min = Integer.MAX_VALUE;
    private TreeNode preNode = null;
    public int getMinimumDifference(TreeNode root) {
        inOrder(root);
        return min;
    }
    public void inOrder(TreeNode root) {
        if (root == null) return;
        inOrder(root.left);
        if (preNode != null) {
            int num = root.val - preNode.val;
            min = Math.min(min, num);
        }
        preNode = root;
        inOrder(root.right);
    }
}
~~~





### LC [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

-   思路：中序遍历BST，由于是有序的，所以相同值的肯定是连续的；用curCnt记录当前值的个数，用当前值和前一个节点的值preNode.val比较，若相同再curCnt自增1，若不同则curCnt更正为1；再维护一个全局节点数最大值maxCnt；利用list集合记录节点数最多的值是哪几个。

~~~java
class Solution {
    private List<Integer> list = new ArrayList<>();
    private TreeNode preNode = null;
    private int maxCnt = 1;
    private int curCnt = 1;
    public int[] findMode(TreeNode root) {
        inOrder(root);
        int[] res = new int[list.size()];
        int idx = 0;
        for (int num : list) res[idx ++] = num;
        return res;
    }
    public void inOrder(TreeNode root) {
        if (root == null) return;
        inOrder(root.left);
        // 遍历第一个节点是不需要改动curCnt和maxCnt的值
        if (preNode != null) curCnt = root.val == preNode.val ? curCnt + 1 : 1;
        if (curCnt > maxCnt) {
            maxCnt = curCnt;
            list.clear();
            list.add(root.val);
        }
        else if (curCnt == maxCnt) list.add(root.val);
        preNode = root;
        inOrder(root.right);
    }
}
~~~



### LC [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

<img src="alg-img/Trie树2.png" width="550px">

<img src="alg-img/Trie树.png" width="550px">

-   思路：

    ~~~java
    class Trie {
    	private Trie[] childs;  // 每个Trie节点都有26个孩子，对应26个字母
        private boolean isLeaf;  // 用来作为一个单词结束的标记，否则只能知道有单词的前缀符合这条路径上的组成，无法确定其是不是在这里终止
    }
    ~~~

    ​	

**方法一： 遍历**

~~~java
class Trie {
    
    private Trie[] children;
    private boolean isLeaf;

    public Trie() {
        children = new Trie[26];
        isLeaf = false;
    }
    
    public void insert(String word) {
        Trie p = this;
        for (int i = 0; i < word.length(); i ++) {
            char ch = word.charAt(i);
            int idx = ch - 'a';
            if (p.children[idx] == null) {
                p.children[idx] = new Trie();
            }
            p = p.children[idx];
        }
        p.isLeaf = true;
    }
    
    public boolean search(String word) {
        Trie p = this;
        for (int i = 0; i < word.length(); i ++) {
            char ch = word.charAt(i);
            int idx = ch - 'a';
            if (p.children[idx] == null) {
                return false;
            }
            p = p.children[idx];
        }
        return p.isLeaf == true;  // 区别
    }
    
    public boolean startsWith(String prefix) {
        Trie p = this;
        for (int i = 0; i < prefix.length(); i ++) {
            char ch = prefix.charAt(i);
            int idx = ch - 'a';
             if (p.children[idx] == null) {
                return false;
            }
            p = p.children[idx];
        }
        return true;
    }
}
~~~

### LC [677. 键值映射](https://leetcode-cn.com/problems/map-sum-pairs/)

~~~java
class MapSum {

    private class TrieNode {
        TrieNode[] children = new TrieNode[26];
        // 题目约定了val值大于0，所以，这里用0作为默认值，表示不是key的节点(表示不是一个单词)
        int val = 0;
    }

    private TrieNode root;

    public MapSum() {
        this.root = new TrieNode();
    }
    
    public void insert(String key, int val) {
        TrieNode p = this.root;
        for(int i = 0; i < key.length(); i++) {
            char ch = key.charAt(i);
            int idx = ch - 'a';
            if (p.children[idx] == null) {
                p.children[idx] = new TrieNode();
            }
            p = p.children[idx];
        }
        p.val = val;

    }
    
    public int sum(String prefix) {
        TrieNode p = this.root;
        for(int i = 0; i < prefix.length(); i++) {
            char ch = prefix.charAt(i);
            int idx = ch - 'a';
            if (p.children[idx] == null) {
                return 0;
            }
            p = p.children[idx];
        }
        // 此时p停在了prefix的最后一个字母的位置上，如'ap'的'p'的位置上
        // 下面要将'p'位置上的值，以及p后面所有的字符串的值都加进来，因为他们都是以'ap'开头的
        return dfs(p);

    }
	// 将'p'位置上的值，以及p后面所有的字符串的值都加进来，因为他们都是以'ap'开头的
    int dfs(TrieNode node) {
        if (node == null) return 0;
        int ans = 0;
        if (node.val > 0) //如果自身是个单词
        	ans += node.val;  // 先将自身的值加进去
        for (TrieNode p : node.children) {  // 然后深度遍历以prefix开头的所有单词
            ans += dfs(p);
        }
        return ans;

    }
}

参考：
作者：tong-zhu
链接：https://leetcode-cn.com/problems/map-sum-pairs/solution/tong-ge-lai-shua-ti-la-zi-dian-shu-qing-h4x2x/
~~~

### 对比：LC [440. 字典序的第K小数字](https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/)

**方法一：字典树**

~~~java

~~~



### LC [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

**方法一：暴力哈希**

~~~java
class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) return false;
        int[] a = new int[26];
        int[] b = new int[26];
        int length = s.length();
        for (int i = 0; i < length; i++) {
            int idx1 = s.charAt(i) - 'a';
            int idx2 = t.charAt(i) - 'a';
            a[idx1] ++;
            b[idx2] ++;
        }
        for (int i = 0; i < 26; i++) {
            if (a[i] != b[i]) return false;
        }
        return true;
    }
}
~~~

**方法二：改进的哈希**

-   思路：先遍历记录字符串 s 中字符出现的频次，然后遍历字符串 t，减去table中对应的频次，如果出现table[i]<0，则说明 t 包含一个不在 s 中的额外字符，返回 false 即可。

~~~java
class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) return false;
        int[] cnt = new int[26];
        int length = s.length();
        for (int i = 0; i < length; i++) {
            int idx = s.charAt(i) - 'a';
            cnt[idx] ++;
        }
        for (int i = 0; i < length; i++) {
            int idx = t.charAt(i) - 'a';
            cnt[idx] --;
            if (cnt[idx] < 0) return false;
        }
        return true;
    }
}
~~~

*拓展：进阶问题的核心点在于「字符是离散未知的」，因此我们用哈希表(HashMap)维护对应字符的频次即可。*

~~~java
// 参考代码：
class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }
        Map<Character, Integer> table = new HashMap<Character, Integer>();
        for (int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);
            table.put(ch, table.getOrDefault(ch, 0) + 1);
        }
        for (int i = 0; i < t.length(); i++) {
            char ch = t.charAt(i);
            table.put(ch, table.getOrDefault(ch, 0) - 1);
            if (table.get(ch) < 0) {
                return false;
            }
        }
        return true;
    }
}
~~~

**方法三：排序**

~~~java
class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) return false;
        char[] s1 = s.toCharArray();
        char[] t1 = t.toCharArray();
        Arrays.sort(s1);
        Arrays.sort(t1);
        return Arrays.equals(s1, t1);
    }
}
~~~



### LC [409. 最长回文串](https://leetcode-cn.com/problems/longest-palindrome/)

-   思路：回文串是一个正着读和反着读都一样的字符串。以回文中心为分界线，对于回文串中左侧的字符 ch，在右侧对称的位置也会出现同样的字符。例如在字符串 "abba" 中，回文中心是 "ab|ba" 中竖线的位置，而在字符串 "abcba" 中，回文中心是 "ab(c)ba" 中的字符 "c" 本身。我们可以发现，在一个回文串中，只有最多一个字符出现了奇数次，其余的字符都出现偶数次。

~~~java
class Solution {
    public int longestPalindrome(String s) {
        // 记录每个字母出现的次数
        int[] count = new int[128];
        for (char ch : s.toCharArray()) {
            count[ch] ++;
        }
        // 数一下有多少个奇数
        int sum = 0;
        for (int i : count) {  
            sum += (i % 2);
        }
        // 若sum==0,说明所有字母都出现偶数次，则刚好可以构成回文串
        // 若sum>0,说明有字母出现了奇数次，但是只有最多一个字母在回文串中出现奇数次，即最中间的那个字母，即该字母可以保留原有个数，而其他字母必须各减去1个变成偶数次从而构造回文串(因此一共需要减去sum-1个字符)
        return sum == 0 ? s.length() : s.length() - sum + 1;
    }
}
~~~



### LC [205. 同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/) 

**方法一：双向映射**

-   思路：维护两张哈希表，记录两个字符串的双向映射关系，必须都一致；如果只维护单向的映射关系是不可以的，详解举例如下：

    ~~~
    egg 和 add 同构，就意味着下边的映射成立
    e -> a
    g -> d
    也就是将 egg 的 e 换成 a, g 换成 d, 就变成了 add
    
    同时倒过来也成立
    a -> e
    d -> g
    也就是将 add 的 a 换成 e, d 换成 g, 就变成了 egg
    
    foo 和 bar 不同构，原因就是映射不唯一
    o -> a
    o -> r
    其中 o 映射到了两个字母
    
    如果验证一个方向，是不可以的。
    
    举个例子，s = ab, t = cc，如果单看 s -> t ，那么 a -> c, b -> c 是没有问题的。
    
    必须再验证 t -> s，此时，c -> a, c -> b，一个字母对应了多个字母，所以不是同构的。
    ~~~

~~~java
class Solution {
    public boolean isIsomorphic(String s, String t) {
        Map<Character,Character> s2t = new HashMap<>();
        Map<Character,Character> t2s = new HashMap<>();
        for (int i = 0; i < s.length(); i++) {
            char a = s.charAt(i);
            char b = t.charAt(i);
            if (s2t.containsKey(a) && s2t.get(a) != b || t2s.containsKey(b) && t2s.get(b) != a) return false;
            s2t.put(a, b);
            t2s.put(b, a);
        }
        return true;
    }
}
~~~

**方法二：按序编号**

-   思路：给两个字符串中的字符分别按照在各自串中的出现次序编号 最终两个串的编号应该完全相同

~~~java
class Solution {
    public boolean isIsomorphic(String s, String t) {
        int[] a = new int[128];
        int[] b = new int[128];
        int cnt = 1;
        for (int i = 0; i < s.length(); i++) {
            int idx_a, idx_b;
            // s串该位置的编号
            if (a[s.charAt(i)] == 0) {
                idx_a = cnt;
                a[s.charAt(i)] = cnt;
            } else {
                idx_a = a[s.charAt(i)];
            }
            // t串该位置的编号
            if (b[t.charAt(i)] == 0) {
                idx_b = cnt;
                b[t.charAt(i)] = cnt;
            } else {
                idx_b = b[t.charAt(i)];
            }
            // 边走边判断 编号应处处相同
            if (idx_a != idx_b) return false;  
            cnt ++;
        }
        return true;
    }
}
~~~



### LC [647. 统计字符串中回文子串的数目](https://leetcode-cn.com/problems/palindromic-substrings/)

**方法一：暴力法**

~~~java
class Solution {
    public int countSubstrings(String s) {
        int ans = 0;
        for (int i = 0; i < s.length(); i++) {
            for (int j = i; j < s.length(); j++) {
                String subStr = s.substring(i, j+1);
                if (isPalindrome(subStr)) ans ++;

            }
        }
        return ans;
    }
    public boolean isPalindrome(String s) {
        for (int i = 0, j = s.length() - 1; i < j; i++, j--) {
            if (s.charAt(i) != s.charAt(j)) return false;
        }
        return true;
    }
}
~~~



**方法二：中心拓展法**

-   思路：

    ~~~
    比如对一个字符串 ababa，选择最中间的 a 作为中心点，往两边扩散，第一次扩散发现 left 指向的是 b，right 指向的也是 b，所以是回文串，继续扩散，同理 ababa 也是回文串。
    这个是确定了一个中心点后的寻找的路径，然后我们只要寻找到所有的中心点，问题就解决了。
    中心点一共有多少个呢？看起来像是和字符串长度相等，但你会发现，如果是这样，上面的例子永远也搜不到 abab，想象一下单个字符的哪个中心点扩展可以得到这个子串？似乎不可能。所以中心点不能只有单个字符构成，还要包括两个字符，比如上面这个子串 abab，就可以有中心点 ba 扩展一次得到，所以最终的中心点由 2 * len - 1 个，分别是 len 个单字符和 len - 1 个双字符。
    
    为什么不可能是三个或者更多？
    - 因为 3 个可以由 1 个扩展一次得到，4 个可以由两个扩展一次得到
    ~~~

    


~~~java
class Solution {
    public int countSubstrings(String s) {
        int n = s.length();
        int ans = 0;
        for (int k = 0; k < n; k++) {
            int i , j;
            // 回文中心为一个字符:k
            i = k ;
            j = k ;
            while (i >= 0 && j < n && s.charAt(i--) == s.charAt(j++)) ans ++;
            //回文中心为两个字符:k,k+1
            i = k;
            j = k + 1;
            while (i >= 0 && j < n && s.charAt(i--) == s.charAt(j++)) ans ++;
        }
        return ans;
    }
}
~~~



### 对比：LC [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

**方法一：中心扩展法**

~~~java
class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        int ans = 1;
        int l = 0, r = 0;
        for (int k = 0; k < n; k++) {
            int i, j;
            // 回文中心为一个字符:k
            i = k ;
            j = k ;
            while (i >= 0 && j < n && s.charAt(i) == s.charAt(j)) {
                if (j - i + 1 > ans) {
                    ans = j - i + 1;
                    l = i;
                    r = j;
                }
                i --;
                j ++;
            }
            //回文中心为两个字符:k,k+1
            i = k;
            j = k + 1;
            while (i >= 0 && j < n && s.charAt(i) == s.charAt(j)){
                if (j - i + 1 > ans) {
                    ans = j - i + 1;
                    l = i;
                    r = j;
                }
                i --;
                j ++;
            }
        }
        return s.substring(l, r + 1);
    }
}
~~~





**方法二：动态规划法**

- 思路：

    ~~~
    
    ~~~

~~~java
public class Solution {

    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }

        int maxLen = 1;
        int begin = 0;
        // dp[i][j] 表示 s[i..j] 是否是回文串
        boolean[][] dp = new boolean[len][len];
        // 初始化：所有长度为 1 的子串都是回文串
        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }

        char[] charArray = s.toCharArray();
        // 递推开始
        // 先枚举子串长度
        for (int L = 2; L <= len; L++) {
            // 枚举左边界，左边界的上限设置可以宽松一些
            for (int i = 0; i < len; i++) {
                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                int j = L + i - 1;
                // 如果右边界越界，就可以退出当前循环
                if (j >= len) {
                    break;
                }

                if (charArray[i] != charArray[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
~~~



### LC [9. 判断回文数](https://leetcode-cn.com/problems/palindrome-number/)

~~~java
class Solution {
    public boolean isPalindrome(int x) {
        String s  = x + "";
        for (int i = 0, j = s.length() - 1; i < j; i++, j--) {
            if (s.charAt(i) != s.charAt(j)) return false;
        }
        return true;
    }
}
~~~



### LC [696. 计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings/)

**方法一：中心拓展法(略暴力)**

~~~java
class Solution {
    public int countBinarySubstrings(String s) {
        System.out.print(s);
        int ans = 0;
        for (int k = 0; k < s.length() - 1; k++) {
            // if (k< s.length()
            if (s.charAt(k) != s.charAt(k+1)) {
                int l = k, r = k + 1;
                while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(k) && s.charAt(r) == s.charAt(k + 1)) {
                    ans ++;
                    l --;
                    r ++;
                }
            }
        }
        return ans;
    }
}
~~~

**方法二：分组法**

-   思路：

    ~~~markdown
    我们可以将字符串s按照0和1的连续段分组，存在counts数组中，例如 s = 00111011，可以得到这样的counts数组counts={2,3,1,2}。
    这里counts数组中两个相邻的数一定代表的是两种不同的字符。假设counts数组中两个相邻的数字为u或者v，它们对应着u个0和v个1，或者 u个1和v个0。它们能组成的满足条件的子串数目为min{u,v}，即一对相邻的数字对答案的贡献。
    我们只要遍历所有相邻的数对，求它们的贡献总和，即可得到答案。
    ~~~

~~~java
class Solution {
    public int countBinarySubstrings(String s) {
        List<Integer> counts = new ArrayList<Integer>();
        int i = 0;
        while (i < s.length()) {
            int j = i + 1;
            while (j < s.length() && s.charAt(j) == s.charAt(i)) j++;
            counts.add(j - i);
            i = j;
        }
        int ans = 0;
        for (int k = 1; k < counts.size(); k++) {
            ans += Math.min(counts.get(k - 1), counts.get(k));
        }
        return ans;
    }
}
~~~

**方法三：**

~~~java
class Solution {
    public int countBinarySubstrings(String s) {
        int preLen = 0, curLen = 1, count = 0;
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == s.charAt(i - 1)) {
                curLen++;
            } else {
                preLen = curLen;
                curLen = 1;
            }
            if (preLen >= curLen) {
                count++;
            }
        }
        return count;
    }
}
~~~



###  LC [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

-   思路：使用哈希表，可以将寻找 target - x 的时间复杂度降低到从O(N)降低到O(1)。这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。

~~~java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();  //(值，索引)
        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(target - nums[i])) {
                return new int[]{map.get(target - nums[i]), i};
            }
            map.put(nums[i], i);
        }
        return new int[0];
    }
}
~~~



### LC [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

~~~java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();  // 值, 个数
        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(nums[i])) return true;
            else map.put(nums[i],1);
        }
        return false;
    }
}
~~~

这里无需Map，改用Set(或者List也行):

~~~java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        Set<Integer> set = new HashSet<>();;  // 值, 个数
        // int len = nums.length;
        // int[] cnt = new int[len + 10];
        for (int i = 0; i < nums.length; i++) {
            if (set.contains(nums[i])) return true;
            else set.add(nums[i]);
        }
        return false;
    }
}
~~~



### LC [594. 最长和谐子序列](https://leetcode-cn.com/problems/longest-harmonious-subsequence/)

-   思路：

    ~~~
    题目规定的「和谐子序列」中的最值差值正好为1，因而子序列排序后必然符合[a,a,..,a+1,a+1]形式，即符合条件的和谐子序列长度为相邻两数（差值为1) 的出现次数之和。
    我们可以使用「哈希表」记录所有nums[i] 的出现次数，然后通过O(n) 的复杂度找出所有可能的数对（两数差值为1)，并在所有符合条件的数对所能构成的「和谐子序列」长度中取最大值。
    ~~~

~~~java
class Solution {
    public int findLHS(int[] nums) {
        // 1 2 2 2 3 3 5 7
        // 0 2 3 5 1 6 4 7
        int ans = 0;
        // 用哈希表记录某个数字在数组中出现了几次
        Map<Integer, Integer> map = new HashMap<>();  // 值，个数
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        for (int key : map.keySet()) {
            if (map.containsKey(key - 1)) {
                ans = Math.max(ans, map.get(key) + map.get(key - 1));
            }
        }
        return ans;
    }
}
~~~





### LC [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/) 

**方法一： 哈希**

-   思路：用哈希表记录以一个数字作为开始或者结尾的最长连续序列长度，然后遍历时分别查看前一个数字和后一个数字在不在哈希表中，这就起到了将前后两端连接起来的作用。

~~~java
class Solution {
    public int longestConsecutive(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();  // map里记录以key开头或结尾的最长连续序列长度
        int ans = 0;
        for (int num : nums) {
            if (!map.containsKey(num)) {
                map.put(num, 1);  // 只是为了做一个标记，证明出现过了
                int left = map.getOrDefault(num - 1, 0);  // 以num - 1结尾的最长连续序列长度
                int right = map.getOrDefault(num + 1, 0);  // 以num + 1开始的最长连续序列长度
                int curLen = left + right + 1;  // 由于num的出现左右两端被连通了
                ans = Math.max(ans, curLen);
                map.put(num - left, curLen);  // 更新当前连续序列左端点的值
                map.put(num + right, curLen);  // 更新当前连续序列右端点的值
            }
        }
        return ans;
    }
}
~~~



**方法二：哈希集合去重**

-   思路：将所有元素放到集合中去重；每次取出一个数，要求集合中不存在比该数小1的数，这样即可以保证该数是某一连续序列的第一个数，然后求该连续序列的长度。

~~~java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();  // map里记录以key开头或结尾的最长连续序列长度
        int ans = 0;
        for (int num : nums) set.add(num);
        for (int num : set) {
            if (!set.contains(num - 1)) {  // 确保num是某一连续子序列的第一个数字
                int curLen = 1;
                while (set.contains(num + 1)) {
                    curLen ++;
                    num ++;
                }
                ans = Math.max(ans, curLen);
            }
        }
        return ans;
    }
}
~~~



### LC [785. 判断二分图](https://leetcode-cn.com/problems/is-graph-bipartite/)

**方法一：染色法**

-   思路：

    ~~~
    首先任意取出一个顶点进行染色，和该节点相邻的点有三种情况:
    1.如果未染色，那么继续染色此节点（染为另一种颜色）
    2.如果已染色但和当前节点颜色不同，则跳过该点
    3.如果已染色并且和当前节点颜色相同，返回失败(该图不是二分图)
    ~~~

~~~java
class Solution {
    public boolean isBipartite(int[][] graph) {
        int size = graph.length;
        int[] color = new int[size];  // 0表示未染色 1表示黑色 2表示白色
        for (int i = 0; i < size; i++) {
            // 如果节点i还没有被染色 对其通过dfs染色
            if (color[i] == 0) {
                if (!dfs(graph, color, i, 1)) return false;
                //上面为何可以每次都染成1？因为当前节点未被染过色，说明与此前染成1色的节点肯定不相邻，所以可以放心的染成1色，染成2色也行，同理
            }
        }
        return true;
    }
    public boolean dfs(int[][] graph, int[] color, int u, int c) {  
        // 将节点u染成c色
        color[u] = c;
        // 然后dfs染色其相邻节点
        for (int node : graph[u]) {
            // 如果相邻节点node还没有被染色
            if (color[node] == 0) {
                // 将其染成相反的颜色
                if (!dfs(graph, color, node, 3 - c)) return false;
            }
            // 如果相邻节点node已经被染过色了，且颜色与当前节点染的颜色一样，那么有冲突了，报false
            else if (color[node] == c) return false;
        }
        return true;
    }
}
~~~

*可以用染色法的图一定是二分图*



### LC [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)

**方法一：BFS**

-   思路：

~~~java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<List<Integer>> graph = new ArrayList<>();
        int[] indgree = new int[numCourses];  // 记录每个节点的入度
        Queue<Integer> qu = new LinkedList<>();  // 用一个队列来记录入度为0的节点
        int cnt = 0; //记录入度为0的节点数
        for (int i = 0; i < numCourses; i++) {
            graph.add(new ArrayList<Integer>());
        }
        // 构造图
        for (int[] cp: prerequisites) {  //[[1,0],[0,1]]  --> 0->1、1->0
            graph.get(cp[1]).add(cp[0]);  // cp[1]是先修课程 cp[0]是后修课程  1指向0
            indgree[cp[0]] ++;  // 被指向的边入度加一
        }
        // 初始化：将所有入度为0的节点加入队列
        for (int i = 0; i < numCourses; i++) {
            if (indgree[i] == 0) {
                qu.add(i);
            }
        }
        // bfs
        while (!qu.isEmpty()) {
            int node = qu.poll();
            cnt ++;
            for (int v : graph.get(node)) {
                indgree[v] --;
                if (indgree[v] == 0) qu.add(v);
            }
        }
        return cnt == numCourses;
    }
}
~~~



**方法二：DFS**

-   思路：

~~~java
class Solution {
    List<List<Integer>> graph;
    int[] visited;
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        graph = new ArrayList<List<Integer>>();
        visited = new int[numCourses];  // 记录节点的状态 0表示未访问 1表示递归搜索中 2表示搜索完成
        for (int i = 0; i < numCourses; i++) {
            graph.add(new ArrayList<Integer>());
        }
        // 构造图
        for (int[] cp: prerequisites) {  //[[1,0],[0,1]]  --> 0->1、1->0
            graph.get(cp[1]).add(cp[0]);  // cp[1]是先修课程 cp[0]是后修课程  1指向0
        }
        // 对所有没搜索过的节点进行dfs处理
        for (int i = 0; i < numCourses; i++) {
            if (visited[i] == 0) {
                if (!dfs(i)) return false;
            }
        }
        return true;
    }

    public boolean dfs(int u) {
        visited[u] = 1;  // 搜索中
        // * 这里是对相邻节点的递归处理
        for (int v : graph.get(u)) {
            if (visited[v] == 0) {
                if (!dfs(v)) return false;  // 下层递归过程中出现矛盾
            }
            else if (visited[v] == 1) return false;  // 出现环
        }
        // * 相邻节点都处理完成了 回溯到节点u
        visited[u] = 2;  // 回溯 搜索完成
        return true;
    }
}
~~~





### LC [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

**方法一：BFS**

-   思路：

~~~java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        List<List<Integer>> graph = new ArrayList<>();
        int[] indgree = new int[numCourses];  // 记录每个节点的入度
        Queue<Integer> qu = new LinkedList<>();  // 用一个队列来记录入度为0的节点
        int cnt = 0; //记录入度为0的节点数
        int[] res = new int[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph.add(new ArrayList<Integer>());
        }
        // 构造图
        for (int[] cp: prerequisites) {  //[[1,0],[0,1]]  --> 0->1、1->0
            graph.get(cp[1]).add(cp[0]);  // cp[1]是先修课程 cp[0]是后修课程  1指向0
            indgree[cp[0]] ++;  // 被指向的边入度加一
        }
        // 初始化：将所有入度为0的节点加入队列
        for (int i = 0; i < numCourses; i++) {
            if (indgree[i] == 0) {
                qu.add(i);
            }
        }
        // bfs
        while (!qu.isEmpty()) {
            int node = qu.poll();
            res[cnt ++] = node;  // 出队的即是没有入边的节点，意味着现在就可以放心学习了
            // cnt ++;
            for (int v : graph.get(node)) {
                indgree[v] --;
                if (indgree[v] == 0) qu.add(v);
            }
        }
        if (cnt == numCourses) return res;
        else return new int[]{};

    }
}
~~~



**方法二： DFS**

-   思路：

~~~java
class Solution {
    List<List<Integer>> graph;
    int[] visited;
    Stack<Integer> stack;
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        graph = new ArrayList<List<Integer>>();
        visited = new int[numCourses];  // 记录节点的状态 0表示未访问 1表示递归搜索中 2表示搜索完成
        stack = new Stack<>();
        for (int i = 0; i < numCourses; i++) {
            graph.add(new ArrayList<Integer>());
        }
        // 构造图
        for (int[] cp: prerequisites) {  //[[1,0],[0,1]]  --> 0->1、1->0
            graph.get(cp[1]).add(cp[0]);  // cp[1]是先修课程 cp[0]是后修课程  1指向0
        }
        // 对所有没搜索过的节点进行dfs处理
        for (int i = 0; i < numCourses; i++) {
            if (visited[i] == 0) {
                if (!dfs(i)) return new int[]{};
            }
        }
		// 可以拓扑排序，整理答案
        int[] res = new int[numCourses];
        int cnt = 0;
        while (!stack.isEmpty()) res[cnt++] = stack.pop();
        return res;
    }

    public boolean dfs(int u) {
        visited[u] = 1;  // 搜索中
        // * 这里是对相邻节点的递归处理
        for (int v : graph.get(u)) {
            if (visited[v] == 0) {
                if (!dfs(v)) return false;  // 下层递归过程中出现矛盾
            }
            else if (visited[v] == 1) return false;  // 出现环
        }
        // * 相邻节点都处理完成了 回溯到节点u
        visited[u] = 2;  // 回溯 搜索完成
        stack.push(u);
        return true;
    }
}
~~~



### LC [684. 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)

**方法一：并查集**

-   思路：有n个节点，那么构成树的话只需要n-1条边，而实际给出n条边，意味着只有一条边是多余的；除了多余的那条边，将其他两条边的两端节点加入同一集合时应该都刚好使得这两个节点连通且不会造成环路，因此只需要遍历每条边，将其两端节点并起来，一旦遇到某一个边的两端节点已经连通了，那么其就是冗余边。

    ~~~
    在一棵树中，边的数量比节点的数量少1。如果一棵树有n个节点，则这棵树有n−1条边。这道题中的图在树的基础上多了一条附加的边，因此边的数量也是n。
    树是一个连通且无环的无向图，在树中多了一条附加的边之后就会出现环，因此附加的边即为导致环出现的边。
    可以通过并查集寻找附加的边。初始时，每个节点都属于不同的连通分量。遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量。
    如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。
    如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。
    ~~~

~~~java
class Solution {
    private int[] p;
    public int[] findRedundantConnection(int[][] edges) {
        // 实际给出n条边，那么构成树的话只需要n-1条边，则有n个节点
        int n = edges.length;
        p = new int[n + 1];  // 节点编号为1~n
        for (int i = 0; i < n + 1; i++) p[i] = i;
        for (int[] edge : edges) {
            if (find(edge[0]) != find(edge[1])) {  // 不连通的话 将其连通
                union(edge[0], edge[1]);
            } else {  // 已经连通了，那么这条边加进去会造成环，是多余的
                return edge;
            }
        }
        return new int[0];
    }

    public int find(int a) {
        if (p[a] != a) {  // 不是根节点的话
            p[a] = find(p[a]);  // 往a的上一层代表节点走 知道找到a的根节点
        }
        return p[a];
    }

    public void union (int a, int b) {   // 将a的根节点挂到b的根节点上
        p[find(a)] = find(b); 
    }
}
~~~





### LC [461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)

**方法一： 使用Integer.bitCount()**

~~~java
class Solution {
    public int hammingDistance(int x, int y) {
        int xor = x ^ y;
        int ans = Integer.bitCount(xor);  // 统计二进制中有多少个1
        return ans;
    }
}
~~~

**方法二：朴素法统计**

~~~java
class Solution {
    public int hammingDistance(int x, int y) {
        int xor = x ^ y;
        int cnt = 0;
        while (xor != 0) {
            if ((xor & 1) == 1) cnt ++;  // 用掩码验证最低一位是不是1
            xor = xor >> 1;
        }
        return cnt;
    }
}
~~~

**方法三：使用 z&(z-1) 去除 z 位级表示最低的那一位**

~~~java
public int hammingDistance(int x, int y) {
    int xor = x ^ y;
    int cnt = 0;
    while (xor != 0) {
        xor = xor & (xor - 1);
        cnt++;
    }
    return cnt;
}
~~~



### LC [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

~~~java
class Solution {
    public int singleNumber(int[] nums) {
        int xor = 0;
        for (int num : nums) 
            xor ^=  num;
        return xor;
    }
}
~~~



### LC [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)

~~~java
class Solution {
    public int missingNumber(int[] nums) {
        int n = nums.length;
        int xor = 0;
        for (int num : nums) {
            xor ^= num;
        }
        for (int num = 0; num <= n; num ++) {
            xor ^= num;
        }
        return xor;
    }
}
~~~



### LC [260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)

~~~java
class Solution {
    public int[] singleNumber(int[] nums) {
        int xor = 0;
        for (int num : nums) {
            xor ^= num;
        }
        // Integer.MIN_VALUE:1000 0000 0000 0000 0000 0000 0000 0000   -2^31
        // 防止溢出 Integer.MIN_VALUE的反码是32个1，会溢出
        // 因为二进制有正负0，负零用于多表示一位负数，这个负数如果取相反数，会产生溢出，所以不能用 a & (-a) 取最低有效位
        // 负0的特点是第一位是1，其余位是0，所以它的最低有效位就是自己
        int lowbit = (xor == Integer.MIN_VALUE ? xor : xor & (-xor));
        int xor1 = 0, xor2 =0;
        for (int num : nums) {
            if ((num & lowbit) == 0 ){  // 这是二进制 不能用==1来判断 那意味着==(000...01)
                xor1 ^= num;
            }
            else {
                xor2 ^= num;
            }
        }
        return new int[]{xor1, xor2};

    }
}
~~~



### LC [190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)

**方法一：**

~~~java
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            if ((n >> i & 1) == 1) {  // 第i位是1
                ans = ans | (1 << (31 - i));
            }
        }
        return ans;
    }
}
~~~

**方法二：**

~~~java
public int reverseBits(int n) {
    int ret = 0;
    for (int i = 0; i < 32; i++) {
        ret <<= 1;  // 先将该位设置为0
        ret |= (n & 1);  // 如果对称位置上真的是0，则0|0设置为0；如果对称位置上是1，1|0设置为1
        n >>>= 1;  // n往相反的方向移动
    }
    return ret;
}
~~~

**方法三：分治法-分组互换 (当做模板)**

-   思路：

    ~~~
    十六进制掩码：
    /* 0xAAAAAAAA = 0b10101010101010101010101010101010  0x55555555 = 0b01010101010101010101010101010101 */
    /* 0xCCCCCCCC = 0b11001100110011001100110011001100  0x33333333 = 0b00110011001100110011001100110011*/
    /* 0xF0F0F0F0 = 0b11110000111100001111000011110000  0x0F0F0F0F = 0b00001111000011110000111100001111 */
    /* 0xFF00FF00 = 0b11111111000000001111111100000000  0x00FF00FF = 0b00000000111111110000000011111111 */
    /* 0xFFFF0000 = 0b11111111111111110000000000000000  0x0000FFFF = 0b00000000000000001111111111111111 */
    ~~~

~~~java
public class Solution {
    public int reverseBits(int n) {
        // 一个一组   奇数位右移1位              偶数位左移一位
        n = ((n & 0xAAAAAAAA) >>> 1)  | ((n & 0x55555555) << 1);
        // 两个一组   奇数位右移1位              偶数位左移一位
        n = ((n & 0xCCCCCCCC) >>> 2)  | ((n & 0x33333333) << 2);
        // 四个一组   奇数位右移1位              偶数位左移一位
        n = ((n & 0xF0F0F0F0) >>> 4)  | ((n & 0x0F0F0F0F) << 4);
        // 八个一组   奇数位右移1位              偶数位左移一位
        n = ((n & 0xFF00FF00) >>> 8)  | ((n & 0x00FF00FF) << 8);
        // 十六个一组  奇数位右移1位              偶数位左移一位
        n = ((n & 0xFFFF0000) >>> 16) | ((n & 0x0000FFFF) << 16);
        // 最后一个可以不用掩码
        // n = (n  >>> 16) | (n  << 16);
        return n;
    }
}
~~~

*总结：不要认为「方法三」一定就比「方法一」等直接采用循环的方式更快。此类做法的最大作用，不是处理 int，而是处理更大位数的情况，在长度只有 32 位的 int 的情况下，该做法不一定就比循环要快（该做法会产生多个的中间结果，导致赋值发生多次，而且由于指令之间存在对 n 数值依赖，可能不会被优化为并行指令），这个道理和对于排序元素少的情况下，我们会选择「冒泡排序」而不是「归并排序」是一样的，因为「冒泡排序」常数更小。*



### LC [面试题 16.01. 交换数字](https://leetcode-cn.com/problems/swap-numbers-lcci/)

-   思路：

~~~
a = 2：10 ,
b = 3：11
------
// 通过异或求两个数哪些位不相等
a = a ^ b;
==> a = 01
    b = 11
// 通过异或值作为掩码 求原b的相反的情况
b = a ^ b;
==> b = 10
    a = 01
// 通过异或值作为掩码 求现b(原a)的相反的情况
a = a ^ b;
==> a = 11
    b = 10

~~~

~~~java
class Solution {
    public int[] swapNumbers(int[] numbers) {
        // 不能用临时变量哦
        numbers[0] = numbers[0] ^ numbers[1];
        numbers[1] = numbers[0] ^ numbers[1];
        numbers[0] = numbers[0] ^ numbers[1];
        return numbers;
    }
}
~~~



### LC [231. 2 的幂](https://leetcode-cn.com/problems/power-of-two/)

-   思路：一个数 n 是 2 的幂，当且仅当 n 是正整数，并且 n 的二进制表示中仅包含 1 个 1。

**方法一：直接统计1的个数**

~~~java
class Solution {
    public boolean isPowerOfTwo(int n) {
        return Integer.bitCount(n) == 1 && n != Integer.MIN_VALUE;
    }
}
~~~

**方法二：去掉最后一个1，看是不是等于0**

~~~
class Solution {
    public boolean isPowerOfTwo(int n) {
        return n > 0 && (n & (n - 1)) == 0;
    }
}
~~~

**方法三：lowbit值是不是等于他本身**

~~~java
class Solution {
    public boolean isPowerOfTwo(int n) {
        return n > 0 && (n & (-n)) == n;
    }
}
~~~





### LC [342. 4的幂](https://leetcode-cn.com/problems/power-of-four/)

-   思路： n 的二进制表示中仅包含 1 个 1并且1处于奇数位(从1开始数)

**方法一：**

~~~java
class Solution {
    public boolean isPowerOfFour(int n) {
        return n > 0 && (n & (-n)) == n && judge(n);

    }
    // 判断1是否在奇数位
    public boolean judge(int n) {
        int cnt = 0;
        while (n != 0) {
            cnt ++;
            n = n >>> 1;
        }
        return cnt % 2 == 1;
    }
}
~~~

**方法二：掩码**

~~~java
/**
mask = (AAAAAAAA)16 = (10101010101010101010101010101010)2
**/
class Solution {
    public boolean isPowerOfFour(int n) {
        return n > 0 && (n & (n - 1)) == 0 && (n & 0xaaaaaaaa) == 0;  // 偶数位是0
    }
}
~~~



### 	LC [693. 交替位二进制数](https://leetcode-cn.com/problems/binary-number-with-alternating-bits/)

**方法一：**

-   思路：用一个变量记录上一次最低位的值，交替检查最低位是不是与上次的相反

~~~java
class Solution {
    public boolean hasAlternatingBits(int n) {
        int lowest = 1 - (n & 1);  //取最后一位的相反数
        do {
            if (lowest == (n & 1)) {
                return false;
            } else {
                lowest = (n & 1);
                n = n >>> 1;
            }

        } while(n != 0);	

        return true;	
    }
}
~~~



**方法二：  最优解**

-   思路：每次比较最低两位	

~~~java
class Solution {
    public boolean hasAlternatingBits(int n) {
        while(n != 0) {
            if ((n & 1) == (n >>> 1 & 1)) return false;
            else n = n >>> 1;
        }
        return true;
    }
}
~~~



### LC [476. 数字的补数](https://leetcode-cn.com/problems/number-complement/)

**方法一：逐位处理**

-   思路：每次获得最低位，取相反，然后右移一位。

~~~java
class Solution {
    public int findComplement(int num) {
        int res = 0;
        int idx = 0;
        while (num != 0) {
            if ((num & 1 ) == 0) {
                res |= 1 << idx;
            }
            idx ++;
            num = num >>> 1;
        }
        return res;
    }
}
~~~

**方法二：掩码**

-   思路：求最高位的1的位置，然后从该位至最低位都设为1，以此作为掩码，与原数做异或运算，原来的1会被异或成0，原来的0会被异或成1。例如：原数：1010，掩码：1111（求解方法：10000 - 1 => 1111），1010 ^ 1111 ==> 0101

~~~java
class Solution {
    public int findComplement(int num) {
        int res = 0;
        // num = 5 : 101 
        int mask = Integer.highestOneBit(num);  // 100
        mask = (mask << 1) - 1;  // 注意计算的优先级  1000 - 1 ==> 111
        res  = num ^ mask;  // 101 ^ 111
        return res;
    }
}
~~~

*小结：Integer.highestOneBit(num):得到小于等于参数的最大2的幂，也就是最高位1保留，其他位设为0*



### LC [371. 两整数之和](https://leetcode-cn.com/problems/sum-of-two-integers/)

-   思路：将两数的相加拆解成需要进位的部分相加以及不需要进位的部分相加，然后再将原来两数的相加转换成一个新的问题：求需要进位部分加出来的和与不需要进位部分加出来的和相加的结果，其中需要进位部分加出来的和等于(a & b) << 1，不需要进位部分加出来的和为 a ^ b。

**方法一：递归**

~~~java
class Solution {
    public int getSum(int a, int b) {
        if (a == 0) return b;
        int carry = (a & b) << 1;  // 需要进位的
        int sum = a ^ b;  // 不需要进位的
        return getSum(carry, sum);  // 递归的处理carry和sum两个新的数之和，直到carry为0，也就是没有需要进位的了
    }
}
~~~

**方法二：循环**

~~~java
class Solution {
    public int getSum(int a, int b) {
        while (a != 0) {
            int carry = (a & b) << 1;  // 需要进位的
            int sum = a ^ b;  // 不需要进位的
            a = carry;
            b = sum;
        }
        return b;
    }
}
~~~



### LC [318. 最大单词长度乘积](https://leetcode-cn.com/problems/maximum-product-of-word-lengths/)

**方法一：**

-   思路：用二进制的方式来映射统计有一个字符串中出现了哪些字母，两个对应二进制串的与结果为0的话就说明这两个字符串没有共同的字母。

~~~java
class Solution {
    public int maxProduct(String[] words) {
        int n = words.length;
        int[] flag = new int[n];
        int maxLen = 0;
        for (int i = 0; i < n; i ++) {
            String word = words[i];
            for (char ch : word.toCharArray()) {
                flag[i] = flag[i] | (1 << ((int)ch - 97));  // 将字母对应的位置设为1
                //  另一种写法：masks[i] |= 1 << (word.charAt(j) - 'a');
            }
        }
        for (int i = 0; i < n; i ++) {
            for (int j = i + 1; j < n; j++) {
                if ((flag[i] & flag[j]) == 0) {
                    maxLen = Math.max(maxLen, words[i].length() * words[j].length());
                }
            }
        }
        return maxLen;
    }
}
~~~



### LC [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)

**方法一：朴素做法-用API统计1的个数**

~~~java
class Solution {
    public int[] countBits(int n) {
        int[] count = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            count[i] = Integer.bitCount(i);
        }
        return count;
    }
}
~~~

**方法二：动态规划-最低设置位(最彻底的DP)**

-   思路：
    -   当前数字的1的个数等于去掉最末位的1后的数字的1的个数加1；边界问题：第一个有1的的数字是1，去掉最末位1后得到0，0中1的字数为0，所以1中1的个数为0+1==1个；后面的数字中至少都有一个1，所以不用再担心边界问题；
    -   转移方程：dp[i] = dp[i & (i - 1)] + 1

~~~java
class Solution {
    public int[] countBits(int n) {
        int[] count = new int[n + 1];
        // dp[i] = dp[i & (i - 1)] + 1
        for (int i = 1; i <= n; i++) {  // 一定要从1开始啊，dp[0] = 0, dp[1] = 1, ....
            count[i] = count[i & (i - 1)] + 1;
        }
        return count;
    }
}
~~~

**方法三：动态规划-最低有效位**

-   思路：当前数字的1的个数等于去掉最末位得到的数字中1的个数加上最低位的结果(最低位是1就再多加一个，是0就不加)。

~~~java
class Solution {
    public int[] countBits(int n) {
        int[] count = new int[n + 1];
        // dp[i] = dp[i >>> 1] + 1?0
        for (int i = 1; i <= n; i++) {  // 一定要从1开始啊，dp[0] = 0, dp[1] = 1, ....
            count[i] = count[i >>> 1] + ((i & 1) == 1 ? 1 : 0);
        }
        return count;
    }
}
~~~

## 算法思想部分

## 双指针

### LC [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

~~~java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int i = 0, j = numbers.length - 1; 
        while (i < j) {
            if (numbers[i] + numbers[j] > target) j --;
            else if (numbers[i] + numbers[j] < target) i ++;
            else return new int[]{i + 1, j + 1};
        }
        return new int[2];
    }
}
~~~



### LC [633. 平方数之和](https://leetcode-cn.com/problems/sum-of-square-numbers/)

~~~java
class Solution {
    public boolean judgeSquareSum(int c) {
        // System.out.print(Integer.MAX_VALUE);
        long i = 0, j = (long)Math.sqrt(c);
        while (i <= j) {
            long sum = i * i + j * j;
            if (sum > c) j --;
            else if (sum < c) i ++;
            else return true;;
        }
        return false;
    }
}
/**
特殊情况：1.eg: 2 = 1 + 1 => a,b可能是1个数，所以循环判断条件应该是小于等于
		2.eg: 4 = 0 + 4 => a可能为0,所以左指针应该从0开始
		3.eg: Math.sqrt(Integer.MAX_VALUE) * Math.sqrt(Integer.MAX_VALUE) => 求平方时如果用int接可能会溢出，所以将变量都设置为long
*/
~~~



### LC [345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)

**方法一：**

~~~java
class Solution {
    public String reverseVowels(String s) {
        List<Character> list = new ArrayList<>();
        list.add('a');
        list.add('e');
        list.add('i');
        list.add('o');
        list.add('u');
        list.add('A');
        list.add('E');
        list.add('I');
        list.add('O');
        list.add('U');
        char[] arr = s.toCharArray();
        int i = 0, j = arr.length - 1;
        while (i < j) {
            // 要先判断索引的合法性，因为这里的i和j可能是上一次循环得到的已经越界的值
            while (i < arr.length && (!list.contains(arr[i]))) i++;  
            while (j >= 0 && (!list.contains(arr[j]))) j--;
            if (i < j) {
                char tmp = arr[i];
                arr[i] = arr[j];
                arr[j] = tmp;
                // 这里交换完一定要让和j往前进一步 不然就一直卡在这里了！！！
                i++;
                j--;
            }
        }
        return String.valueOf(arr);
    }
}
~~~

**方法一改进版：**

~~~java
class Solution {
    public String reverseVowels(String s) {
        char[] arr = s.toCharArray();
        int i = 0, j = arr.length - 1;
        while (i < j) {
            while (i < arr.length && "aeiouAEIOU".indexOf(arr[i]) < 0) i++;
            while (j >= 0 && "aeiouAEIOU".indexOf(arr[j]) < 0) j--;
            if (i < j) {
                char tmp = arr[i];
                arr[i] = arr[j];
                arr[j] = tmp;
                i++;
                j--;
            }
        }
        return String.valueOf(arr);
    }
}
~~~



### LC [680. 验证回文字符串 Ⅱ](https://leetcode-cn.com/problems/valid-palindrome-ii/)

~~~java
class Solution {
    public boolean validPalindrome(String s) {
        for (int i = 0, j = s.length() - 1; i < j; i++, j--) {
            if (s.charAt(i) != s.charAt(j)) {  // 给一个试错的机会，接下来交给更严格的没有试错机会的2号函数去判断
                return validPalindrome(s, i + 1, j) || validPalindrome(s, i, j - 1);
            }
        }
        return true;
    }
    public boolean validPalindrome(String s, int left, int right) {
        for (int i = left, j = right; i < j; i++, j--) {
            if (s.charAt(i) != s.charAt(j)) {
                return false;
            }
        }
        return true;
    }
}
~~~





### LC [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

**方法一：正向双指针**

-   复杂度：
    -   时间复杂度：O(m+n)。指针移动单调递增，最多移动 m+n 次，因此时间复杂度为 O(m+n)。
    -   空间复杂度：O(m+n)。需要建立长度为 m+n 的中间数组 sorted。

~~~java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = 0, j = 0;
        int[] nums = new int[m + n];
        int idx = 0;
        while (i < m && j < n) {
            if (nums1[i] <= nums2[j]) nums[idx++] = nums1[i++];
            else nums[idx++] = nums2[j++];
        }
        while (i < m) nums[idx++] = nums1[i++];
        while (j < n) nums[idx++] = nums2[j++];
        for (int k = 0; k < m+n; k++) {
            nums1[k] = nums[k];
        }
    }
}
~~~

**方法二：逆向双指针**

-   思想：
-   复杂度：
    -   时间复杂度：O(m+n)。指针移动单调递增，最多移动 m+n 次，因此时间复杂度为 O(m+n)。
    -   空间复杂度：O(m+n)。需要建立长度为 m+n 的中间数组 sorted。

~~~java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int p1 = m - 1, p2 = n - 1;
        int tail = m + n - 1;
        int cur;
        while (p1 >= 0 || p2 >= 0) {
            if (p1 == -1) {
                cur = nums2[p2--];
            } else if (p2 == -1) {
                cur = nums1[p1--];
            } else if (nums1[p1] > nums2[p2]) {
                cur = nums1[p1--];
            } else {
                cur = nums2[p2--];
            }
            nums1[tail--] = cur;
        }
    }
}
~~~



### LC [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

**方法一：集合记录已经访问过的节点**

~~~java
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode p = head;
        List<ListNode> list = new ArrayList<>();
        while (p != null) {
            if (list.contains(p)) return true;
            else {
                list.add(p);
                p = p.next;    
            }
        }
        return false;
    }
}
~~~



**方法二：双指针-快慢指针**

~~~java
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow = head, fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) return true;
        }
        return false;
    }
}
~~~



### LC [524. 通过删除字母匹配到字典里最长单词](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/)

**方法一：双指针**

~~~java
class Solution {
    public String findLongestWord(String s, List<String> dictionary) {
        String res = "";
        for (String str : dictionary) {
            // 能匹配上
            if (judge(s, str)) {
                // 长度更长或长度一样但是次序更前
                if (str.length() > res.length() || str.length() == res.length() && str.compareTo(res) < 0)
                    res = str;
            }
        }
        return res;
    }
    public boolean judge(String s1, String s2) {
        int i = 0, j = 0;
        while (j < s2.length()) {
            while (i < s1.length() && s1.charAt(i) != s2.charAt(j)) {
                i ++;
            }
            // s1[i]和s2[j]没匹配上
            if (i >= s1.length()) return false;
            // s1[i]和s2[j]匹配上了
            else {
                i++;
                j++;
            }
        }
        return true;
    }
}
~~~

**方法二：动态规划**

~~~java

~~~



## 排序

### LC [912. 排序数组！](https://leetcode-cn.com/problems/sort-an-array/)

**方法一：快速排序-随机主元**

-   思路：

    ~~~
    # 指针快排的大while循环的第一个while循环为什么一定要先从右边开始?? 能不能先从左边开始?
    升序排序时, 从右边开始是因为要保证left指向的值在退出循环时永远小于等于pivot, 保证随后的中枢值归位swap(nums, pivot_index, left);的正确性.
    前面说了快排只是每次将数组分为比基准值大和比基准值小的两部分，哨兵j先走，由于`while (left < right && nums[right] >= pivot) right--;`,则j停下时一定是因为遇到的值小于pivot了或者直接碰到了i，这样能够保证从开始右移到j和哨兵i相遇时，碰到的元素都小于等于pivot，哨兵j右侧都是比基准值大的元素，然后再与基准值交换可以保证交换后基准值左侧都是比他小的元素，右侧都是比他大的元素。
    简而言之，j最终停留的位置将所有大于等于pivot的值都卡在了j的右边，使得i与j相遇时碰不到大于等于pivot的值，这样i和j相遇处左边都是小于等于pivot的，右边都是大于等于pivot的。
    # 极端情况：数组是递增的，那么right直接就走到了left的位置，第一层循环直接结束，递归经判定索引非法后直接结束(q(0,-1),q(1,0))。
    
    
    ~~~

~~~java
class Solution {
    public int[] sortArray(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
        return nums;
    }
    public void quickSort(int[] nums, int left, int right) {
        // 这个函数用于递归地进快速排序
        // 先调用partition函数使得某元素归位, 再递归地排序归位元素的左边和右边
        if (right <= left) {
            return;
        }
        // 返回的是已经归位的元素的下标
        // 1.以第一个作为主元
        // int partition_index = partition(nums, left, right);
        // 2.随机选择主元
        int partition_index = partitionRandom(nums, left, right);
        quickSort(nums, left, partition_index - 1);
        quickSort(nums, partition_index + 1, right);
    
    }
    public int partitionRandom(int[] nums, int left, int right) {
        int randomIndex = left + new Random().nextInt(right - left + 1);
        swap(nums, randomIndex, left);
        return partition(nums, left, right);
    }
    public int partition(int[] nums, int left, int right) {
        // 归位nums[left, right] 范围内的某一个元素, 一般归位的是nums[left], 不过也可以随机化归位元素(将那个随机的元素换个left位置即可)
        // 返回归位元素的下标index
        int pivot_index = left;
        int pivot = nums[pivot_index];
        while (left < right) {
            // 先从后面开始找一个严格小于pivot的值
            while (left < right && nums[right] >= pivot)
                right--;
            // 再从头部到right停留处这一段找一个严格大于pivot的值
            while (left < right && nums[left] <= pivot)
                left++;
            if (left < right)
                swap(nums, left, right);
            // if (left == right) : 碰上了，说明两端都已被划分完毕了，碰到的这个位置就是pivot应该在的位置
        }
        swap(nums, pivot_index, left);
        return left;
    }
    public void swap(int[] nums, int i, int j) {
    	int temp = nums[i];
    	nums[i] = nums[j];
    	nums[j] = temp;
    }
}
~~~

**方法二：快速排序-三数取中法**

-   思路：

    ~~~markdown
    我们在上面的例子中选取的都是 nums[low] 做为我们的基准值，那么当我们遇到特殊情况时呢？
    如：7 1 5 4 3 6 2 --> 2 1 5 4 3 6 7
    我们按上面的方法，选取第一个元素做为基准元素，那么我们执行一轮排序后，发现仅仅是交换了 2 和 7 的位置，这是因为 7 为序列的最大值。所以我们的 pivot 的选取尤为重要，选取时应尽量避免选取序列的最大或最小值做为基准值。则我们可以利用三数取中法来选取基准值，也就是选取三个元素中的中间值放到 nums[low] 的位置，做为基准值。这样就避免了使用最大值或最小值做为基准值。
    三数取中法：将中间元素放到 nums[low] 位置做为基准值，最大值放到 nums[hight],最小值放到 nums[mid],即 [4,2,3] 经过上面代码处理后，则变成了 [3,2,4].此时我们选取 3 做为基准值，这样也就避免掉了选取最大或最小值做为基准值的情况。
    
     
    ~~~

~~~java
class Solution {
    public int[] sortArray(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
        return nums;
    }
    public void quickSort(int[] nums, int left, int right) {
        if (right <= left) {
            return;
        }
        int partition_index = partitionTriple(nums, left, right);
        quickSort(nums, left, partition_index - 1);
        quickSort(nums, partition_index + 1, right);
    }
    // 先将最大的放在right位置，然后将left和mid位置中较大的放在left位置
    public int partitionTriple(int[] nums, int left, int right) {
        int mid = left + right >> 1;
        if (nums[left] > nums[right]) swap(nums, left, right);
        if (nums[mid] > nums[right]) swap(nums, mid, right);
        if (nums[mid] > nums[left]) swap(nums, mid, left);
        return partition(nums, left, right);
    }
    public int partition(int[] nums, int left, int right) {
        int pivot_index = left;
        int pivot = nums[pivot_index];
        while (left < right) {
            while (left < right && nums[right] >= pivot)
                right--;
            while (left < right && nums[left] <= pivot)
                left++;
            if (left < right)
                swap(nums, left, right);
        }
        swap(nums, pivot_index, left);
        return left;
    }
    public void swap(int[] nums, int i, int j) {
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
    }
}
~~~

**方法三：堆排序-用堆API****

-   思路：

~~~java
class Solution {
    public int[] sortArray(int[] nums) {
        // 默认是小根堆，实现大根堆需要重写一下比较器。
        Queue<Integer> heap = new PriorityQueue<>();
        for (int num : nums) {
            heap.offer(num);
        }
        for (int i = 0; i < nums.length; i++) {
            nums[i] = heap.poll();
        }
        return nums;
    }
}
~~~

**方法四：堆排序-手撕堆**

-   思路：

    ~~~
    # 大根堆
    建堆：
    对于初始数组，从第一个非叶节点开始自底向上做调整，使得每个节点沉到合适的位置
    求最大值：
    弹出堆的第一个元素(一般处理方式是将其与最后一位元素互换，然后将堆的长度减1)，再将第一个元素沉到合适的位置
    大根堆的下沉操作：
    将某节点和其两个孩子比较，与其中最大的互换，如此循环，直到该值比两个孩子都大
    插入元素：
    ？对数组整体进行一次建堆操作
    ~~~

    

~~~java
class Solution {
    public int[] sortArray(int[] nums) {
        heapSort(nums);
        return nums;
    }
    private void heapSort(int[] nums){
        // 将数组初始为一个大根堆
        buildMaxHeap(nums);
        for(int i = 0; i < nums.length; i++){
            // 将堆顶元素（最大元素）移到数组末尾
            swap(nums, 0, nums.length - 1 - i);
            // 拿走堆顶元素后导致堆结构改变，必须重新构造大顶堆
            // [0,i]共i+1个元素被换到最后去了，还剩n-(i+1)=n-i-1个
            maxHeapify(nums, 0, nums.length - i - 1);  
        }
    }
	// 从最后一个非叶子节点开始自底向上构建大根堆  -->up()
    private void buildMaxHeap(int[] nums){
        for(int i = nums.length / 2 - 1; i >= 0; i--){
            maxHeapify(nums, i, nums.length);
        }
    }
	// 把小的把下沉，直到中间节点比两个子节点都大  --> down()
    private void maxHeapify(int[] nums, int i, int heapSize){
        // 向下调整的中间节点
        int mid = i;
        // 左节点下标
        int left = 2 * i + 1;
        // 右节点下标
        int right = left + 1;
        // 判断左节点是否小于中间节点
        if(left < heapSize && nums[mid] < nums[left]){
            mid = left;
        }
        // 判断右节点是否小于中间节点
        if(right < heapSize && nums[mid] < nums[right]){
            mid = right;
        }
        // 发生交换，必须重建子树结构（交换会打破子树的大根堆结构）
        if(mid != i){
            swap(nums, mid, i);
            // 重构子树的堆结构
            maxHeapify(nums, mid, heapSize);
        }
    }
    private void swap(int[] arr, int i, int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
~~~

**方法五：归并排序**

~~~java
class Solution {
    public int[] sortArray(int[] nums) {
        mergeSort(nums, 0, nums.length - 1);
        return nums;
    }
    public void mergeSort(int[] nums, int l, int r) {
        if (l >= r) return;
        int mid = (l + r) >>> 1;
        // 先递归的对左右两边的序列进行递归排序
        mergeSort(nums, l, mid);
        mergeSort(nums, mid + 1, r);
        // 然后以整个序列为对象，一分为二，进行归并
        mergeTempl(nums, l, mid, nums, mid + 1, r);
    }
    // merge()合并的两端一定是连续的
    public void mergeTempl(int[] nums1, int l1, int r1, int[] nums2, int l2, int r2) {
        int i = l1;
        int j = l2;
        int cnt = (r1 - l1 + 1) + (r2 - l2 + 1);
        // (临时)数组接归并后的结果
        int[] nums = new int[cnt];
        int idx = 0;
        while (i <= r1 && j <= r2) {
            if (nums1[i] <= nums2[j]) nums[idx++] = nums1[i++];
            else nums[idx++] = nums2[j++];
        }
        while (i <= r1) nums[idx++] = nums1[i++];
        while (j <= r2) nums[idx++] = nums2[j++];
        // 将归并后的结果归位
        // merge()合并的两端一定是连续的，所以这里可以利用nums[]连续的归位
        for (int k = 0; k < cnt; k++) {
            nums1[k + l1] = nums[k];
        }
    }
}
~~~



### 对比-归并排序-LC [315. 计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)

~~~java

~~~

### 对比-归并排序-LC [剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

~~~java

~~~





### LC [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

**方法一：快速排序-完全基于快排模板**

~~~java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int target = nums.length - k;
        quickSort(nums, 0, nums.length - 1, target);
        return nums[target];
    }
    public void quickSort(int[] nums, int left, int right, int target) {
        if (left >= right) return;
        int partitionIndex = partitionRandom(nums, left, right);
        if (partitionIndex == target) return;
        else if (partitionIndex > target) {
            quickSort(nums, left, partitionIndex - 1, target);
        } else {
            quickSort(nums, partitionIndex + 1, right, target);
        }
    }
    public int partitionRandom(int[] nums, int left, int right) {
        int randomIndex = left + new Random().nextInt(right - left + 1);
        swap(nums, left, randomIndex);
        return partition(nums, left, right);
    }
    public int partition(int[] nums, int left, int right) {
        int pivotIndex = left;
        int pivot = nums[pivotIndex];
        while (left < right) {
            while (left < right && nums[right] >= pivot) right--;
            while (left < right && nums[left] <= pivot) left++;
            if (left < right) swap(nums, left, right);
        }
        swap(nums, pivotIndex, left);
        return left;
    }
    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
~~~

**方法二：快速排序-根据题意优化**

~~~java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int target = nums.length - k;
        return findKth(nums, 0, nums.length - 1, target);
    }
    public int findKth(int[] nums, int left, int right, int target) {
        if (left >= right) return nums[left];
        int partitionIndex = partitionRandom(nums, left, right);
        if (partitionIndex == target) return nums[partitionIndex];
        else if (partitionIndex > target) {
            return findKth(nums, left, partitionIndex - 1, target);
        } else {
            return findKth(nums, partitionIndex + 1, right, target);
        }
    }
    public int partitionRandom(int[] nums, int left, int right) {
        int randomIndex = left + new Random().nextInt(right - left + 1);
        swap(nums, left, randomIndex);
        return partition(nums, left, right);
    }
    public int partition(int[] nums, int left, int right) {
        int pivotIndex = left;
        int pivot = nums[pivotIndex];
        while (left < right) {
            while (left < right && nums[right] >= pivot) right--;
            while (left < right && nums[left] <= pivot) left++;
            if (left < right) swap(nums, left, right);
        }
        swap(nums, pivotIndex, left);
        return left;
    }
    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
~~~

**方法三：堆排序-用堆API**

-   思路：

~~~java
// 小根堆
class Solution {
    public int findKthLargest(int[] nums, int k) {
        // 默认是小根堆，实现大根堆需要重写一下比较器。
        Queue<Integer> heap = new PriorityQueue<>();
        for (int num : nums) {
            heap.offer(num);
        }
        for (int i = 0; i < nums.length - k; i++) {
            heap.poll();
        }
        return heap.peek();
    }
}
// 大根堆
class Solution {
    public int findKthLargest(int[] nums, int k) {
        Queue<Integer> heap = new PriorityQueue<>(new Comparator<Integer>(){
            @Override	
            public int compare(Integer o1, Integer o2){
                return o2.compareTo(o1);  // 递减
                // 递减 return o1 > o2 ? -1 : 1;  ==> return o2 - o1;
                /* 递增 return o1.compareTo(o2); */  
            }
        });
        for (int num : nums) {
            heap.offer(num);
        }
        // 第k大的的索引是k-1,所以弹出0~k-2
        for (int i = 0; i < k - 1; i++) {
            heap.poll();
        }
        return heap.peek();
    }
}
~~~

**方法四：堆排序-手撕堆**

~~~java

~~~





### LC [75. 颜色分类-荷兰国旗颜色问题](https://leetcode-cn.com/problems/sort-colors/)

**方法一：快速排序**

~~~java
class Solution {
    public void sortColors(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
    }
    public void quickSort(int[] nums, int left, int right) {
        // 先调用partition函数使得某元素归位, 再递归地排序归位元素的左边和右边
        if (right <= left) {
            return;
        }
        int partition_index = partitionTriple(nums, left, right);
        quickSort(nums, left, partition_index - 1);
        quickSort(nums, partition_index + 1, right);
    }
    public int partitionTriple(int[] nums, int left, int right) {
        int mid = left + right >> 1;
        if (nums[left] > nums[right]) swap(nums, left, right);
        if (nums[mid] > nums[right]) swap(nums, mid, right);
        if (nums[mid] > nums[left]) swap(nums, mid, left);
        return partition(nums, left, right);
    }
    public int partition(int[] nums, int left, int right) {
        // 归位nums[left, right] 范围内的某一个元素, 一般归位的是nums[left], 不过也可以随机化归位元素(将那个随机的元素换个left位置即可)
        // 返回归位元素的下标 index
        int pivot_index = left;
        int pivot = nums[pivot_index];
        while (left < right) {
            while (left < right && nums[right] >= pivot)
                right--;
            while (left < right && nums[left] <= pivot)
                left++;
            if (left < right)
                swap(nums, left, right);
        }
        swap(nums, pivot_index, left);
        return left;
    }
    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
~~~

**方法二：三指针(类似快排的划分)**

-   思路：将 0、2 都放在合适的位置，那么 1 必然已在合适的位置；所以整个过程只主动地移动 0、2，1 是被动地被移动的（遇到 `nums[i] === 1`遍历指针直接跳过去下一位）：

    -   指针 p：初始化为 0，每确认一个 0，则向右移动 p；或者说 p 左侧的都是 0
    -   指针 q：初始化为 n-1，每确认一个 2，则向左移动 q；或者说 q 右侧的都是 2
    -   注意：指针 p 不能比 i 快，指针 q 不能比 i 慢

    为什么要回退 i：`nums[i]` 用来和 `nums[p]`/`nums[q]` 作交换（分别确认一个 0/2），若交换后的 `nums[i]` 还是 0/2，那么 `nums[i]` 还要找到正确的位置并交换，因此要原地踏步。

~~~java
class Solution {
    public void sortColors(int[] nums) {
        int p0 = 0, p2 = nums.length - 1;
        int idx = 0;
        while (idx <= p2) {
            if (nums[idx] == 0) {
                /**
                这里交换的nums[p0]只能是0或者1,因为p0小于等于idx,而idx左边的元素小于等于2(如果有2的话之前就已经被换到后面去了)
                所以一共有两种情形: 1.nums[p0]和nums[idx]都是0,相当于只是把0的右边界又右移了；2.nums[idx]是0,nums[p0]是1,交换后nums[idx]是1，
                秉着不主动处理1的原则，idx往后移一位
                 */
                // 交换后现在p0位置放的是0 idx位置放的一定是1 
                swap(nums, p0++, idx++);  
            } else if (nums[idx] == 2) {
                swap(nums, p2--, idx);
                // 交换后idx位置如果放的是1 idx也往后移一位 
                if (nums[idx] == 1) idx ++;
            } else {
                idx ++;
            }
        }
    }
    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
~~~



### LC [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

**方法一：快速排序**

~~~java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        int n = map.size();
        List<int[]> list = new ArrayList<>();
        for (int key : map.keySet()) {
            list.add(new int[]{ key, map.get(key) });
        }
        quickSort(list, 0, n - 1, n - k - 1);
        int[] res = new int[k];
        int idx = n - k;
        for (int i = 0; i < k; i++) {
            res[i] = list.get(idx++)[0];
        }
        return res;

    }
    public void quickSort(List<int[]> list, int left, int right, int target) {
        if (left >= right) return;
        int partitionIndex = partitionRandom(list, left, right);
        if (partitionIndex == target) {
            return;
        } else if (partitionIndex > target) {
            quickSort(list, left, partitionIndex - 1, target);
        } else {
            quickSort(list, partitionIndex + 1, right, target);
        }
    }
    public int partitionRandom(List<int[]> list, int left, int right) {
        int randomIndex = left + new Random().nextInt(right - left + 1);
        Collections.swap(list, randomIndex, left);
        return partition(list, left, right);
    }
    public int partition(List<int[]> list, int left, int right) {
        int pivotIndex = left;
        int pivot = list.get(pivotIndex)[1];
        while (left < right) {
            while (left < right && list.get(right)[1] >= pivot) right--;
            while (left < right && list.get(left)[1] <= pivot) left++;
            if (left < right) Collections.swap(list, left, right);
        }
        Collections.swap(list, pivotIndex, left);
        return left;
    }
}
~~~

**方法二：堆排序**

~~~java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        Queue<int[]> heap = new PriorityQueue<>(new Comparator<int[]>(){
            @Override
            public int compare(int[] pair1, int[] pair2) {
                return pair1[1] > pair2[1] ? -1 : 1;  // 大顶堆
            }
        });
        for (int key : map.keySet()) {
            heap.offer(new int[]{ key, map.get(key) });
        }
        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = heap.poll()[0];
        }
        return res;
    }
}
~~~

**方法三：桶排序**

~~~java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        List<Integer>[] buckets = new ArrayList[nums.length + 1];
        for (int num : map.keySet()) {
            int freq = map.get(num);
            if (buckets[freq] == null) {
                buckets[freq] = new ArrayList<>();
            }
            buckets[freq].add(num);
        }
        int cnt = 0;
        List<Integer> list = new ArrayList<>();
        for (int i = buckets.length - 1; i >= 0; i--) {
            if (buckets[i] == null) continue;
            if (cnt + buckets[i].size() <= k) {
                list.addAll(buckets[i]);
            } else {
                list.addAll(buckets[i].subList(0, k - cnt - 1));
            }    
        }
        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = list.get(i);
        }
        return res;
    }
}
~~~





### LC [451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)

**方法一：快速排序**

~~~java
class Solution {
    public String frequencySort(String s) {
        Map<Integer, Integer> map = new HashMap<>();
        char[] arr = s.toCharArray();
        for (int ch : arr) {
            map.put(ch, map.getOrDefault(ch, 0) + 1);
        }
        int n = map.size();
        List<int[]> list = new ArrayList<>();
        for (int ch : map.keySet()) {
            list.add(new int[]{ ch, map.get(ch) });
        }
        quickSort(list, 0, n - 1);
        StringBuilder sb = new StringBuilder(10);
        for (int i = list.size() - 1; i >= 0; i--) {
            for (int j = 0; j < list.get(i)[1]; j++) {
                sb.append((char)list.get(i)[0]);
            }
        }
        return sb.toString();
    }
    public void quickSort(List<int[]> list, int left, int right) {
        if (left >= right) return;
        int partitionIndex = partitionRandom(list, left, right);
        quickSort(list, left, partitionIndex - 1);
        quickSort(list, partitionIndex + 1, right);
    }
    public int partitionRandom(List<int[]> list, int left, int right) {
        int randomIndex = left + new Random().nextInt(right - left + 1);
        Collections.swap(list, randomIndex, left);
        return partition(list, left, right);
    }
    public int partition(List<int[]> list, int left, int right) {
        int pivotIndex = left;
        int pivot = list.get(pivotIndex)[1];
        while (left < right) {
            while (left < right && list.get(right)[1] >= pivot) right--;
            while (left < right && list.get(left)[1] <= pivot) left++;
            if (left < right) Collections.swap(list, left, right);
        }
        Collections.swap(list, pivotIndex, left);
        return left;
    }
}
~~~

**方法二：堆排序**

~~~java
class Solution {
    public String frequencySort(String s) {
        Map<Integer, Integer> map = new HashMap<>();
        char[] arr = s.toCharArray();
        for (int ch : arr) {
            map.put(ch, map.getOrDefault(ch, 0) + 1);
        }
        int n = map.size();
        System.out.println(n);
        Queue<int[]> heap = new PriorityQueue<>(new Comparator<int[]>(){
            @Override
            public int compare(int[] pair1, int[] pair2) {
                return pair1[1] > pair2[1] ? -1 : 1;
            }
        });
        for (int ch : map.keySet()) {
            heap.offer(new int[]{ ch, map.get(ch) });
        }
        StringBuilder sb = new StringBuilder(10);
        while (!heap.isEmpty()) {
            int[] pair = heap.poll();
            for (int j = 0; j < pair[1]; j++) {
                sb.append((char)pair[0]);
            }
        }
        return sb.toString();
    }
}
~~~

**方法三：桶排序**

~~~java
class Solution {
    public String frequencySort(String s) {
        Map<Integer, Integer> map = new HashMap<>();
        char[] arr = s.toCharArray();
        for (int ch : arr) {
            map.put(ch, map.getOrDefault(ch, 0) + 1);
        }
        List<Integer>[] buckets = new ArrayList[s.length() + 1];
        for (int ch : map.keySet()) {
            int freq = map.get(ch);
            if (buckets[freq] == null) {
                buckets[freq] = new ArrayList<>();
            }
            buckets[freq].add(ch);
        }
        StringBuilder sb = new StringBuilder(10);
        for (int i = buckets.length - 1; i >= 0; i--) {
            if (buckets[i] == null) continue;
            for (int ch : buckets[i]) {
                for (int j = 0; j < i; j++) {
                    sb.append((char)ch);
                }
            }
        }
        return sb.toString();
    }
}
~~~



## 二分查找

### LC [69. x 的平方根 ](https://leetcode-cn.com/problems/sqrtx/)

**方法一：模板套用**

-   思路：

    -   如果这个整数的平方 **恰好等于** 输入整数，那么我们就找到了这个整数；

    -   如果这个整数的平方 **严格大于** 输入整数，那么这个整数肯定不是我们要找的那个数；

    -   如果这个整数的平方 **严格小于** 输入整数，那么这个整数 **可能** 是我们要找的那个数（重点理解这句话），正是借助这个条件设计了check()函数。

        本题中，check()函数用来判断mid^2是否小于等于x,若小于等于x，则mid有可能是正确答案，即答案存在于[mid, right]中；若mid^2严格大于x，则mid不可能是答案，所以答案存在与[left, mid - 1]中

~~~java
class Solution {
    public int mySqrt(int x) {
        if (x == 0 || x == 1) return x;
        return bsearch2(1, x, x);

    }
    public int bsearch2(int l, int r, int x) {
        while (l < r) {
            int mid = l + (r - l + 1) / 2; //mid属于左边  
            if (check(mid, x)) l = mid;    // check()判断mid是否满足性质，答案(边界点)在左边[l,mid]中
            else r = mid - 1;
        }
        return l;
    }
    public boolean check(int mid, int x) {
        return mid <= x / mid;
    }
}
~~~

**方法二：牛顿迭代法**

~~~
牛顿迭代法解决LC69.x的平方根
~~~



### LC [744. 寻找比目标字母大的最小字母](https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/)

~~~java
class Solution {
    public char nextGreatestLetter(char[] letters, char target) {
        return bsearch1(letters, target);
    }
    public char bsearch1(char[] letters, char target) {
        int l = 0, r = letters.length - 1;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (check(letters, mid, target)) l = mid + 1;
            else r = mid;
        }
        // 如果target比所有字母都大则返回 第一个字母
        if (letters[l] > target) return letters[l];
        else return letters[0];
        
    }
    public boolean check(char[] letters, int mid, char target){
        return letters[mid] <= target;
    }
}
~~~



### LC [540. 有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)

**方法一：位运算**

~~~java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int xor = 0;
        for (int num : nums) xor ^= num;
        return xor;
    }
}
// 复杂度O(n) 不符合要求
~~~



**方法二：二分查找**

-   思路：

    ~~~java
    // 以mid前面有没有问题把序列分成两部分
    // 1.若mid为偶数，那么num[mid]前面一共有偶数个数，若num[mid]==num[mid+1]则可以说明num[mid]及num[mid]之前的序列都没问题
    // 2，若mid为奇数，那么num[mid-1]前面一共有偶数个数，若num[mid-1]==num[mid]则可以说明num[mid-1]、num[mid]及之前的序列都没问题
    // 总之，判断mid附近最大偶数个数的情况
    ~~~

    

~~~java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int index = bsearch_1(nums);
        return nums[index];

    }
    public int bsearch_1(int[] nums) {
        int l = 0, r = nums.length - 1;
        while (l < r) {
            int mid = l + r >> 1; //mid属于左边  
            // 确保前面没有问题
            if (check(nums, mid)) l = mid + 1;    
            else r = mid;  // check()判断mid是否满足性质，答案(边界点)在左边[l,mid]中
        }
        return l;
    }
    public boolean check(int[] nums, int mid) {
        if (mid % 2 == 1) return nums[mid] == nums[mid - 1];
        else return nums[mid] == nums[mid + 1];
    }
}
~~~

**方法三：二分查找-只看第奇数位**

-   思路：只看第奇数位置，这样往右跳的时候能一下跳两格

~~~java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int index = bsearch_1(nums);
        return nums[index];
    }
    //偶数情况下取左边 那么右边应该和他相等
    public int bsearch_1(int[] nums) {
        int l = 0, r = nums.length - 1;
        while (l < r) {
            int mid = l + r >> 1; //mid属于左边  
            // 确保前面没有问题
            if (mid % 2 == 1) mid--; 
            if (check(nums, mid)) l = mid + 2;    
            else r = mid;  // check()判断mid是否满足性质，答案(边界点)在左边[l,mid]中
        }
        return l;
    }
    public boolean check(int[] nums, int mid) {
        // if (mid % 2 == 1) return nums[mid] == nums[mid - 1];
        return nums[mid] == nums[mid + 1];
    }
}
~~~



### LC [278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)

~~~java
public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        return bsearch1(n);
    }
    public int bsearch1(int n) {
        int l = 1, r = n;
        while (l < r) {
            int mid = l + (r - l) / 2;
            // 如果前面的都没出错
            if (check(mid) == false) l = mid + 1;
            else r = mid;
        }
        return l;
    }
    public boolean check(int mid) {
        return isBadVersion(mid);  // 没问题返回false
    }
}
~~~



### LC [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

-   思路：

    ~~~markdown
    在二分查找的每一步中，左边界为low，右边界为high，区间的中点为pivot，最小值就在该区间内。我们将中轴元素nums[pivot] 与右边界元素nums[high] 进行比较，可能会有以下的三种情况：
    第一种情况是nums[pivot]<nums[high]，这说明nums[pivot]是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分，但是不能忽略nums[pivot]本身，因为它可能就是最小的。
    第二种情况是nums[pivot]>nums[high]，这说明nums[pivot] 是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分。
    由于数组不包含重复元素，并且只要当前的区间长度不为 1，pivot 就不会与high 重合；而如果当前的区间长度为1，这说明我们已经可以结束二分查找了。因此不会存在nums[pivot]=nums[high] 的情况。
    ~~~

~~~java
class Solution {
    public int findMin(int[] nums) {
        return bsearch(nums);
    }
    public int bsearch(int[] nums) {
        int l = 0, r = nums.length - 1;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (check(nums, mid)) l = mid + 1;  // 前面肯定没问题 后面肯定有问题
            else r = mid;  
        }
        return nums[l];
    }

    public boolean check(int[] nums, int mid) {
        return nums[mid] > nums[nums.length - 1];  // mid及其前面肯定没问题
    }
}
~~~

### 对比 [剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

-   思路：

    <img src="alg-img/旋转数组2.png" width="350px">

~~~java
class Solution {
    public int minArray(int[] numbers) {
        int n = numbers.length;
        int l = 0, r = n - 1;
        while (l < r) {
            int mid = l + ((r - l) >> 1);
            if (check(numbers, mid)) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        return numbers[l];
    }
    public boolean check(int[] numbers, int mid) {
        int n = numbers.length;
        if (numbers[mid] > numbers[n - 1]) return true;
        for (int i = mid; i < n; i++) {
            if (numbers[i] < numbers[mid]) return true;
        }
        return false;
    }
}
~~~



### LC [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

~~~java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        if (nums.length == 0) return new int[]{-1, -1};
        return new int[]{bsearch1(nums, target), bsearch2(nums, target)};
    }
    public int bsearch1(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if ( nums[mid] < target ) l = mid + 1;  // 前面肯定没问题
            else r = mid;  
        }
        return nums[l] == target ? l : -1;
    }
    public int bsearch2(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while (l < r) {
            int mid = l + (r - l + 1) / 2;
            if (nums[mid] <= target) l = mid;  
            else r = mid - 1;    // 后面肯定没问题  nums[mid] > target
        }
        return nums[l] == target ? l : -1;
    }
    public boolean check(int[] nums, int mid) {
        return nums[mid] > nums[nums.length - 1];  // mid及其前面肯定没问题
    }
}
~~~



## 分治

### LC [241. 为运算表达式设计优先级](https://leetcode-cn.com/problems/different-ways-to-add-parentheses/)

-   思路：

    ~~~java
    /** eg: "2*3-4*5"
    [4]*[5]
    [3]-[20]  <--2--
    [3]-[4]
    [-1]*[5]  <--2--
    [2]*[-17, -5]  <-1-
    ---------------------
    [2]*[3]  <--2--
    [4]*[5]  <--2--
    [6]-[20]  <-1-
    ---------------------
    [3]-[4]
    [2]*[-1]
    [2]*[3]  <--2--
    [6]-[4]  <--2--
    [-2, 2]*[5] <-1-
    递归三部曲：
    1.确定递归函数的参数以及返回值
    2.确定终止条件
    3.确定单层递归的逻辑
    */
    ~~~

~~~java
class Solution {
    public List<Integer> diffWaysToCompute(String input) {
        List<Integer> results = new ArrayList<>();
        // 递归停止方式1：
        // 如果是纯数字 直接加到结果集
        if (isNum(input)) {
            results.add(Integer.valueOf(input));
            return results;
        }
        for (int i = 0; i < input.length(); i++) {
            char c = input.charAt(i);
            if (isOp(c)) {
                List<Integer> left = diffWaysToCompute(input.substring(0, i));
                List<Integer> right = diffWaysToCompute(input.substring(i + 1));
                for (int l : left) {
                    for (int r : right) {
                        results.add(calculate(c, l, r));
                    }
                }
            }
        }
        // 递归停止方式2：
        // 如果整趟都没有检测到运算符 list中不会add任何值
        // if (ways.size() == 0) {
        //     ways.add(Integer.valueOf(input));
        // }
        return results;
    }
    public boolean isOp(char ch) {
        return ch == '+' || ch == '-' || ch == '*';
    }
    public int calculate(char op, int l, int r) {
        if (op == '+') return l + r;
        else if (op == '-') return l - r;
        else return l * r;
    }
    public boolean isNum(String input) {
        for (int i = 0; i < input.length(); i++) {
            char ch = input.charAt(i);
            if (isOp(ch)) return false;
        }
        return true;
    }
}
~~~

### LC [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

~~~java
class Solution {
    public List<TreeNode> generateTrees(int n) {
        return generateTreesHelper(1, n);
    }
    public List<TreeNode> generateTreesHelper(int l, int r) {
        List<TreeNode> result = new ArrayList<>();
        if (l > r) {
            result.add(null);
            return result;
        }
        // 枚举可行根节点
        for (int i = l; i <= r; i++) {
            // 获得所有可行的左子树集合
            List<TreeNode> left = generateTreesHelper(l, i - 1);
            // 获得所有可行的右子树集合
            List<TreeNode> right = generateTreesHelper(i + 1, r);
            // 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上
            for (TreeNode ll : left) {
                for (TreeNode rr : right) {
                    TreeNode head = new TreeNode(i);
                    head.left = ll;
                    head.right = rr;
                    result.add(head);
                }
            }
        }
        return result;

    }
}
~~~



## 搜索

## -BFS

### LC [1091. 二进制矩阵中的最短路径](https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/)	

~~~java
class Solution {
    public int shortestPathBinaryMatrix(int[][] grid) {
        int n = grid.length;
        if (grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;
        Queue<int[]> qu = new LinkedList<>();
        int[][] directions = {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1}};
        qu.add(new int[]{0,0});
        int len = 0;
        while (!qu.isEmpty()) {
            len ++;
            int size = qu.size();
            // 取出该层的所有节点
            for (int i = 0; i < size; i++) {
                int[] cur = qu.poll();
                int row = cur[0], col = cur[1];
                // 如果当前单元格值为1 跳过
                if (grid[row][col] == 1) continue;
                // 当前单元格值为0 
                // 如果到达终点了
                if (row == n - 1 && col == n - 1) return len;
                // 没到达终点 将相邻的符合条件的节点加入队列
                grid[row][col] = 1;  // 标记改为1 替代visited数组的作用
                for (int[] dir : directions) {
                    int neiRow = row + dir[0], neiCol = col + dir[1];
                    if (neiRow < 0 || neiRow > n - 1 || neiCol < 0 || neiCol > n - 1) {
                        continue;
                    }
                    qu.add(new int[]{neiRow, neiCol});
                }
            }
        }
        return -1;
    }
}
~~~

> -   如果只是要找到某一个结果是否存在，那么DFS会更高效。因为DFS会首先把一种可能的情况尝试到底，才会回溯去尝试下一种情况，只要找到一种情况，就可以返回了。但是BFS必须所有可能的情况同时尝试，在找到一种满足条件的结果的同时，也尝试了很多不必要的路径；
> -   如果是要找所有可能结果中最短的，那么BFS回更高效。因为DFS是一种一种的尝试，在把所有可能情况尝试完之前，无法确定哪个是最短，所以DFS必须把所有情况都找一遍，才能确定最终答案（DFS的优化就是剪枝，不剪枝很容易超时）。而BFS从一开始就是尝试所有情况，所以只要找到第一个达到的那个点，那就是最短的路径，可以直接返回了，其他情况都可以省略了，所以这种情况下，BFS更高效。

### LC [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

**方法一：BFS**

-   思路：将改题看作是0位根节点、树的每一个节点的值都是平方数的和的m叉树。每一个节点的值都是从根节点到当前节点的累加。而平方数的个数其实就是遍历到第几层的时候累加和等于target。我们只需要一层一层的遍历，也就是常说的BFS，当遇到累加的和等于target的时候直接返回当前的层数即可。

    <img src="alg-img/LC279-BFS.png" width="550px">


~~~java
class Solution {
    public int numSquares(int n) {
        if (n == 1) return 1;
        Queue<Integer> qu = new LinkedList<>();
        List<Integer> list = new ArrayList<>();  //[1, 4, 9]
        Set<Integer> visited = new HashSet<>();
        int cnt = 0;
        int num = 1;
        // 生成平方数方式1：
        // while (num *num <= n) {
        //     list.add(num * num); 
        //     num ++;
        // }
        // 生成平方数方式2：
        list = generateSquares(n);
        qu.add(0);
        while (!qu.isEmpty()) {
            cnt ++;
            int size = qu.size();
            for (int i = 0; i < size; i++) {
                int cur = qu.poll();
                for (int k : list) {
                    if (cur + k == n) return cnt;
                    if (cur + k > n) break;
                    if (!visited.contains(cur + k)) {
                        qu.add(cur + k);
                        visited.add(cur + k);
                    }
                }
            }
        }
        return 0;
    }
    private List<Integer> generateSquares(int n) {
        List<Integer> squares = new ArrayList<>();
        int square = 1;
        int diff = 3;
        while (square <= n) {
            squares.add(square);
            square += diff;
            diff += 2;
        }
        return squares;
    }
}
~~~

**方法二：DP**

~~~java

~~~



### LC [127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)

**方法一：BFS+visted集合-依然暴力(988ms)**

~~~java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        if (!wordList.contains(endWord)) return 0;
        Queue<String> qu = new LinkedList<>();
        Set<String> visited = new HashSet<>();
        int len = 1;
        qu.offer(beginWord);
        while (!qu.isEmpty()) {
            if (len > wordList.size() + 1) return 0;
            int size = qu.size();
            for (int i = 0; i < size; i++) {
                String curWord = qu.poll();
                for (String word : wordList) {
                    if (visited.contains(word)) continue;
                    if (!onlyOneCheck(word, curWord)) continue;
                    // 没访问过 且 只有一个字母不相同
                    if (word.equals(endWord)) return len + 1;
                    qu.add(word);
                    visited.add(word);
                }
            }
            // 开始下一层
            len ++;
        }
        return 0;
    }
    public boolean onlyOneCheck(String s1, String s2) {
        int cnt = 0;
        for (int i = 0; i < s1.length(); i++) {
            if (s1.charAt(i) != s2.charAt(i)) {
                cnt++;
                if (cnt > 1) return false;
            }
        }
        return cnt == 1;
    }
}
~~~

**方法二：BFS + 寻找合法单词方式优化(94ms)**

-   思路：

    >判断当前单词可以转换成哪些候选单词（未访问的单词），有两种思路：
    >
    >-   思路1：遍历所有候选单词，判断当前单词是否可以转换成这个候选单词。判断的过程也就是前面的canConvert方法，逐个对比单词的字符。
    >
    >-   思路2：因为单词是由 a~z 这有限数量的字符组成的，可以遍历当前单词能转换成的所有单词，判断其是否包含在候选单词中。候选单词用 HashSet 保存，可以大大提高判断包含关系的性能。
    >
    >当单词总数量庞大的时候，之前代码用到的思路1耗时就会很长。而当单词的字符串数量、单词长度很大时，思路 2 耗时就会更长。实际情况下，一般单词不会很长，字符也是固定的 26 个小写字母，因此思路2的性能会好很多。
    >

~~~java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        if (!wordList.contains(endWord)) return 0;
        Queue<String> qu = new LinkedList<>();
        Set<String> visited = new HashSet<>();
        Set<String> wordSet = new HashSet<>(wordList);
        int len = 1;
        qu.offer(beginWord);
        while (!qu.isEmpty()) {
            // if (len > wordList.size() + 1) return 0;
            int size = qu.size();
            for (int i = 0; i < size; i++) {
                String curWord = qu.poll();
                char[] curWordArr = curWord.toCharArray();
                for (int j = 0; j < curWordArr.length; j++) {
                    char originChar = curWordArr[j];
                    for (char c = 'a'; c <= 'z'; c++) {
                        curWordArr[j] = c;
                        String newWord = new String(curWordArr);
                        if (!wordSet.contains(newWord)) continue;
                        if (visited.contains(newWord)) continue;
                        if (newWord.equals(endWord)) return len + 1;
                        qu.add(newWord);
                        visited.add(newWord);
                    }
                    curWordArr[j] = originChar;
                }
            }
            len ++;
        }
        return 0;
    }
}
~~~

**方法三：双向BFS + 寻找合法单词方式优化**

~~~java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        if (!wordList.contains(endWord)) return 0;
        Set<String> wordSet = new HashSet<>(wordList);
        Queue<String> beginQueue = new LinkedList<>();
        Queue<String> endQueue = new LinkedList<>();
        beginQueue.offer(beginWord);
        endQueue.offer(endWord);
        Set<String> beginVisited = new HashSet<>();
        Set<String> endVisited = new HashSet<>();
        beginVisited.add(beginWord);
        endVisited.add(endWord);
        int len = 1;
        // qu.offer(beginWord);
        while (!beginQueue.isEmpty() && !endQueue.isEmpty()) {
            // begin: 可复用的修改
            if (beginQueue.size() > endQueue.size()) {
                Queue<String> tmpQueue = beginQueue;
                beginQueue = endQueue;
                endQueue = tmpQueue;
                Set<String> tmpVisited = beginVisited;
                beginVisited = endVisited;
                endVisited = tmpVisited;
            }
            // end.
            int beginSize = beginQueue.size();
            for (int i = 0; i < beginSize; i++) {
                String curWord = beginQueue.poll();
                char[] curWordArr = curWord.toCharArray();
                for (int j = 0; j < curWordArr.length; j++) {
                    char originChar = curWordArr[j];
                    for (char c = 'a'; c <= 'z'; c++) {
                        curWordArr[j] = c;
                        String newWord = new String(curWordArr);
                        if (!wordSet.contains(newWord)) continue;
                        if (beginVisited.contains(newWord)) continue;
                        // 两端遍历相遇，结束遍历，返回 count
                        if (endVisited.contains(newWord)) return len + 1;
                        beginQueue.add(newWord);
                        beginVisited.add(newWord);
                    }
                    curWordArr[j] = originChar;
                }
            }
            len ++;
        }
        return 0;
    }
}
~~~

>   双向BFS适用于起点和终点都知道的情况。



## -DFS

### LC [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

**方法一：DFS**

~~~java
class Solution {
    private int[][] directions = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
    public int maxAreaOfIsland(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        int ans = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                ans = Math.max(ans, dfs(grid, i, j));
            }
        }
        return ans;
    }
    public int dfs(int[][] grid, int i, int j) {
        if (i < 0 || i > grid.length - 1 || j < 0 || j > grid[0].length - 1 || grid[i][j] == 0){
            return 0;
        }
        int area = 1;
        grid[i][j] = 0;
        for (int[] dir : directions) {
            area += dfs(grid, i + dir[0], j + dir[1]);
        }
        return area;
    }
}
~~~

**方法二：**



### LC [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

**方法一：DFS**

~~~java
class Solution {
    private int[][] directions = {{0,-1}, {0,1}, {-1,0}, {1,0}};
    private int ans = 0;
    public int numIslands(char[][] grid) {
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == '1') {
                    ans += 1;
                    dfs(grid, i, j);		
                }
            }
        }
        return ans;
    }
    public void dfs(char[][] grid, int i, int j) {
        if (i < 0 || i > grid.length - 1 || j < 0 || j > grid[0].length - 1 || grid[i][j] == '0') {
            return;
        }
        grid[i][j] = '0';
        for (int[] dir : directions) {
            dfs(grid, i + dir[0], j + dir[1]);
        }   
    }
}
~~~

**方法二：并查集**

~~~java

~~~



### LC [547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)

**方法一：DFS**

~~~java
class Solution {
    public int findCircleNum(int[][] isConnected) {
        int ans = 0;
        boolean[] hasVisited = new boolean[isConnected.length];
        // dfs访问每个省份i
        for (int i = 0; i < isConnected.length; i++) {
            if (hasVisited[i] == false) {
                ans += 1;
                dfs(isConnected, i, hasVisited);
            }
        }
        return ans;
    }
    // 访问省份i，标注其已访问，并递归地访问其相邻省份
    public void dfs(int[][] isConnected, int i, boolean[] hasVisited) {
        for (int k = 0; k < isConnected[0].length; k++) {
            if (isConnected[i][k] == 1 && hasVisited[k] == false) {
                hasVisited[i] = true;
                dfs(isConnected, k, hasVisited);
            }
            
        }   
    }
}
~~~



**方法二：并查集**





### LC [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)

**方法一：DFS**

-   思路：对边上所有的"O"节点做DFS，将其标为"A"，都完成后图中找到所有被 `'X'` 围绕的区域仍然为"O"，任何边界上的 'O' 都被填充为 "A"；接下来只需要将A还原成O、将O覆盖成X即可。

~~~java
class Solution {
    private int[][] directions = {{0,-1}, {0,1}, {-1,0}, {1,0}};
    public void solve(char[][] board) {
        int m = board.length, n = board[0].length;
        // 遍历第一行和最后一行
        for (int i = 0; i < n; i++) {
            if (board[0][i] == 'O') dfs(board, 0, i);
            if (board[m - 1][i] == 'O') dfs(board, m - 1, i);
        }
        // 遍历第一列和最后一列
        for (int i = 0; i < m; i++) {
            if (board[i][0] == 'O') dfs(board, i, 0);
            if (board[i][n - 1] == 'O') dfs(board, i, n - 1);
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if(board[i][j] == 'A') board[i][j] = 'O';
                else if (board[i][j] == 'O') board[i][j] = 'X';
            }
        }
        // return board;
    }
    public void dfs(char[][] board, int i, int j) {
        if (i < 0 || i > board.length - 1 || j < 0 || j > board[0].length - 1 || board[i][j] != 'O') {
            return;
        }
        board[i][j] = 'A';
        for (int[] dir : directions) {
            dfs(board, i + dir[0], j + dir[1]);
        }   
    }
}
~~~

**方法二：BFS**

~~~java

~~~



### LC [417. 太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)

**方法一：DFS**

~~~java
class Solution {
    private int[][] directions = {{0,-1}, {0,1}, {-1,0}, {1,0}};
    public List<List<Integer>> pacificAtlantic(int[][] heights) {
        List<List<Integer>> res = new ArrayList<>();
        int m = heights.length, n = heights[0].length;
        boolean[][] canReachP = new boolean[m][n];
        boolean[][] canReachA = new boolean[m][n];
        for (int j = 0; j < n; j++) {
            dfs(heights, 0, j, canReachP);
            dfs(heights, m - 1, j, canReachA);
        }
        for (int i = 0; i < m; i++) {
            dfs(heights, i, 0, canReachP);
            dfs(heights, i, n - 1, canReachA);
        }

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (canReachP[i][j] && canReachA[i][j]) {
                    res.add(Arrays.asList(i, j));
                }
            }
        }
        return res;
    }
    public void dfs(int[][] heights, int i, int j, boolean[][] canReach) {
        if (canReach[i][j]) {
            return;
        }
        canReach[i][j] = true;
        for (int[] dir : directions) {
            int nextRow = i + dir[0], nextCol = j + dir[1];
            if (nextRow < 0 || nextRow > heights.length - 1 || nextCol < 0 || nextCol > heights[0].length - 1 || heights[nextRow][nextCol] < heights[i][j]) {
                continue;
            }
            dfs(heights, nextRow, nextCol, canReach);
        }  
    }
}
~~~



## -回溯

-   普通 DFS 主要用在 **可达性问题** ，这种问题只需要执行到特点的位置然后返回即可。
-   而 Backtracking 主要用于求解 **排列组合** 问题，例如有 { 'a','b','c' } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。

因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：

-   在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；
-   但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。



### LC [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

~~~java
class Solution {
    // 数字到号码的映射
    private String[] map = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    // 结果集
    private List<String> res = new ArrayList<>();
   
    public List<String> letterCombinations(String digits) {
        if (digits == null || digits.length() == 0) return res;
        // 路径
        StringBuffer sb = new StringBuffer();
        backtrack(sb, digits, 0);
        return res;
    }
    // 回溯函数
    // sb:路径(已选的)  digits+index：候选列表(下一步可选的)
    public void backtrack(StringBuffer sb, String digits, int index) {
        if (sb.length() == digits.length()) {
            res.add(sb.toString());
            return;
        }
        String str = map[digits.charAt(index) - '0'];  // 2 : abc
        for (char ch : str.toCharArray()) {
            sb.append(ch);
            backtrack(sb, digits, index + 1);
            sb.deleteCharAt(sb.length() - 1);
        }
    }
}
~~~



## DP

# 剑指Offer部分

## 数组与矩阵

### [剑指 Offer 03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

**方法一：Set记录**

-   思想：用一个HashSet记录已经访问过的数字，若再访问到某个数字已经再集合中了，那么他就是重复的数字。

~~~java
class Solution {
    public int findRepeatNumber(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            if (set.contains(num)) {
                return num;
            } else {
                set.add(num);
            }
        }
        return -1;
    }
}
~~~



### [剑指 Offer 04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

**方法一：Z字型搜索**

-   思路：由于每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序，所以从右上角往左下角看的话，往下走数字会变大，往左走数字会变下，就像二叉搜索树一样。

    从右上角出发，当前数比target大就往左走一格，比target小就往下走一格，其行走路线呈Z字型，故名曰“Z字型搜索”。

~~~java
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        if (matrix.length == 0 || matrix[0].length == 0) return false;
        int i = 0, j = matrix[0].length - 1;
        // 循环的终止条件是走到了左下角
        while(i < matrix.length && j >= 0) {
            if (matrix[i][j] == target) return true;
            if (matrix[i][j] < target) i ++;
            else j --;
        }
        // 走到的左下角都没遇到target，说明数组中没有
        return false;
    }
}
~~~



### [剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

**方法一：StringBuffer**

-   思路：用StringBuffer动态的追加字符，对原字符串遍历，若遇到的是非空格，则追加原来的字符；若遇到的是空格，则追加`"%20"`。

~~~java
class Solution {
    public String replaceSpace(String s) {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == ' ') {
                sb.append("%20");
            } else {
                sb.append(s.charAt(i));
            }
        }
        return sb.toString();
    }
}
~~~

### [剑指 Offer 29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

**方法一：模拟路径**

-   思路：

~~~java
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        if (matrix.length == 0 || matrix[0].length == 0) return new int[0];
        int m = matrix.length, n = matrix[0].length;
        boolean[][] visited = new boolean[m][n];
        int[] res = new int[m * n];
        int idx = 0;
        int i = 0, j = 0;
        for (int k = 0; k < m * n; k++) {
            while (j + 1 < n && !visited[i][j + 1]) {
                visited[i][j] = true;
                res[idx++] = matrix[i][j];
                j++;
            }
            while (i + 1 < m && !visited[i + 1][j]) {
                visited[i][j] = true;
                res[idx++] = matrix[i][j];
                i++;
            }
            while (j - 1 >= 0 && !visited[i][j - 1]) {
                visited[i][j] = true;
                res[idx++] = matrix[i][j];
                j--;
            }
            while (i - 1 >= 0 && !visited[i - 1][j]) {
                visited[i][j] = true;
                res[idx++] = matrix[i][j];
                i--;
            }
            if (!visited[i][j]) {
                visited[i][j] = true;
                res[idx] = matrix[i][j];
            }
        }
        return res;
    }
}
~~~

**方法二：按层模拟**

-   思路：一圈一圈的取处理，通过最上面一行、最右边一列、最下面一行、最左边一列即可确认一圈，然后对这一圈进行顺时针遍历就很简单。要注意的是，要判断最上面一行和最下面一行以及最右边一列和最左边一列是不是已经变成相同的了，如何相同了那么行或列只需要遍历一次就可以了，否则就逆序重复了。

<img src="alg-img/顺时针打印矩阵.png" width="550px">

~~~java
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        if (matrix.length == 0 || matrix[0].length == 0) return new int[0];
        int m = matrix.length, n = matrix[0].length;
        int[] res = new int[m * n];
        int idx = 0;
        int up = 0, down = m - 1, left = 0, right = n - 1;
        while (up <= down && left <= right) {
            // 最上面一行
            for (int j = left; j <= right; j++) {
                res[idx++] = matrix[up][j];
            }
            // 最右边一列
            for (int i = up + 1; i < down; i++) {
                res[idx++] = matrix[i][right];
            }
            // 最下面一行
            if (up != down) {  //如果只有一列的话只要遍历一次 不然就和1重复了
                for (int j = right; j >= left; j--) {
                    res[idx++] = matrix[down][j];
                }
            }
            // 最左边一列
            if (left != right) {  //如果只有一行的话只要遍历一次 不然就和2重复了
                for (int i = down - 1; i > up; i--) {
                    res[idx++] = matrix[i][left];
                }
            }
            up++;
            down--;
            left++;
            right--;
        }
        return res;
    }
}
~~~

### 剑指Offer-[面试题50. 第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

**方法一：哈希表**

~~~java
class Solution {
    public char firstUniqChar(String s) {
        Map<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (map.get(c) == 1) return c;
        }
        return ' ';
    }
}
// 哈希表+队列
class Solution {
    public char firstUniqChar(String s) {
        Map<Character, Integer> map = new HashMap<>();
        Queue<Character> qu = new LinkedList<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (!map.containsKey(c)) {
                map.put(c, 1);
                qu.offer(c);
            } else {
                map.put(c, map.get(c) + 1);
            }
        }
        while (!qu.isEmpty()) {
            char c = qu.poll();
            if (map.get(c) == 1) return c;
        }
        return ' ';


    }
}
~~~

**方法二：BitSet**

~~~java
class Solution {
    public char firstUniqChar(String s) {
        BitSet bs1 = new BitSet(32);
        BitSet bs2 = new BitSet(32);
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (!bs1.get(c - 'a') && !bs2.get(c - 'a')) bs1.set(c - 'a');
            else if (bs1.get(c - 'a') && !bs2.get(c - 'a')) bs2.set(c - 'a');
        }
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (bs1.get(c - 'a') && !bs2.get(c - 'a')) return c;
        }
        return ' ';
    }
}
~~~







## 栈、队列、堆

### [剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

-   思想：in栈用来push入队的元素，当首次需要出队时，将in栈中的元素全都挪到out栈中，然后再弹出第一个元素即可；注意：挪过来的元素可能不止一个，这是不需要再将其他的挪回去了，而是留着等后面的出队操作用；等out栈空了、再次调用出队操作时再将in栈中的元素挪过来，如此反复。

~~~java
class CQueue {
    public Stack<Integer> in;
    public Stack<Integer> out;
    public CQueue() {
        in = new Stack<>();
        out = new Stack<>();
    }
    public void appendTail(int value) {
        in.push(value);
    }
    public int deleteHead() {
        if (in.isEmpty() && out.isEmpty()) return -1;
        if (!out.isEmpty()) return out.pop();
        else {
            while (!in.isEmpty()) {
                out.push(in.pop());
            }
            return out.pop();
        }
    }
}
~~~

### [剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

-   思想：用一个数据栈正常进行的数据的压入和弹出操作，再用一个非严格单调栈记录压入的元素中所有曾经当过最小值的元素，从栈顶要栈底呈非严格递增。

    ​    注意：一定要非严格单调哦！比如可能压入了两个0，如果最小值栈中只记录一次0的话，那么当数据栈中上面一个0被弹出后最小值栈中的0也可能会被跟着弹出，那么其中就没有0了，而事实上数据栈中的0还是有可能在后面继续作为最小值的。

~~~java
class MinStack {
    private Stack<Integer> stack;
    private Stack<Integer> minStack;
    public MinStack() {
        stack = new Stack<>();
        minStack = new Stack<>();
    }
    public void push(int x) {
        stack.push(x);
        if (minStack.isEmpty() || x <= minStack.peek()) {  // 非严格单调！！！
            minStack.push(x);
        }
    }
    public void pop() {
        int x = stack.pop();
        if (x == minStack.peek()) minStack.pop();
    }
    public int top() {
        return stack.peek();
    }
    public int min() {
        if (!minStack.isEmpty()) return minStack.peek();
        else return -1;
    }
}
~~~



### [剑指 Offer 31. 通过栈的压入、弹出序列判断合法性](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

-   思路：由于序列中的元素都是唯一的，所以每个元素的进栈和出栈的时间都是唯一确定的，那么就可以用一个栈来模拟序列的进栈和出栈情况。进栈一个元素，若栈顶元素等于出栈序列的第一个，那么说明栈顶元素就是在此时出栈的：将其出栈，直到栈顶元素不等于队首元素(题目里直接用原序列和idx索引来模拟了，也可以用队列存放，然后队首和栈顶相等时同步出队和出栈)。整个入栈流程结束后，若出栈序列合法的话，栈中的元素应该全部被弹出去了，否则的话说明该出栈序列不合法。

~~~java
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        Stack<Integer> stack = new Stack<>();
        int idx = 0;
        for (int i = 0; i < pushed.length; i++) {
            stack.push(pushed[i]);
            while (!stack.isEmpty() && stack.peek() == popped[idx]) {
                stack.pop();
                idx ++;
            }
        }
        return stack.isEmpty();
    }
}
~~~



### [剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

-   思路：

~~~java
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        Queue<Integer> heap = new PriorityQueue<>();
        int[] res = new int[k];
        for (int i = 0; i < arr.length; i++) {
            heap.offer(arr[i]);
        }
        for (int i = 0; i < k; i++) {
            res[i] = heap.poll();
        }
        return res;
    }
}
// 优化版：当剩余的不足k个了，则当前最小堆的根一定在答案里面。
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        Queue<Integer> heap = new PriorityQueue<>();
        int[] res = new int[k];
        int idx = 0;
        for (int i = 0; i < arr.length; i++) {
            heap.offer(arr[i]);
            if (arr.length - i - 1 < k) {
                res[idx++] = heap.poll();
            }
        }
        return res;
    }
}
~~~

### 

### [剑指 Offer 41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)

-   思路：

~~~java
class MedianFinder {
    Queue<Integer> minHeap;  // 让minHeap元素多一个  保存较大的元素
    Queue<Integer> maxHeap;  // 保存较小的元素
    public MedianFinder() {
        minHeap = new PriorityQueue<>();
        maxHeap = new PriorityQueue<>((o1, o2) -> (o2 - o1));
        /**
            maxHeap = new PriorityQueue<>((o1, o2) -> {
                return o2 - o1;
            });
        */
    }
    public void addNum(int num) {
        // 此时minHeap多一个元素，所以应该给maxHeap新增一个元素了,但不能保证num是较小的一半,所以
        //   将其先加到minHeap中,然后把minHeap的堆顶部元素(即当前较大部分的最小值)挪到maxHeap中
        if (minHeap.size() != maxHeap.size()) {  
            minHeap.offer(num);
            maxHeap.offer(minHeap.poll());
        } 
        // 此时minHeap和maxHeap元素个数一样多,应该给minHeap新增一个元素了，但不能保证num是较大的一半,
        // minHeap中保存的是这个序列较大的一半，所以应该先将num加到maxHeap中，
        // 然后把maxHeap的堆顶部元素(即当前较小部分的最大值)挪到minHeap中
        else {
            maxHeap.offer(num);
            minHeap.offer(maxHeap.poll());
        }
    }
    public double findMedian() {
        if (minHeap.size() != maxHeap.size()) return (double)minHeap.peek();
        else return (minHeap.peek() + maxHeap.peek()) / 2.0;
    }
}
~~~



### [剑指Offer 41.1  字符流中第一个不重复的字符](https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=23448&ru=%2Fpractice%2F00de97733b8e4f97a3fb5c680ee10720&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&sourceUrl=)

**方法一：哈希**

-   思路：类似剑指offer-面试题50，先遍历一遍，用哈希表记录每个字符出现的次数；然后再遍历一遍，直到遇到第一个只出现一次的。

~~~java
import java.util.*;
public class Solution {
    public Map<Character, Integer> map = new HashMap<>();
    public List<Character> list = new ArrayList<>();
    public void Insert(char ch)
    {
        list.add(ch);
        map.put(ch, map.getOrDefault(ch, 0) + 1);
    }
    public char FirstAppearingOnce()
    {
        for (char c : list)
        {
            if (map.get(c) == 1)
            {
                return c;
            }
        }
        return '#';
    }
}
~~~

**方法二：哈希+队列优化**

-   思路：还是用哈希表记录字符出现的次数，然后维护一个队列，用来存放第一次出现的字符：如果一个字符是第一次出现，就把他加入到队列，这样队列中的元素都是曾经在子串中只出现一次的，且队列中的先后关系也体现了他们在字符串中的先后关系。那么当我们需要获取当前串的第一个不重复的字符时，是不是只要输出队列的队首字符就可以了呢？显然不是的，因为队首的字符可能在后面又出现了，即队首的字符此时可能已经“失效”了；所以应该首先看看队首的元素在整个串中的最新的出现次数，如果发现次数不是1了，那么把他从队首移除；如果次数仍然是1，那么它就是目标字符；如果整个队列都弹出了，那说明没有只出现一次的元素。

~~~java
import java.util.*;
public class Solution {
    public Map<Character, Integer> map = new HashMap<>();
    public List<Character> list = new ArrayList<>();
    public Queue<Character> queue = new LinkedList<>();
    public void Insert(char ch)
    {
        list.add(ch);
        if (!map.containsKey(ch)) {
            queue.offer(ch);
            map.put(ch, 1);
        } else {
            map.put(ch, map.get(ch) + 1);
        }
    }
    public char FirstAppearingOnce()
    {
        while (!queue.isEmpty()) {
            if (map.get(queue.peek()) == 1) {
                return queue.peek();
            } else {
                queue.poll();
            }
        }
        return '#';
    }
}
~~~

>   加队列优化比较适合这种字符流的情景，像第50题那样固定的字符串的话反而会变慢；在字符流情景中，字符是一直在追加的、查询也是可能随机发生的，如果不用一个队列维护上一时刻的情况，则每次查询时都要每次都要从头遍历字符串。

### [剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

**方法一：堆**

-   思路：

~~~java

~~~



**方法二：滑动窗口+双端单调队列**

~~~java

~~~











## 双指针

### [剑指 Offer 57. 和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/)

-   思路：双指针left和right初始分别指向第一个和最后一个数字，left只能向右移动，right只能向左移动，这样当num[i] + num[j] 小于target时，left向右移动一位，大于target时，right向左移动一位，等于时即为解。若left跑到了right右边，则说明无解。

~~~java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while (l < r) {
            if (nums[l] + nums[r] == target) return new int[]{nums[l], nums[r]};
            else if (nums[l] + nums[r] > target) r--;
            else l++;
        }
        return new int[0];
    }
}
~~~



### [剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

**方法一：双指针+滑动窗口**

-   思路：用i表示左边界，j表示右边界，**窗口的左边界和右边界永远只能向右移动**，而不能向左移动。初始设置i在1位置，j也在1位置，但是sum不要把j也加进去，sum初始设置为1；当窗口的和小于target时，j向右移动一位，并把新的值加入sum；当窗口的和大于target时，先将i从sum中减去，然后i向右移动一位；当窗口的和等于target时，输出一组答案，然后将i从sum中减去，将i向左移动一位（因为以i开头只可能有一个答案，接下来左边界向右移动，找以i+1开头的）。j最右边界应该是(n + 1) / 2，因为后面任意两个数字之和都大于n。

~~~java
class Solution {
    public int[][] findContinuousSequence(int target) {
		int i = 1; // 滑动窗口的左边界
        int j = 1; // 滑动窗口的右边界
        int sum = 1; // 滑动窗口中数字的和
        List<int[]> res = new ArrayList<>();
        while (j < target - 1) {  // j <= (target + 1) / 2
            if (sum < target) {
                // 右边界向右移动
                j++;
                sum += j;
            } else if (sum > target) {
                // 左边界向右移动
                sum -= i;
                i++;
            } else {
                // 记录结果 i~j
                int[] arr = new int[j-i+1];
                for (int k = i; k <= j; k++) {
                    arr[k-i] = k;
                }
                res.add(arr);
                // 以i开头只可能有一个答案，接下来左边界向右移动，找以i+1开头的
                sum -= i;
                i++;
            }
        }
        return res.toArray(new int[res.size()][]);
    }
}
~~~

>   滑动窗口的重要性质是：**窗口的左边界和右边界永远只能向右移动**，而不能向左移动。

### [剑指 Offer 58 - I. 翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)

**方法一：双指针**

-   思路：先将原字符串以空格为分隔符分成字符串数组，然后利用双指针反转字符串数组，最后通过StringBuffer来遍历的追加每个字符串，要注意的是根据题意如果要追加的字符串不是空格，那么要在其后面再追加一个空格；如果要追加的字符串就是空格，那么就不用再额外加空格了；遍历结束后还要将字符串首尾的空格去掉！

~~~java
class Solution {
    public String reverseWords(String s) {
        String[] strArr = s.split(" ");
        int i = 0, j = strArr.length - 1;
        while (i < j) {
            String temp = strArr[i];
            strArr[i] = strArr[j];
            strArr[j] = temp;
            i++;
            j--;
        }
        StringBuffer sb = new StringBuffer();
        for (int k = 0; k < strArr.length; k++) {
            sb.append(strArr[k]);
            if (!strArr[k].trim().isEmpty()) sb.append(" ");
        }
        return sb.toString().trim();

    }
}
~~~

>   if (!strArr[k].trim().isEmpty()) sb.append(" ");  // 判断字符串是否是空格
>
>   sb.toString().trim();  // trim()可以将字符串的首尾的空格都去掉，返回一个新的字符串。

### [剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

**方法一：字符串遍历遍历拼接**

~~~java
class Solution {
    public String reverseLeftWords(String s, int n) {
        StringBuffer sb = new StringBuffer();
        for (int i = n; i < s.length(); i++) {
            sb.append(s.charAt(i));
        }
        for(int i = 0; i < n; i++) {
            sb.append(s.charAt(i));
        }
        return sb.toString();
    }
}
~~~

**方法二：字符串取余遍历遍历拼接**

~~~java
class Solution {
    public String reverseLeftWords(String s, int n) {
        StringBuffer sb = new StringBuffer();
        for (int i = n; i < s.length() + n; i++) {
            sb.append(s.charAt(i % s.length()));
        }
        return sb.toString();
    }
}
~~~

>   新学习到一种遍历思想！



### 48题

参考acwingT61





## 链表

### [剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

**方法一：递归反转链表后再遍历**

-   思路：用一个pre指针指着已经归入新链表的头，用cur指针指着还未归入新链表部分的头，用temp指针记录这cur的下一个节点，然后将cur指向pre，然后pre/cur/temp整体往后移动一位，直到cur为null，即原链表的尾部空节点。

~~~java
class Solution {
    public int len = 0;
    public int[] reversePrint(ListNode head) {
        if (head == null) return new int[0];
        ListNode p = reverse(null, head);
        int[] res = new int[len];
        int idx = 0;
        while (p != null) {
            res[idx++] = p.val;
            p = p.next;
        }
        return res;
    }
    public ListNode reverse(ListNode pre, ListNode cur) {
        if (cur == null) {
            return pre;
        }
        len ++;
        // 记住当前节点的后一个节点，然后将当前节点连接到前一个节点(头结点的前一个节点设置为null)
        ListNode temp = cur.next;
        cur.next = pre;
        return reverse(cur, temp);
    }
}
~~~

**方法二：递归-在递归的过程中输出**

-   思路：递归出口：当遍历到空节点时；然后通过栈的本质去逆序打印所有节点。

~~~java
class Solution {
    public List<Integer> list = new ArrayList<>();
    public int[] reversePrint(ListNode head) {
        dfs(head);
        int[] res = new int[list.size()];
        for (int i = 0; i < list.size(); i++) {
            res[i] = list.get(i);
        }
        return res;
    }
    public void dfs(ListNode p) {
        if (p == null) return;
        dfs(p.next);
        list.add(p.val);
    }
    /** 也可以利用反转链表的dfs模板，先将链表反转，然后再打印
    ListNode p = dfs(null, head); // 反转后的新链表
    public ListNode dfs(ListNode pre, ListNode cur) {
        if (cur == null) return pre;
        len ++;
        ListNode temp = cur.next;
        cur.next = pre;
        return dfs(cur, temp);
    }
    */
}
~~~

**方法三：非递归反转链表后再遍历**

-   思路：用一个pre指针指着已经归入新链表的头，用cur指针指着还未归入新链表部分的头，用temp指针记录这cur的下一个节点，然后将cur指向pre，然后pre/cur/temp整体往后移动一位，直到cur为null，即原链表的尾部空节点。

~~~java
class Solution {
    public int len = 0;
    public int[] reversePrint(ListNode head) {
        if (head == null) return new int[0];
        ListNode p = reverse(head);
        int[] res = new int[len];
        int idx = 0;
        while (p != null) {
            res[idx++] = p.val;
            p = p.next;
        }
        return res;
    }
    public ListNode reverse(ListNode head) {
        if (head == null) return null;
        ListNode pre = null, cur = head;
        ListNode tmp;
        while (cur != null) {
            len ++;
            tmp = cur.next;  // 注意tmp要在cur更新前先更新一下！
            cur.next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
}
~~~

*递归和非递归的思想是一样的，只是递归地写法更加优雅。*

**方法四：栈**

~~~java
class Solution {
    public int[] reversePrint(ListNode head) {
        if (head == null) return new int[0];
        Stack<ListNode> stack = new Stack<>();
        int len = 0;
        ListNode p = head;
        while (p != null) {
            len ++;
            stack.push(p);
            p = p.next;
        }
        int[] res = new int[len];
        for (int i = 0; i < len; i++) {
            res[i] = stack.pop().val;
        }
        return res;
    }
}
~~~



### [剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

-   思路：

    特判：如果要删除的是第一个节点，那么直接返回第二个节点(链表只有一个节点的情况也包括在这里了)。

    用一个指针pre指向一个节点，再用一个指针cur指向下一个节点，当发现cur就是要删除的节点时，将pre.next直接指向cur.next，然后返回头结点。

~~~java
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        // if (head == null || head.next == null) return null;
        if (head.val == val) return head.next;
        ListNode pre = head, cur = pre.next;
        while (cur != null && cur.val != val) {
            pre = cur;
            cur = pre.next;
        }
        pre.next = cur.next;
        return head;
    }
}
// 引入哨兵节点
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode pre = dummy, cur = head;
        while (cur != null && cur.val != val) {
            pre = cur;
            cur = cur.next;
        }
        pre.next = cur.next;
        return dummy.next;
    }
}
~~~



### [剑指Offer 76. 删除链表中重复的结点-不保留](https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github)

-   思路：先用一个哨兵节点指向头节点，因为头节点本身也可能是重复的值而被删掉，那么如果没有哨兵节点的话链表的头就丢失了；然后用cur指针进行遍历，如果cur的后一个节点值和cur的值不相等，那么pre指针和cur指针同步往后移动；如果cur的后一个节点值和cur的值相等，让cur独自往后移动，只要cur的后一个节点值和cur的值不相等，此时pre.next到cur这一段都是重复的节点，因此将pre.next指向cur.next即可将这些重复的节点都删掉了。

~~~java
public class Solution {
    public ListNode deleteDuplication(ListNode pHead){
        ListNode dummy = new ListNode(-1);
        // 哨兵节点初始指向头节点 记录的是有效链表的起点
        dummy.next = pHead;
        // pre记录的是
        ListNode pre = dummy, cur = pHead;
        while (cur != null){
            // 如果cur的下一个节点存在且它的值和cur的值相等
            if (cur.next != null && cur.val == cur.next.val){
                // 一直让cur往后跑 直到cur的下一个节点的值和cur的值不相等或者跑到最后一个节点了
                while (cur.next != null && cur.val == cur.next.val){
                    cur = cur.next;
                } // 此时cur的下一个节点的值和cur的值不相等
                cur = cur.next;
                pre.next = cur;
            } else{ 
                pre = cur;
                cur = cur.next;
            }
        }
        return dummy.next;
    }
}
~~~

>   同 LC [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

### [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

~~~java
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode slow = head, fast = head;
        int cnt = 1;
        while (fast.next != null) {
            if (cnt >= k) slow = slow.next;
            fast = fast.next;
            cnt ++;
        }
        return slow;
    }
}
~~~

### [剑指Offer 23. 链表中环的入口结点](https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github)

**方法一：哈希**

~~~java
import java.util.*;
public class Solution {
    public ListNode EntryNodeOfLoop(ListNode pHead) {
        int[] visited = new int[10010];
        ListNode p = pHead;
        while (p != null){
            if (visited[p.val] == 1) return p;
            else {
                visited[p.val] = 1;
                p = p.next;
            }
        }
        return null;       
    }
}
~~~

**方法二：快慢指针**

~~~java
// 写法一：
import java.util.*;
public class Solution {
    public ListNode EntryNodeOfLoop(ListNode pHead) {
        ListNode preHead = new ListNode(-1);
        preHead.next = pHead;
        ListNode slow = preHead;
        ListNode fast = preHead;
        // 这里起点是放在头节点的前一个的，要先走再判断
        // 先走再判断
        while (true){
            slow = slow.next;
            fast = fast.next.next;
            if (fast == null || fast.next == null) return null;
            if (slow == fast) break;
        } 
        ListNode preMeet = new ListNode(-1);
        slow = preHead;
        // 先走再判断
        while (true){
            slow = slow.next;
            fast = fast.next;
            if (slow == fast) break;
        }
        return slow;
    }
}
// 写法二：参考评论区
import java.util.*;
public class Solution {
    public ListNode EntryNodeOfLoop(ListNode pHead) {
        if(pHead == null) return null;
        ListNode slow = pHead;
        ListNode fast = pHead;
        // 这里起点是放在头节点上的，要先判断再走
        // 先判断再走
        while (fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) break;
        } 
        // 不能放进前面的循环中判断 而必须在这里判断一次，因为可能只有一个数，那么整趟都不会进入上面的循环 eg:1->x
        if (fast == null || fast.next == null) return null;
        slow = pHead;
        // 先判断再走
        while (slow != fast){
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
}
~~~

>   类似 LC [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

### [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

**方法一：递归**

~~~java
class Solution {
    public ListNode reverseList(ListNode head) {
        return reverse(null, head);
    }
    public ListNode reverse(ListNode pre, ListNode cur) {
        if (cur == null) return pre;
        ListNode next = cur.next;
        cur.next = pre;
        return reverse(cur,next);
    }
}
~~~

**方法二：非递归**

~~~java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        ListNode next;
        while(cur != null) {
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
~~~

### [剑指 Offer 25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

~~~java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode p1 = l1;
        ListNode p2 = l2;
        ListNode head = new ListNode(-1);
        ListNode p = head;
        while (p1 != null && p2 != null) {
            if (p1.val <= p2.val) {
                p.next = p1;
                p = p.next;
                p1 = p1.next;
            }
            else {
                p.next = p2;
                p = p.next;
                p2 = p2.next;
            }
        }
        while (p1 != null) {
            p.next = p1;
            p = p.next;
            p1 = p1.next;
        }
        while (p2 != null) {
            p.next = p2;
            p = p.next;
            p2 = p2.next;
        }
        return head.next;

    }
}
~~~

### [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

-   思路：用两个指针再两个链表同时往后遍历，若某一个走到末尾的空节点了两个节点还是不相等，那么从另一个链表的头继续遍历，直到相遇。

    **注意：这里得用`pA == null`来判断是不是需要去另一个链表的头了**，这样的话等于是把两个链表的尾部的空节点也纳入相同节点的考虑范畴，这样即使没有其他相同的非空节点，两个指针也一定会在空节点出相遇。

~~~java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode pA = headA;
        ListNode pB = headB;
        while (pA != pB) {
            pA = pA == null ? headB : pA.next;  
            pB = pB == null ? headA : pB.next;
        }
        // if (pA == null) return null;
        return pA;
    }
}
~~~

### [剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

**方法一：哈希表**

-   思路：先遍历一遍原链表，并根据原节点的值生成新节点，然后将他们的对应关系存入哈希表；再进行一轮遍历，将原节点对应的新节点的next和random指针通过哈希表里的映射关系分别指针对应的新节点。

~~~java
class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) return null;
        Map<Node, Node> map = new HashMap<>();  // <old, new>
        // Node dummy = new Node(-1);
        Node p = head;
        while (p != null) {  // 生成所有的新节点
            map.put(p, new Node(p.val));
            p = p.next;
        }
        p = head;
        while (p != null) {  // 利用哈希表可以查询到各个新指针该指向何处
            map.get(p).next = map.get(p.next);
            map.get(p).random = map.get(p.random);
            p = p.next;
        }
        return map.get(head);
    }
}
~~~







## 树

### [剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

**方法一：分治**

-   思路：利用`preOrder[preL, preR]`数组获取根节点`preOrder[preL]`，再去`inOrder[inL,inR]`数组中找根节点对应的下标`inIndex`，这样通过`inIndex-inL`就可以知道这棵(子)树根节点的左子树有多少个元素，这样就能将区间根据左右子树再划分了；然后递归的去处理左右子树。
-   递归终止条件是`preL > preR`，好像一般区间类分治/递归问题的终止条件都是这个？
-   中序序列主要是用来通过根节点在中序序列中的索引减去中序序列的左区间起点来获得左子树的节点数，所以可以将节点在中序序列中的索引放到哈希表中，方便后面的查找。

~~~java
class Solution {
    Map<Integer, Integer> index = new HashMap<>();
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        // if (preorder.length == 0) return null;
        // if (preorder.length == 1) return new TreeNode(preorder[0]);
        for (int i = 0; i < inorder.length; i++) {
            index.put(inorder[i], i);
        }
        return buildTreeHelper(preorder, 0, preorder.length - 1, 0);
    }
    public TreeNode buildTreeHelper(int[] preorder, int preL, int preR, int inL) {
        if (preL > preR) return null;
        TreeNode root = new TreeNode(preorder[preL]);
        int inIndex = index.get(preorder[preL]);
        int leftTreeSize = inIndex - inL;  //  (idx - inL + 1) - 1  
        root.left = buildTreeHelper(preorder, preL+1, preL+leftTreeSize, inL);
        root.right = buildTreeHelper(preorder, preL+leftTreeSize+1, preR, inIndex+1);
        return root;
    }
}
~~~



### [剑指 Offer 二叉树的下一个结点](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github)

**方法一：**

-   思路：

    > -   1.右子树存在：右子树中序遍历第一个
    > -   2.没有右子树且是左节点：父节点
    > -   3.没有右子树且是右边节点：所属左子树的根节点(若该节点是整个树的最右下节点，那么可以看做整个树是一个根为空的更大的树的左子树，这种情况下next也是空哦)
    > -   4.没有父节点：空

~~~java
// 返回中序遍历的下一个节点
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode) {
        // 1.有右子树：右子树中序遍历第一个
        if (pNode.right != null) {
            TreeLinkNode p = pNode.right;
            // 找右子树的最左下角节点
            while (p.left != null) p = p.left;
            return p;
        } 
         // 2.没有右子树且是左节点：父节点
        if (pNode.next != null && pNode.next.left == pNode) {
            return pNode.next;
        } 
        // 3.没有右子树且是左节点：所属左子树的根节点
        if (pNode.next != null && pNode.next.right == pNode) {
            TreeLinkNode p = pNode.next;
            // 仍是右子树 一直往上走 （要先对p.next判空 因为p可能是一棵树的最右下节点，走到整个树的根节点时p.next.right就不存在了）
            while (p.next != null && p.next.right == p) p = p.next;
            return p.next;
            //return null;
        }
        return null;
    }
}
~~~



### [剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

**方法一：递归**

-   思路： 宏观来看，如果B是A的子树的话有三种可能性：1.B和A就是一样的树；2.B和A的某个左子树相同；3.B和A的某个右子树相同；其中二三都是可以通过递归来判断的。

~~~java
class Solution {
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        if (A == null && B == null) return true;
        if (A == null || B == null) return false;
        // 宏观来看，如果B是A的子树的话有三种可能性：
        return recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);
    }
    // 以A为根节点的(子)树是否包含树B
    public boolean recur(TreeNode A, TreeNode B) {
        if (B == null) return true;
        if (A == null || A.val != B.val) return false;
        return recur(A.left, B.left) && recur(A.right, B.right);
    }
}
~~~

>   对比：判断两棵树是不是相同的树
>
>   ~~~java
>   class Solution {
>       public boolean isSameTree(TreeNode p, TreeNode q) {
>           if (p == null && q == null) return true;
>           if (p == null || q == null) return false;
>           if (p.val != q.val) return false;
>           return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
>       }
>   }
>   ~~~
>
>   

### [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

**方法一：递归-带返回值-自底向上**

~~~java
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        if (root == null) return null;
        // 这里要先保存原来的值 不能直接赋给新的节点，不然root.right获得的就不是原来的值了，它参与了两次变换
        TreeNode left = mirrorTree(root.left);
        TreeNode right = mirrorTree(root.right);
        root.left = right;
        root.right = left;
        return root;
    }
}
~~~

**方法二：递归-不带返回值-自顶向下**

~~~java
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        if (root == null) return null;
        reverse(root);
        return root;
    }
    public void reverse(TreeNode root) {
        if (root == null) return;
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        reverse(root.left);
        reverse(root.right);
    }
}
~~~



### [剑指 Offer 28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

**方法一：**

-   思路：自顶向下，先判断左右孩子节点是不是相等，再判断左孩子的左节点是不是和右孩子的右节点相等、左孩子的右节点是不是和右孩子的左节点相等。

~~~java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) return true;
        return judge(root.left, root.right);
    }
    // 判断两个节点的值是否相等
    public boolean judge(TreeNode p1, TreeNode p2) {
        if (p1 == null && p2 == null) return true;
        if (p1 == null || p2 == null) return false;
        if (p1.val != p2.val) return false;
        // 再镜像地递归地去检查子树节点
        return judge(p1.left, p2.right) && judge(p1.right, p2.left);
    }
}
~~~



### [剑指 Offer 32 - II. 从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

~~~java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null) return ans;
        Queue<TreeNode> qu = new LinkedList<>();
        qu.offer(root);
        int size = 0;
        while (!qu.isEmpty()) {
            size = qu.size();
            List<Integer> list = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                TreeNode cur = qu.poll();
                list.add(cur.val);
                if (cur.left != null) qu.offer(cur.left);
                if (cur.right != null) qu.offer(cur.right);
            }
            ans.add(list);
        }
        return ans;
    }
}
~~~



### [剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

**方法一：BFS+反转数组**

-   思路：正常BFS，若是偶数行的话先反转list再将其加入到结果集中。

~~~java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null) return ans;
        Queue<TreeNode> qu = new LinkedList<>();
        qu.offer(root);
        int size = 0;
        int level = 0;
        while (!qu.isEmpty()) {
            level++;
            size = qu.size();
            List<Integer> list = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                TreeNode cur = qu.poll();
                list.add(cur.val);
                if (cur.left != null) qu.offer(cur.left);
                if (cur.right != null) qu.offer(cur.right);
            }
            if ((level & 1) == 0) Collections.reverse(list);
            ans.add(list);
        }
        return ans;
    }
}
~~~

**方法二：BFS+双端队列**

-   思路：用双端队列来接收每一层的节点，奇数层的节点从队尾入队（正序），偶数层的节点从队头入队（逆序），然后加入结果集。

~~~java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null) return ans;
        Queue<TreeNode> qu = new LinkedList<>();
        qu.offer(root);
        int size = 0;
        int level = 0;
        while (!qu.isEmpty()) {
            level++;
            size = qu.size();
            // 双端队列不能用多态的方式写声明
            LinkedList<Integer> dequeue = new LinkedList<>();
            for (int i = 0; i < size; i++) {
                TreeNode cur = qu.poll();
                // 如果正在奇数行，从队尾入队
                if ((level & 1) == 1) dequeue.addLast(cur.val);
                // 如果正在偶数行，从队头入队，实现逆序处理
                else dequeue.addFirst(cur.val);
                if (cur.left != null) qu.offer(cur.left);
                if (cur.right != null) qu.offer(cur.right);
            }
            ans.add(dequeue);
        }
        return ans;
    }
}
~~~



### [剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

**方法一：递归判断**

-   思想：对于二叉搜索树的后序遍历序列postorder[l, r]， postorder[r]为根，那么前面的元素应该刚好可以被分成两部分，前半部分都小于postorder[r]，后半部分都大于postorder[r]，因此可以在前面的连续序列中先往前找到大于postorder[r]的最左边界，再找小于postorder[r]的最左边界。此时找到的最左边界刚好就是整个区间的最左边界，那么说明根前面的元素可以刚好被分成两部分，即满足要求，再递归地检查这两棵子树；若此时找到的最左边界不是整个区间的最左边界，则不满足BST的要求，直接返回false。

    <img src="alg-img/二叉搜索树的后序遍历序列.png" width="500px">

~~~java
class Solution {
    public boolean verifyPostorder(int[] postorder) {
        if (postorder.length <= 1) return true;
        return jugde(postorder, 0, postorder.length - 1);
    }
    public boolean jugde(int[] postorder, int l, int r) {
        if (l >= r) return true;
        int k = r - 1;  // 4
        while (k >= l && postorder[k] > postorder[r]) {
            k --;
        }
        int j = k + 1;
        while (k >= l && postorder[k] < postorder[r]) {
            k --;
        }
        int i = k + 1;
        if (i != l) return false;
        return jugde(postorder, l, j - 1) && jugde(postorder, j, r - 1);
    }
}
~~~

**方法二：单调栈**

~~~java

~~~



### [剑指 Offer 34. 二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

**方法一：DFS**

-   思路：不要想那么多、加入过多的递归终止条件，只需要正常dfs遍历一遍树，当遇到符合条件的路径将其加入结果集即可，要注意的仅是结束一棵子树的dfs遍历后得回溯一下路径表。

~~~java
class Solution {
    public List<List<Integer>> res = new ArrayList<>();
    // List<Integer> route = new ArrayList<>();
    Stack<Integer> path = new Stack<>();
    public List<List<Integer>> pathSum(TreeNode root, int target) {
        if (root == null) return res;  // 可能是负的 需要root.val == 0不能作为特判断条件
        dfs(root, target);
        return res;
    }
    public void dfs(TreeNode root, int target) {
        if (root == null) return;
        // 将当前节点加入路径，并使target减去当前节点的值
        path.push(root.val);
        target -= root.val;
        if (root.left == null && root.right == null && target == 0) {
            // res.add(route); // 如果直接传入那么传入的是地址，后续list/stack发生改变是，已经加入res的也会跟着改变，所以得先复制一份再加入res
            res.add(new ArrayList<Integer>(path));  // 就算用List的话也要先复制一份再加入res
        }
        dfs(root.left, target);
        dfs(root.right, target);
        // target += root.val;  // 每次进入dfs的时候target都是更新过的 每个dfs()独用一个target 这里不需要回溯
        // 结束当前子树的遍历，将实时路径回溯
        path.pop();  // 只有这个公用的需要回溯
    }
}
~~~

>    ans.add(list); 如果直接传入list，当后续list改变时，加入到ans的list也会改变，所以题解用了 ans.add(new Linked(list))，对list进行了复制在插入ans



### [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

-   思路：

    **treeToDoublyList(root)：**

    1.  特例处理： 若节点 root 为空，则直接返回；

    2.  初始化： 空节点 pre ；

    3.  转化为双向链表： 调用 dfs(root) ；

    4.  构建循环链表： 中序遍历完成后，head 指向头节点， pre 指向尾节点，因此修改 head 和 pre 的双向节点引用即可；

    5.  返回值： 返回链表的头节点 head 即可；

    **dfs(cur):** 递归法中序遍历；

    1. 终止条件： 当节点 cur 为空，代表越过叶节点，直接返回；

    2. **递归左子树**，即 dfs(cur.left) ；

    3. 构建链表：
       当 pre 为空时： 代表正在访问链表头节点，记为 head ；
       当 pre 不为空时： 修改双向节点引用，即 pre.right = cur ， cur.left = pre ；
       保存 cur ： 更新 pre = cur ，即节点 cur 是后继节点的 pre ；
       
    4. **递归右子树**，即 dfs(cur.right) ；


~~~java
class Solution {
    private Node head, pre;
    public Node treeToDoublyList(Node root) {
        if (root == null) return null;
        inOrder(root);
        // 此时head仍指向中序遍历的第一个节点，它就是链表的头节点；
        // cur停留在了最右下角的null节点出，pre则指向中序遍历的最后一个节点，它就是链表的尾节点
        // 将头尾相接
        head.left = pre;
        pre.right = head;
        return head;
    }
    public void inOrder(Node cur) {
        if (cur == null) {
            return;
        }
        inOrder(cur.left);
        // 此时是中序遍历的第一个节点，左边没有节点，无需节点连接操作
        if (pre == null) {
            head = cur;
            pre = cur;
        } 
        // 将前一个节点的right指向当前节点，将当前节点的left指向前一个节点
        else {
            pre.right = cur;
            cur.left = pre;
            pre = cur;
        }
        inOrder(cur.right);
    }
}
~~~



### [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

-   思想：逆中序遍历即可

~~~java
class Solution {
    public int target, cnt, ans;
    public int kthLargest(TreeNode root, int k) {
        target = k;
        dfs(root);
        return ans;
    }
    public void dfs(TreeNode cur) {
        if (cur == null) return;
        dfs(cur.right);
        cnt ++;
        if (cnt == target) {
            ans = cur.val;
            return;
        }
        dfs(cur.left);
    }
}
~~~



### [剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

-   思想：自底向上：当前节点的高度等于左右子树中较大的高度加1.

~~~java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
}
~~~



### [剑指 Offer 55 - II. 平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)

-   思想：套用自底向上求二叉树的高度的模板，并在更新一棵树的高度时先比较左右两棵子树的高度，若高度差大于1，则说明不是AVL，将全局变量改成false；

~~~java
class Solution {
    public boolean flag = true;
    public boolean isBalanced(TreeNode root) {
        getHeight(root);
        return flag;
    }
    public int getHeight(TreeNode root) {
        if (root == null) return 0;
        int l = getHeight(root.left);
        int r = getHeight(root.right);
        if (Math.abs(l - r) > 1) flag = false;
        return Math.max(l, r) + 1;
    }
}
~~~

### [剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

-   思想：先做特判，若根节点为空或者根节点就是p或q其中的一个，那么根节点就是所求最近公共祖先；不是特判情况的话，对左右子树分别递归地查找，自底向上返回p和q在不同层面的子树中属于哪一侧，直到遇到某个层面的子树，p和q分布在_root两侧。

    >   [参考题解：](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/solution/mian-shi-ti-68-ii-er-cha-shu-de-zui-jin-gong-gon-7/)
    >
    >   若 root 是 p, q 的 最近公共祖先 ，则只可能为以下情况之一：
    >
    >   1.  p和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；
    >
    >   2.  p=root ，且 q 在 root 的左或右子树中；
    >
    >   3.  q=root ，且 p 在 root 的左或右子树中；
    >
    >   考虑通过递归对二叉树进行先序遍历，当遇到节点 p 或 q 时返回。**从底至顶回溯，当节点 p, q 在节点 root 的异侧时，节点 root 即为最近公共祖先，则向上返回 root **。
    >
    >   递归解析：
    >
    >   1.  终止条件：
    >       当越过叶节点，则直接返回 null ；
    >       当 root 等于 p, q，则直接返回 root ；
    >   2.  递推工作：
    >       开启递归左子节点，返回值记为 left ；
    >       开启递归右子节点，返回值记为 right ；
    >   3.  返回值： 根据 eft 和 right ，可展开为四种情况；
    >       1.  当 left 和 right 同时为空 ：说明 root 的左 / 右子树中都不包含 p,q ，返回 null ；
    >       2.  当 left 和 right 同时不为空 ：说明 p,q 分列在 root 的 异侧 （分别在 左 / 右子树），因此 root 为最近公共祖先，返回 root ；
    >       3.  当 left 为空 ，right 不为空 ：p,q 都不在 root 的左子树中，直接返回 right 。具体可分为两种情况：
    >           p,q 其中一个在 root 的 右子树 中，此时 right 指向 pp（假设为 pp ）；
    >           p,q 两节点都在 root 的 右子树 中，此时的 right 指向 最近公共祖先节点 ；
    >       4.  当 left 不为空 ， right 为空 ：与情况 3. 同理；

~~~java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) return null;
        if (root == p || root == q) return root;
        /**  
        如果root不是p或q中的一个，那么p和q都在root的子树中，递归地去左右子树中找，如果其中一个子树包含
        p和q，那么其根节点就是最近公共祖先，它会被递归传给最外层的根节点；如果其中一个子树只包含p和q中的一个，
        虽然没有找到全部，但是根据 root == p || root == q 条件这个p或q会被返回给根节点，这样至少让根节点
        知道了p和q在哪一个子树上，然后再自底向上返回，直到遇到一种情况，p和q在根节点两侧

        */
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        // 2.如果都为空 说明没有这两个节点
        if (left == null && right == null) return null;
        // 3.如果left为空 说明左子树中没有p q
        if (left == null) return right;
        // 4.如果right为空 说明右子树中没有p q
        if (right == null) return left;
        // 1.如果left right都不为空 说明left right分布在root两侧 则root就是最近公共祖先
        return root;  // if (left != null && right != null) 
    }
}
~~~

### 对比：LC [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

-   思路：

    1.  若p的值小于root的值，q的值大于根的值，那么root就是最近公共祖先。

    2.  若p的值和q的值都小于root的值，那么代表最近祖先一定在root的左子树中

    3.  若p的值和q的值都大于root的值，那么代表最近祖先一定在root的右子树中

    2.  3情况发生的话，只需要继续递归即可，而 1则是递归出口。

~~~java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root.val < p.val && root.val < q.val)
            return lowestCommonAncestor(root.right, p, q);
        if(root.val > p.val && root.val > q.val)
            return lowestCommonAncestor(root.left, p, q);
        return root;
    }
}
~~~









## 二分查找

### [剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

-   思路：与主站 154 题不同的是，这题会有重复元素，意味着是非严格单调递增的。在严格单调递增的情况下，只需要找到一个mid使得nums[mid] > nums[r]即可确定最小值所在区间；但是在非严格单调递增的情况下，有可能遇到nums[mid] == nums[r]的情况，这种情况下mid点有两种落位可能，一是下图3的左半边水平线上，二是下图3右半边的水平线上；第一种可能是可以确定最小值是严格在mid点右边的区间的，第二种可能只能只能确定最小值点是在mid或mid之前的区间里，那么如何区分这两种情况呢？可以通过遍历[mid, r]的所有数，如果出现了个更小的数字，说明是第一种情况，反之则是第二种情况。

    <img src="alg-img/旋转数组2.png" width="350px">

~~~java
class Solution {
    public int minArray(int[] numbers) {
        int n = numbers.length;
        int l = 0, r = n - 1;
        while (l < r) {
            int mid = l + ((r - l) >> 1);
            if (check(numbers, mid)) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        return numbers[l];
    }
    // 判断[0, mid]是不是都不可能
    public boolean check(int[] numbers, int mid) {
        int n = numbers.length;
        if (numbers[mid] > numbers[n - 1]) return true;
        for (int i = mid; i < n; i++) {
            if (numbers[i] < numbers[mid]) return true;
        }
        return false;
    }
}
~~~



### [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

~~~java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        if (n == 0) return 0;
        int l = 0, r = n - 1;
        int idx1, idx2;
        // 相同情况取左边
        while (l < r) {
            int mid = l + ((r - l) >> 1);
            if (nums[mid] < target) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        idx1 = l;
        l = 0;
        r = n - 1;
        // 相同情况取右边
        while (l < r) {
            int mid = l + ((r - l + 1) >> 1);
            if (nums[mid] > target) {
                r = mid - 1;
            } else {
                l = mid;
            }
        }
        idx2 = l;
        // 如果idx1==idx2，可能只有一个目标值，可能是没找到
        if (idx1 == idx2) return nums[idx2] == target ? 1 : 0;
        return idx2 - idx1 + 1;
    }
}
~~~









## 位运算

### [剑指 Offer 15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

~~~java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int cnt = 0;
        for (int i = 0; i < 32; i++) {
            if ((n >>> i & 1)  == 1) cnt ++;
        }
        return cnt;
    }
}
~~~



### [剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

**方法一：位运算**

-   思路：对数组中所有元素做一次异或运算，出现次数为偶数的都抵消了，所以最后得到的值是两个只出现一次的元素的异或值。xor中位为1则说明两个数在该位上不同，那么只需要去最低位的1(lowbit)就可以将两个数字分为两波了。

~~~java
class Solution {
    public int[] singleNumbers(int[] nums) {
        int xor = 0;
        for (int num : nums) {
            xor ^= num;  // 1 ^ 6
        }
        int xor1 = 0;
        int xor2 = 0;
        // int lowbit = xor & (-xor);  
        int lowbit = (xor == Integer.MIN_VALUE ? xor : xor & (-xor));
        for (int num : nums) {
            if ((num & lowbit) == 0) xor1 ^= num;
            else xor2 ^= num;
        }
        return new int[]{xor1, xor2};
    }
}
~~~





## 分治

### [剑指 Offer 16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)

**方法一：分治**

-   思路：最直观的解法是将 x 重复乘 n 次，x*x*x...*x，那么时间复杂度为 O(N)。因为乘法是可交换的，所以可以将上述操作拆开成两半 (x*x..*x)* (x*x..*x)，两半的计算是一样的，因此只需要计算一次。而且对于新拆开的计算，又可以继续拆开。这就是**分治**思想，将原问题的规模拆成多个规模较小的子问题，最后子问题的解合并起来。本题中子问题是 x^n/2，在将子问题合并时将子问题的解乘于自身相乘即可。但如果 n 不为偶数，那么拆成两半还会剩下一个 x，在将子问题合并时还需要需要多乘于一个 x。

~~~java
class Solution {
    public double myPow(double x, int n) {
        if (x == 0) return 0;
        double ans = pow(x, Math.abs(n));
        if (n < 0) ans = 1 / ans;
        return ans;
    }
    public double pow(double x, int n) {
        if (n == 0) return 1.0;
        if (n == 1) return x;
        double res = pow(x, n / 2);
        res *= res;
        if (n % 2 != 0) res *= x;
        return res;
    }
}

class Solution {
    public double myPow(double x, int n) {
        if (x == 0) return 0;
        long nn = n;  // ********
        double ans = pow(x, Math.abs(nn));
        if (n < 0) ans = 1 / ans;
        return ans;
    }
    public double pow(double x, long n) {
        if (n == 0) return 1.0;
        if (n == 1) return x;
        double res = pow(x, n >> 1);
        res *= res;
        if ((n & 1) == 1) res *= x;
        return res;
    }
}
~~~

>   Java 代码中 int32 变量 n \in [-2147483648, 2147483647]n∈[−2147483648,2147483647] ，因此当 n = -2147483648n=−2147483648 时执行 n = -nn=−n 会因越界而赋值出错。解决方法是先将 nn 存入 long 变量 bb ，后面用 bb 操作即可。
>



## 搜索

### [剑指 Offer 12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

**方法一：DFS+回溯+剪枝**

-   思路：首先在矩阵中找到和s第一个字母一样的元素，以此为起点dfs，每次在dfs的入口处做判断，要求索引合法、元素值相同、未访问过，不满足任何一条则递归终止，达到了剪枝的效果；若遍历到s的最后一个字符了，也满足了递归入口判断条件，则视为找到了，此时将全局flag更新为true，意味着找到了，后面的dfs就不会执行了，这也达到了剪枝的效果。值得注意的是，有可能沿某条路径走了很远后发现这条路径无效，但是路径上的元素有可能是有效路径上的元素，因此退出递归时一定要记得回溯，即将其重新设置为未访问。

~~~java
class Solution {
    private int[][] directions = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
    private boolean flag = false;
    public boolean exist(char[][] board, String word) {
        for(int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (flag) {
                    return true;
                } else {
                    if (board[i][j] == word.charAt(0)) {
                        int[][] visited = new int[board.length][board[0].length];
                        dfs(board, i, j, word, 0, visited);
                    }
                }
            }
        }
        return flag;
    }
    public void dfs(char[][] board, int i, int j, String word, int k, int[][] visited) {
        if (i >= board.length || i < 0 || j >= board[0].length || j < 0 || word.charAt(k) != board[i][j] || visited[i][j] == 1) {
            return;
        }
        visited[i][j] = 1;
        if (k == word.length() - 1) {
            flag = true;
            return;
        }
        for (int[] dir : directions) {
            int ii = i + dir[0], jj = j + dir[1];
            // 找到一组答案就别再dfs了，不然会tle
            if (!flag)  dfs(board, ii, jj, word, k + 1, visited);
        }
        visited[i][j] = 0;  // 回溯！
    }
}
~~~





**方式二：DFS+剪枝**

~~~java
class Solution {
    public boolean exist(char[][] board, String word) {
        char[] words = word.toCharArray();
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board[0].length; j++) {
                if(dfs(board, words, i, j, 0)) return true;
            }
        }
        return false;
    }
    boolean dfs(char[][] board, char[] word, int i, int j, int k) {
        if(i >= board.length || i < 0 || j >= board[0].length || j < 0 || board[i][j] != word[k]) return false;
        if(k == word.length - 1) return true;
        board[i][j] = '\0';
        boolean res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || 
                      dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1);
        board[i][j] = word[k];
        return res;
    }
}
~~~



### [剑指 Offer 13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

~~~java
class Solution {
    public int[][] visited;
    public int[][] dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}};
    public int m, n;
    public int movingCount(int m, int n, int k) {
        this.m = m;
        this.n = n;
        visited = new int[m][n];
        return dfs(0, 0, k);
    }
    public int dfs(int i, int j, int k) {
        if (i < 0 || i > m - 1 || j < 0 || j > n - 1 || visited[i][j] == 1 || calculate(i, j) > k ) {
            return 0;
        }
        visited[i][j] = 1;
        int temp = 0;
        for (int[] dir : dirs) {
            temp += dfs(i + dir[0], j + dir[1], k);
        }
        return temp + 1;
    }
    public int calculate(int i, int j) {
        int res = 0;
        while(i != 0) {
            res += (i % 10);
            i /= 10;
        }
        while(j != 0) {
            res += (j % 10);
            j /= 10;
        }
        return res;
    }
}
~~~



### [剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)

**方法一：DFS+Set去重**

~~~java
class Solution {
    public String s;
    public Set<String> res;
    int[] visited;
    public String[] permutation(String s) {
        this.s = s;
        res = new HashSet<>();
        visited = new int[s.length()];
        for (int i = 0; i < s.length(); i++) {
            StringBuffer sb = new StringBuffer();
            dfs(i, sb);
        }
        return res.toArray(new String[res.size()]);
    }
    public void dfs(int k, StringBuffer sb) {
        if (visited[k] == 1) return;
        visited[k] = 1;
        if (!res.contains(sb.toString()))
            res.add(sb.toString());
        if (sb.length() == s.length()) {
            res.add(sb.toString());
        }
        for (int i = 0; i < s.length(); i++) {
            dfs(i, sb);
        }
        visited[k] = 0;
        sb.deleteCharAt(sb.length() - 1);
    }
}
~~~











## 排序





## 动态规划

### [剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

**方法一：DP-数组存放历史状态**

-   思路：数组存放上一状态

~~~java
class Solution {
    public int fib(int n) {
        if (n == 0 || n == 1) return n;
        int[] res = new int[n + 1];
        res[0] = 0;
        res[1] = 1;
        for (int i = 2; i <= n; i++) {
            // 注意：答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
            // 从一开始就要取模，最后再取模就会出错了
            res[i] = (res[i - 1] + res[i - 2])  % 1000000007;
        }
        return res[n];
    }
}
~~~

**方法二：DP-交换秩**

-   思路：并不是所有的历史状态都要，因此只需要p和q记录上两个历史状态的信息，然后用临时变量cur记录当前状态信息即可。当前状态信息读取结束后，在跳往下一状态之前先p指向q，q指向cur（等于p和q都往后移了一位）。

~~~java
class Solution {
    public int fib(int n) {
        if (n < 2) return n;
        int p = 0, q = 1;
        int f = 0;
        for (int i = 2; i <= n; i++) {
            f = (p + q) % 1000000007;
            p = q;
            q = f;
        }
        return q;
    }
}
~~~

### [剑指 Offer 10- II. 青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

-   思路：青蛙从上一时刻跳到第n级台阶有2种可能性：1.从第n-1级台阶跳一格上来，2.从第n-2级台阶跳2格上来，容易推出递推公式为：`dp[i] = dp[i-2]+d[i-1]`，其中dp[1]显然为1，dp[2]显然为2，dp[0]是没有什么意义的，但是为了递推的一致性，我们可以将dp[0]设置为1，这样dp[2]也可能由d[0]和dp[1]得到。

~~~java
class Solution {
    public int numWays(int n) {
        final int MOD = 1000000007;
        if (n == 0) return 1;
        if (n <= 2) return n;
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        // dp[2] = 2;
        for (int i = 2; i <= n; i++) {
            dp[i] = (dp[i - 2] + dp[i - 1]) % MOD;
        }
        return dp[n];
    }
}
~~~

>**空间复杂度优化：** （斐波那契同理）
>若新建长度为 n 的 dp 列表，则空间复杂度为 O(N) 。
>**由于 dp列表第 i 项只与第 i-1 和第 i-2 项有关** ，因此只需要初始化三个整形变量 sum, a, b ，利用辅助变量 sum 使 a, b 两数字交替前进即可 （具体实现见代码）。
>因为节省了dp列表空间，因此空间复杂度降至 O(1)。

### [剑指 Offer 71. 跳台阶扩展问题](https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github)

**方法一：普通动态规划**

-   思路：调到第n级台阶有这么几种可能性：从n-1级跳1级而来、从n-2级跳2级而来、从n-3级跳3级而来.....从0级跳n级而来，因此可能递推公式为：`dp[n] = dp[0] + dp[1] + ... + dp[n-1]`。

~~~java
public class Solution {
    public int jumpFloorII(int target) {
        if (target == 0) return 1;
        if (target == 1) return 1;
        int[] dp = new int[target + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= target; i++)
            for (int j = 0; j < i; j++) dp[i] += dp[j];
        return dp[target];
    }
}
~~~

**方法二：优化-记忆化搜索**

-   思路：`dp[n] = dp[0] + dp[1] + ... + dp[n-1]`，`dp[n-1] = dp[0] + dp[1] + ... + dp[n-2]`，所以`dp[n] = 2 * dp[n-1] `。

~~~
public class Solution {
    public int jumpFloorII(int target) {
        if (target == 0) return 1;
        if (target == 1) return 1;
        int[] dp = new int[target + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= target; i++) {
            dp[i] = 2 * dp[i - 1];
        }
        return dp[target];
    }
}
~~~





### [剑指 Offer 70. 矩形覆盖](https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github)

-   思路：当(2,1)的时候只有一种可能：竖着的；当(2,2)的时候有两种可能：两个竖着的（是在(2,1)的后面加了个竖着的）、两个横着的（可以看做是在(0，0)的后面加了两个横着的）；当(2,3)的时候有三种可能：在(2,2)的后面加一个竖着的，其中(2,2)有两种达到的方法，所以该情况也有两种达到的方法；在(2,1)的的后面加两个横着的，其中(2,1)有一种达到的方法，所以该情况也有一种达到的方法。综上所述，(2,n)可以由两种情况发展而来：在(2,n-1)的后面追加一个竖着的、在(2,n-2)的后面加两个横着的，所以递推公式为`dp[n] = dp[n-1]+dp[n-2]`。

<img src="alg-img/矩形覆盖.png" width="400px">

~~~java
public class Solution {
    public int rectCover(int target) {
        if (target == 0) return 0;
        if (target == 1) return 1;
        int[] dp = new int[target + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= target; i++) {
            dp[i] = dp[i - 2] + dp[i - 1];
        }
        return dp[target];
    }
}
~~~

>   优化思路与前两题一样。

### [剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

**~~方法一：暴力前缀和（超时）~~**

~~~java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int[] preSum = new int[n + 1];
        int ans = Integer.MIN_VALUE;
        preSum[0] = 0;
        for (int i = 1; i < n + 1; i++) {
            preSum[i] = preSum[i - 1] + nums[i - 1];
        }
        // 0 -2 -1 -4 
        for (int i = 0; i < n + 1; i++) {
            for (int j = i + 1; j < n + 1; j++) {
                ans = Math.max(ans, preSum[j] - preSum[i]);
            }
        }
        return ans;
    }
}
~~~



**方法二：动态规划**

-   思路：dp[i]表示以nums[i]结尾的连续子数组的最大和，那么dp[i]的答案就会有两种情况：1.dp[i-1] >= 0，说明以前一个元素结尾的最大和连续子数组可以对nums[i]作出正贡献，那么dp[i] = dp[i - 1] + nums[i]；2.dp[i-1] < 0，说明以前一个元素结尾的最大和连续子数组会对nums[i]作出负贡献，加上他们还不如不加，那么索性不要他们了，dp[i] = nums[i]。这样一趟一下就可以知道以每一个元素结尾的最大和的连续子数组的和是多少，并在遍历的过程中实时更新ans为最大的连续子数组和即可。

~~~java
class Solution {
    public int maxSubArray(int[] nums) {
        if (nums.length == 1) return nums[0];
        // dp[i]表示以i结尾的数组中连续子数组的最大和
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int ans = dp[0];
        for (int i = 1; i < nums.length; i++) {
            dp[i] = dp[i - 1] >= 0 ? dp[i - 1] + nums[i] : nums[i];
            ans = Math.max(ans, dp[i]);
        }
        return ans;
    }
}
~~~



### [剑指 Offer 47. 礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)

**方法一：动态规划**

-   思路：`dp[i][j]`可以由`dp[i-1][j]`和``dp[i][j-1]``跳来，也就是从上面或者左边跳过来，因此只需要比较他们两个的已累积获得的价值哪个更大，然后加上当前的价值即可，当前，前提是上面的或左边的要存在，所以要先判断索引的合法性。

    ​			易得递推公式为：`dp[i][j] = max(i - 1 >= 0 ? dp[i-1][j] : 0, j - 1 >= 0 ? dp[i][j-1] : 0) + grid[i][j]`

~~~java
class Solution {
    public int maxValue(int[][] grid) {
        if (grid.length == 1 && grid[0].length == 1) return grid[0][0];
        int m = grid.length, n = grid[0].length;
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int up = i - 1 >= 0 ? dp[i - 1][j] : 0;
                int left = j - 1 >= 0 ? dp[i][j - 1] : 0;
                dp[i][j] = Math.max(up, left) + grid[i][j];
            }
        }
        return dp[m - 1][n - 1];
    }
}
~~~



### [剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

**方法一：双指针-滑动窗口**

-   思路：用l, r两个指针维护一个窗口，窗口内的元素都不重复，每个有效窗口形成后计算窗口长度并更新答案ans，然后r往后移一位，若与窗口内的元素重复了，则将l指针一直往后移，直到形成一个新的有效窗口使得窗口内元素不重复；循环直至r走到最后一位。

~~~java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        if (n <= 1) return n;
        Map<Character, Integer> map = new HashMap<>();
        int ans = 0;
        int l = 0, r = 0;
        while (r < n) {
            char c = s.charAt(r);
            map.put(c, map.getOrDefault(c, 0) + 1);
            if (map.get(c) == 1) {
                ans = Math.max(ans, r - l + 1);
                r ++;
            } else {
                while (map.get(c) > 1) { // 1
                    char tmp = s.charAt(l);
                    map.put(tmp, map.get(tmp) - 1);
                    l ++;
                }
                ans = Math.max(ans, r - l + 1); 
                r ++;
            }
        }
        return ans;
    }
}
~~~

**方法二：动态规划**

-   思路：用哈希表记录每个字符最后出现的字符，dp[i]记录以s[i]结尾的最长不重复子串的长度。要计算dp[i]首先看前面有没有出现过相同的元素，即哈希表中有没有相同的键，如果没有则当前最大长度等于上一状态的最大长度加1即可；如果前面出现过，则比较上一状态的长度和s[i-1]到上一个重复元素的长度（通俗来说也就是以s[i-1]为右端点，比较左端点谁大谁小），若dp[i - 1] < i - preCurIdx，说明重复元素在更左边，在区间外，那么当前最大长度等于上一状态的最大长度加1；反之说明重复元素在区间内，那么当前最大长度等于当前元素到preCur后一个元素的长度。

~~~java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        if (n <= 1) return n;
        // 用{a:i}记录元素a最后一次出现的位置，也就是最右边的位置
        Map<Character, Integer> map = new HashMap<>();
        int ans = 0;
        // int curLen = 0;
        // dp[i]表示以s[i]结尾的最长不重复子串的长度
        int[] dp = new int[n];
        map.put(s.charAt(0), 0);
        dp[0] = 1;
        for (int i = 1; i < n; i++) {
            char cur = s.charAt(i);
            if (!map.containsKey(cur)) {
                dp[i] = dp[i - 1] + 1;
            } else {
                int preCurIdx = map.get(cur);
                // s[i-1]到preCur的长度：i - preCurIdx + 1 - 1 -> i - preCurIdx
                // 以s[i-1]结尾的最长重复子串长度：dp[i-1]
                // preCur在以s[i-1]结尾的最长重复子串内部,那么以s[i]结尾的最长重复子串为preCur后一个到cur
                if (dp[i - 1] >= i - preCurIdx) {
                    dp[i] = i - preCurIdx;
                } else {// preCur在以s[i-1]结尾的最长重复子串外部,不影响
                    dp[i] = dp[i - 1] + 1;
                }
            }
            ans = Math.max(ans, dp[i]);
            map.put(cur, i);
        }
        return ans;
    }
}
~~~



### [剑指 Offer 49. 丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)

**方法一：三指针+动态规划**

-   思路：后面的丑数一定由前面的丑数乘以2，或者乘以3，或者乘以5得来。例如，8,9,10,12一定是1, 2, 3, 4, 5, 6乘以2,3,5三个质数中的某一个得到。这样的话我们的解题思路就是：从第一个丑数开始，一个个数丑数，并确保数出来的丑数是递增的，直到数到第n个丑数，得到答案。那么问题就是如何递增地数丑数？观察上面的例子，假如我们用1, 2, 3, 4, 5, 6去形成后面的丑数，我们可以将1, 2, 3, 4, 5, 6分别乘以2, 3, 5，这样得到一共6*3=18个新丑数。也就是说1, 2, 3, 4, 5, 6中的每一个丑数都有一次机会与2相乘，一次机会与3相乘，一次机会与5相乘（一共有18次机会形成18个新丑数），来得到更大的一个丑数。

~~~java
class Solution {
    public int nthUglyNumber(int n) {
        // 1   2(2*1)   3(3*1)  4(2*2)   5(5*1)   6(2*3)   8(2*4)   9(3*3)    10(2*5)    12(3*4)
        int[] dp = new int[n];
        dp[0] = 1;
        int a = 0, b = 0, c = 0;
        for (int i = 1; i < n; i++) {
            dp[i] = Math.min(Math.min(dp[a] * 2, dp[b] * 3), dp[c] * 5);
            if (dp[i] == dp[a] * 2) a++;
            if (dp[i] == dp[b] * 3) b++;
            if (dp[i] == dp[c] * 5) c++;
            // 如果某个丑数是由2 3 5当中的两个相乘得到的，那么那两个指针都要往后移动一位，因为如果只移动较小的一个话，较大的那一个下次会再生成一次相同的丑数，就重复了。
        }
        return dp[n - 1];
    }
}
~~~



### [剑指 Offer 60. n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/)

**方法一：动态规划**

-   思路：易知只有一个骰子的情况下，只能掷出6种点数，且是等可能的；在两个骰子的情况下，掷出的点数可以看作是在一个骰子的各种可能的点数上分别加上1~6，这样就构成了两个骰子的所有可能点数.....推得在有n个骰子的情况下，可能的点数是由前n-1可能掷出的点数和最后一个骰子掷出的点数组合决定的。

    设`dp[n+1][6*n+1]`，`dp[i][j]`表示i个骰子掷出j点的可能性，因此想要求i个骰子可能掷出的所有点数及其可能性，只需要将i-1个骰子可能掷出的各种点数再分别加上1~6并累加上对应的点数，这样即可得到i个骰子可能掷出的所有点数和概率：
    
    ~~~
    伪代码：
    for k in [1,6]:
      dp[i][j + k] = dp[i - 1][j] * 1/6.0 
                   用i-1个掷出j点的概率 * 当前骰子掷出k点的概率
    ~~~

~~~java
class Solution {
    public double[] dicesProbability(int n) {
        // n ~ 6n  --> 5n + 1 种数字可能性
        // dp[i][j]表示用i个筛子掷出j点的可能性
        double[][] dp = new double[n+1][6*n+1];
        // 1个筛子只能生成6中结果，而且是等可能的
        for (int j = 1; j <= 6; j++) {
            dp[1][j] = 1 / 6.0;
        }
        // 然后遍历处理2个，3个.....n个筛子的情况
        for (int i = 2; i <= n; i++) {
            // 新加上一次骰子(共有nn个骰子)可能产生的点数由nn-1个骰子产生的点数再分别加上1~6而产生
            // 要求第i个骰子的可能点数，就看i-1个可能的点数和1~6组合
            // i - 1个可能产生的点数范围是:i-1 ~ 6(i-1)
            for (int j = i - 1; j <= 6 * (i - 1); j++) {
                // 当前骰子可掷出1~6点
                for (int k = 1; k <= 6; k++) {
                    // 前i-1个共掷出j点 当前掷出k点 共j+k点
                    dp[i][j+k] += dp[i-1][j] / 6.0;
                }
            }
        }
        double[] res = new double[5 * n + 1];
        // n ~ 6n  -> 0 ~ 5n
        for (int i = 0; i < 5 * n + 1; i++) {
            res[i] = dp[n][i + n];
        }
        return res;
    }
}
~~~



### [剑指 Offer 66. 构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)

**方法一：动态规划**

-   思路：		

    <img src="alg-img/构建乘积数组.png" width="600px">

~~~java
class Solution {
    public int[] constructArr(int[] a) {
        if (a.length == 0) return new int[0];
        int n = a.length;
        int[] left = new int[n];
        int[] right = new int [n];
        int[] b = new int[n];
        left[0] = 1;
        right[n - 1] = 1;
        for (int i = 1; i < n; i++) {
            left[i]  = left[i - 1] * a[i - 1];
        }
        for (int i = n - 2; i >= 0; i--) {
            right[i] = right[i + 1] * a[i + 1];
        }
        for (int i = 0; i < n; i++) {
            b[i] = left[i] * right[i];
        }
        return b;
    }
}
~~~



























## 贪心思想



## 数学

### [剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)

**方法一：摩尔投票法**

~~~java
class Solution {
    public int majorityElement(int[] nums) {
        int maxCnt = 0;
        int maxNum = nums[0];
        for (int i = 0; i < nums.length; i++) {
            if (maxCnt == 0) {
                maxNum = nums[i];
                maxCnt++;
            } else {
                if (nums[i] == maxNum) maxCnt ++;
                else maxCnt --;
            }
        }
        return maxNum;
    }
}
~~~

### [剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

**方法一：循环遍历**

~~~java
class Solution {
    public int lastRemaining(int n, int m) {
        // 0 1 2 ... n-1 0 1 2 ... n-1
        int cnt = 0;
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < n; i++) list.add(i);
        int k = 0;
        for (int i = 0; i < n - 1; i++) {
            k = (k + m - 1) % list.size();
            list.remove(k);
        }
        return list.get(0);
    }
}
~~~

**方法二：动态规划+约瑟夫环解法**

-   思路：

    ~~~
    n串：               0,        1,       2,    .....              n-1
    * 删除的是n串中的(0 + m - 1) % n == (m - 1) % n, 因此下一个串的第一个将是n串中的m % n
    用n串的下标表示n-1串：m%n      (m+1)%n  (m+2)%n .... n-1 0, 1 ... (m-2)%n
    又可以写做：        (m+0)%n  (m+1)%n           ....             (m+n-2)%n
    n-1串自己的下标：     0         1              ....               n-2
    综上有n-1串和n串的坐标对应关系：dp[n] = (m + dp[n-1]) % n
    因此易知1串的结果就是坐标为0的元素，因此可用上述递推公式反推到该元素在n串中的坐标
    ~~~

~~~java
class Solution {
    public int lastRemaining(int n, int m) { 
         int[] dp = new int[n + 1];
         dp[1] = 0;
         for (int i = 2; i <= n; i++) {
             dp[i] = (m + dp[i - 1]) % i;
         }
         return dp[n];
    }
}
~~~

### [剑指 Offer 43. 1～n 整数中 1 出现的次数](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/)

**方法一：遍历统计-超内存**

**方法二：按位统计**

-   思路：

    <img src="alg-img/1～n整数中1出现的次数.png" width="500px">

    按位统计，假设该位为1的情况下有多少组合的可能性。将数字分为三个部分：当前遍历的`digit`位上的数字`cur`、已经被统计过的低位上的数字`low`、还未被统计过的高位上的数字`high`。`digit`位固定设为1的情况下的所有组合的可能性由两部分组成：

    

    1.  先不看`digit`位的值，列举高位和低位的所有组合可能性，使得重新组合后的值总是小于`n`，因此高位上的数字的调整范围为`00...0 ~ high-1`，低位上的数字的调整范围为`00...0 ~ digit-1`，这种情况下的可能数有`high * digit`；

    2.  将`digit`位设为1，然后看`cur`的值：

    -   若`cur`本来为0，那么在`digit`位设为1的情况下高位最多只能到`high - 1`，没有其他组合的可能了。

    -   若`cur`本来为1，那么可以将高位升为`high`，然后低位的数字的调整范围为`00..0 ~ low`，这种情况下的可能数有`low + 1`种。

    -   若`cur`本来大于1，那么可以将高位升为`high`，此时digit设为1的情况下低位可能放心的设置可能组合(因为`digit`设为1，小于`cur`，低位怎么弄都不会越界)，因此低位的数字的调整范围为`00..0 ~digit-1`，这种情况下的可能数有`digit` 种。

    综上，设`digit`位设为1，其他所有位的所有组成可能数为`f`：

    ~~~
       = high * digit           (cur == 0)
    f  = high * digit + low + 1 (cur == 1)
       = high * digit + digit   (cur > 1)
    ~~~

~~~java
class Solution {
    public int countDigitOne(int n) {
        int res = 0;
        int digit = 1;
        int high = n / 10, cur = n % 10, low = 0;
        while (digit <= n) {
            if (cur == 0) {
                res += (high * digit);
            } else if (cur == 1) {
                res += (high * digit + low + 1);
            } else {
                res += (high * digit + digit);
            }
            low += cur * digit;
            cur = high % 10;
            high /= 10;
            digit *= 10;
        }
        return res;
    }
}
~~~



# 参考题库

## 递归

### LC-[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

**方法一：DP**

~~~java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 2] + dp[i - 1];
        }
        return dp[n];
    }
}
~~~

**方法二：递归(超时)**

~~~java
class Solution { 
    public int climbStairs(int n) {
        // 递归终止条件
        if(n == 1) return 1;
        if(n == 2) return 2;
        // 当前递归层的逻辑处理 加法
        // 进入下一层递归 climbStairs(n - 1) 和 climbStairs(n - 2)
        return climbStairs(n - 1) + climbStairs(n - 2);
    }
}
/**
作者：caddy-k
链接：https://leetcode-cn.com/problems/climbing-stairs/solution/yuan-lai-hui-pa-lou-ti-de-zheng-que-zi-s-pjez/
*/
~~~

**方法三：递归优化**

-   思路：思路和方法一的DP是相同的：f(n) = f(n - 2) + f(n - 1)，只是用了递归实现。

~~~java
class Solution {
    HashMap<Integer,Integer> map = new HashMap();
    public int climbStairs(int n) {
        if(n == 1) return 1;
        if(n == 2) return 2;
 
        if(map.containsKey(n))
            return map.get(n);
 
        int sum = climbStairs(n - 1) + climbStairs(n - 2);
        map.put(n,sum);
 
        return sum;
    }
}
/**
作者：caddy-k
链接：https://leetcode-cn.com/problems/climbing-stairs/solution/yuan-lai-hui-pa-lou-ti-de-zheng-que-zi-s-pjez/
*/
~~~



### LC-[112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

~~~java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) return false;
        if (root.left == null && root.right == null && targetSum == root.val) {
            return true;
        }
        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);
    }
}
~~~



### LC-[509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

**方法一：DP**

~~~java
class Solution {
    public int fib(int n) {
        if (n == 0) return 0;
        if (n == 1) return 1;
        int p = 0, q = 1;
        for (int i = 2; i <= n; i++) {
            int temp = p + q;
            p = q;
            q = temp;
        }
        return q;
    }
}
~~~

**方法二：递归 + Map优化**

~~~java
class Solution {
    public Map<Integer, Integer> map = new HashMap<>();
    public int fib(int n) {
        if (n == 0) return 0;
        if (n == 1) return 1;
        if (map.containsKey(n)) return map.get(n);
        int sum = fib(n - 1) + fib(n - 2);
        map.put(n, sum);
        return sum;
    }
}
~~~



## 分治

### LC-[23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

**方法一：K路归并**

~~~java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists.length == 0) return null;
        ArrayList<ListNode> list = new ArrayList<>();
        for(ListNode l : lists) list.add(l);
        ListNode head = new ListNode(-1);
        ListNode p = head;
        while (list.size() > 0) {
            int pMin = 0;
            for (int i = 0; i < list.size(); i++) {
                if (list.get(i) == null) {
                    list.remove(i);
                    i--;
                    continue;
                }
                if (list.get(i).val < list.get(pMin).val) pMin = i;
            }
            if (!list.isEmpty()) {
                p.next = list.get(pMin);
                p = p.next;
                list.set(pMin, list.get(pMin).next);
            }
        }
        return head.next;
    }
}
~~~

**方法二：K路归并+堆优化**

-   思路：维护一个以节点值为条件的最小堆，堆中放着所有非空链表的头节点，每次取出堆中第一个元素加入新链表，取出后若该节点的下一个节点非空，将其加入堆。

~~~java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        Queue<ListNode> heap = new PriorityQueue<>((o1, o2) -> (o1.val - o2.val));
        for (ListNode node : lists) {
            if (node != null) {
                heap.offer(node);
                node = node.next;
            }
        }
        ListNode head = new ListNode(0);
        ListNode p = head;
        while (!heap.isEmpty()) {
            p.next = heap.poll();
            p = p.next;
            if (p.next != null) {
                heap.offer(p.next);
            }
        }
        return head.next;
    }
}
~~~



**方法三：两两分治（最优）**

~~~java
class Solution {
   public ListNode mergeKLists(ListNode[] lists) {
        if (lists.length == 0) return null;
        return merge(lists, 0, lists.length - 1);
    }
    public ListNode merge(ListNode[] lists, int left, int right) {
        if (left == right) return lists[left];
        int mid = left + (right - left) / 2;
        ListNode l1 = merge(lists, left, mid);
        ListNode l2 = merge(lists, mid + 1, right);
        return mergeTwoLists(l1, l2);
    }
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode p1 = l1, p2 = l2;
        ListNode head = new ListNode(-1);
        ListNode p = head;
        while (p1 != null && p2 != null) {
            if (p1.val <= p2.val) {
                p.next = p1; p = p.next; p1 = p1.next;
            }
            else {
                p.next = p2; p = p.next; p2 = p2.next;
            }
        }
        while (p1 != null) {
            p.next = p1; p = p.next; p1 = p1.next;
        }
        while (p2 != null) {
            p.next = p2; p = p.next; p2 = p2.next;
        }
        return head.next;
    }
}
~~~





### [LC-169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

**方法一：快排划分**

-   思路：有序序列中 n / 2 位置上的元素一定是众数。

~~~java
class Solution {
    public int target;
    public int majorityElement(int[] nums) {
        target = nums.length / 2;
        quicksort(nums, 0, nums.length - 1);
        return nums[target];
    }
    public void quicksort(int[] nums, int l, int r) {
        if (l >= r) return;
        int idx = patition(nums, l, r);
        if (idx == target) return;
        quicksort(nums, l, idx - 1);
        quicksort(nums, idx + 1, r);
    }
    public int patition(int[] nums, int l, int r) {
        int pivotIndex = l;
        int pivot = nums[pivotIndex];
        while (l < r) {
            while (l < r && nums[r] >= pivot) r--;
            while (l < r && nums[l] <= pivot) l++;
            if (l < r) swap(nums, l, r);
        }
        swap(nums, pivotIndex, l);
        return l;
    }
    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
~~~

**方法二：摩尔投票法**

-   思路：

~~~java
class Solution {
    public int majorityElement(int[] nums) {
        int cnt = 0;
        int candidate = 0;
        for (int i = 0; i < nums.length; i++) {
            // 当前元素是第一个元素 或 前面的候选candidate都被抵消了 现在尝试用当前元素作candidate
            if (cnt == 0) {
                candidate = nums[i];
                cnt ++;
            } else {
                if (candidate == nums[i]) cnt++;
                else cnt --;
            }
        }
        return candidate;
    }
}
~~~

### (TODO)对比 LC-[229. 求众数 II](https://leetcode-cn.com/problems/majority-element-ii/)

~~~java

~~~



### LC-[240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

~~~java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length, n = matrix[0].length;
        int i = 0, j = n - 1;
        while (i < m && j >= 0 && matrix[i][j] != target) {
            if (matrix[i][j] > target) {
                j--;
            } else {
                i++;
            }
        }
        // 结束循环有两种可能性：找到了target值 或 下标越界
        // 还停留在矩阵内 说明是因为碰到target导致停下来的
        return i < m && j >= 0;
    }
}
~~~





## 单调栈

### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

**方法一：单调栈-逆序**

-   思路：栈里维护一个从后到前的温度严格单调递减序列。

    >   为什么要严格单调？防止比较的下一个和今天相同的温度，eg:33(1) 33(2) 35  若33(2)不出栈的话，33(1)就会和33(2)计算了

~~~java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        Stack<Integer> stack = new Stack<>();
        int[] res = new int[n];
        stack.push(n - 1);
        for (int i = n - 1; i >= 0; i--) {
            // 将小于等于今天温度的全都出栈
            while (!stack.isEmpty() && temperatures[i] >= temperatures[stack.peek()]) {
                stack.pop();
            }
            // 之前的全都被出栈了 说明今天的温度是目前最高的
            if (stack.isEmpty()) {
                res[i] = 0;
            } else {
                res[i] = stack.peek() - i;
            }
            stack.push(i);
        }
        return res;
    }
}
~~~



### [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)

**方法一：单调栈-逆序**

~~~java
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        Stack<Integer> stack = new Stack<>();
        int n = nums.length;
        int[] res = new int[n];
        // 第一遍遍历主要是为了求在循环数组中最后一个元素后面的单调序列情况，以求出最后一个数的后一个最大的数
        for (int i = n - 1; i >= 0; i--) {
            while (!stack.isEmpty() && nums[i] >= nums[stack.peek()]) {
                stack.pop();
            }
            stack.push(i);
        } 
        // 这里就和下一个更高的温度那里几乎一样了
        for (int i = n - 1; i >= 0; i--) {
            while (!stack.isEmpty() && nums[i] >= nums[stack.peek()]) {
                stack.pop();
            }
            if (stack.isEmpty()) {
                res[i] = -1;
            } else {
                res[i] = nums[stack.peek()];
            }
            stack.push(i);
        }
        return res;
    }
}
~~~

### [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

**方法一：双单调栈**

-   思路：

~~~java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        // 使用Deque取代Stack
        Deque<Integer> stackL = new ArrayDeque<Integer>();
        Deque<Integer> stackR = new ArrayDeque<Integer>();
        // Stack<Integer> stackL= new Stack<>();
        // Stack<Integer> stackR = new Stack<>();
        int[] minR = new int[n];
        int[] minL = new int[n];
        int ans = 0;
        // 找右边第一个小于当前高度的 严格递增  
        for (int j = n - 1; j >= 0; j--) {
            while (!stackR.isEmpty() && heights[j] <= heights[stackR.peek()]) {
                stackR.pop();
            }
            minR[j] = stackR.isEmpty() ? n : stackR.peek();  // minR[j]决定了以heights[j]为高的话，右边界是哪里
            stackR.push(j);
        } 
        // 找左边第一个小于当前高度的 严格递增
        for (int i = 0; i < n; i++) {
            while (!stackL.isEmpty() && heights[i] <= heights[stackL.peek()]) {
                stackL.pop();
            }
            minL[i] = stackL.isEmpty() ? -1 : stackL.peek();  // minL[j]决定了以heights[i]为高的话，左边界是哪里
            stackL.push(i);
        } 
        for (int k = 0; k < n; k++) {
            ans = Math.max(ans, heights[k] * (minR[k] - minL[k] - 1));
        }
        return ans;
    }
}
~~~

>   java.util.Stack 类 Java 官方已经不在建议使用了。现在官方推荐使用 java.util.Deque。类似下面的用法：`Deque<Integer> stack = new ArrayDeque<Integer>();`
>
>   `ArrayDeque`是`Deque`接口的一个实现，使用了可变数组，所以没有容量上的限制。同时，`ArrayDeque`是线程不安全的，在没有外部同步的情况下，不能再多线程环境下使用。`ArrayDeque`是`Deque`的实现类，可以作为栈来使用，效率高于`Stack`；也可以作为队列来使用，效率高于`LinkedList`。需要注意的是，`ArrayDeque`不支持`null`值。

### [85. 矩阵中最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)

**方法一：逐行转化+双单调栈**

-   思路：84题是在高确定的情况下求最大矩形，这里虽然是在二维矩阵中，但是可以逐行转化成84题的情况，即底和高是确定的，求最大矩形。具体的，逐行遍历，若(i, j)是1，则将高度加1，若是0，这上面的元素不管是0还是1，这一列都没用的，直接将该列高度置零，然后将更新后的heights传给84题的函数即可求出以该行为底的情况下矩阵中的最大矩形面积。

    <img src="alg-img/LC85.png" width="400px">

~~~java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        int[] heights = new int[n];
        int res = 0;
        for (int i = 0; i < m; i++) {
            // 更新以第i行为底的情况下每一列的高度
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '1') heights[j] += 1;
                else heights[j] = 0;
            }
            res = Math.max(res, largestRectangleArea(heights));
        }
        return res;
    }
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        // 使用Deque取代Stack
        Deque<Integer> stackL = new ArrayDeque<Integer>();
        Deque<Integer> stackR = new ArrayDeque<Integer>();
        int[] minR = new int[n];
        int[] minL = new int[n];
        int ans = 0;
        // 找右边第一个小于当前高度的 严格递增
        for (int j = n - 1; j >= 0; j--) {
            while (!stackR.isEmpty() && heights[j] <= heights[stackR.peek()]) {
                stackR.pop();
            }
            minR[j] = stackR.isEmpty() ? n : stackR.peek();
            stackR.push(j);
        } 
        // 找左边第一个小于当前高度的 严格递增
        for (int i = 0; i < n; i++) {
            while (!stackL.isEmpty() && heights[i] <= heights[stackL.peek()]) {
                stackL.pop();
            }
            minL[i] = stackL.isEmpty() ? -1 : stackL.peek();
            stackL.push(i);
        } 
        for (int k = 0; k < n; k++) {
            ans = Math.max(ans, heights[k] * (minR[k] - minL[k] - 1));
        }
        return ans;
    }
}
~~~







## 并查集

### LC-[547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)

**方法一：DFS**

~~~java
class Solution {
    public int[] visited;
    public int n;
    public int findCircleNum(int[][] isConnected) {
        n = isConnected.length;
        if (n == 1) return 1;
        int ans = 0;
        visited = new int[n];
        for (int i = 0; i < n; i++) {
            if (visited[i] == 0) {
                ans ++;
                dfs(i, isConnected);
            }
        }
        return ans;
    }
    public void dfs(int c, int[][] isConnected) {
        if (visited[c] == 1) return;
        visited[c] = 1;
        for (int i = 0; i < n; i++) {
            if (isConnected[c][i] == 1) {
                dfs(i, isConnected);
            }
        }
    }
}
~~~

**方法二：并查集**

~~~java
class Solution {
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        int[] father = new int[n];
        int ans = 0;
        for (int i = 0; i < n; i++) {
            father[i] = i;  // 初始化 自己指向自己
        }
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (isConnected[i][j] == 1) {
                    int pi = i, pj = j;
                    while (father[pi] != pi) pi = father[pi];
                    while (father[pj] != pj)  pj = father[pj];
                    if (pi != pj) father[pj] = pi;
                }
            }
        }
        for (int i = 0; i < n; i++) {
            if (father[i] == i) ans ++;
        }
        return ans;
    }
}

// 用并查集模板
class Solution {
    public int[] father;
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        father = new int[n];
        int ans = 0;
        for (int i = 0; i < n; i++) {
            father[i] = i;  // 初始化 自己指向自己
        }
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (isConnected[i][j] == 1) {
                    int pi = i, pj = j;
                    if (find(pi) != find(pj)) {  // 分别找到pi和pj的根
                        union(pj, pi);  // 将pj的根连到pi的根
                    }
                }
            }
        }
        for (int i = 0; i < n; i++) {
            if (father[i] == i) ans ++;
        }
        return ans;
    }
    public int find(int a) {
        while (father[a] != a) a = father[a];
        return a;
    }
    public void union (int a, int b) {   // 将a的根节点挂到b的根节点上
        father[find(a)] = find(b); 
    }
}
~~~



### LC-[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

**方法一：DFS**

~~~java
class Solution {
    public int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    public int m, n;
    public int numIslands(char[][] grid) {
        m = grid.length;
        n = grid[0].length;
        int ans = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    ans ++;
                    dfs(grid, i, j);
                }
            }
        }
        return ans;
    }
    public void dfs(char[][] grid, int i, int j) {
        if (i < 0 || i > m - 1 || j < 0 || j > n - 1 || grid[i][j] == '0') return;
        grid[i][j] = '0';
        for (int[] dir : dirs) {
            int ii = i + dir[0], jj = j + dir[1];
            dfs(grid, ii, jj);
        }
    }
}
~~~



**方法二：并查集**

~~~java
class Solution {
    public int[] father;
    public int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    public int numIslands(char[][] grid) {
        int m = grid.length, n = grid[0].length;
        int ans = 0;
        father = new int[m * n];
        for (int i = 0; i < m * n; i++) father[i] = i;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    // 将周边的岛屿价格自己的连通集中
                    for (int[] dir : dirs) {
                        int ii = i + dir[0], jj = j + dir[1];
                        // 如果(ii, jj)左边不合法或者不是岛屿，跳过
                        if (ii < 0 || ii > m - 1 || jj < 0 || jj > n - 1 || grid[ii][jj] == '0') continue;
                        if (find(i * n + j) != find(ii * n + jj)) {
                            union(i * n + j, ii * n + jj);
                        }
                    }
                }
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1' && father[i * n + j] == i * n + j) {  // i * n + j
                    ans ++;
                }
            }
        }
        return ans;
    }
    public int find(int a) {
        while (father[a] != a) a = father[a];
        return a;
    }
    public void union(int a, int b) { //将b的根挂到a的根上
        father[find(b)] = find(a);
    }
}
~~~

>   (i, j)在father[]数组中对应的索引是 i * n + j



### LC-[684. 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)

-   思路：有n个节点，构成一棵树需要n - 1条边，实际给出n条边，意味着只有一条边是多余的。这条边不仅是多余的，而且加入后会导致树产生环路，变成图，因此只要找到某一条边，其连接的节点都已经属于同一连通集，由于edges中无重复边，所以这条边一定就是那个多余的、加入后会产生环路的边，即为所求。

~~~java
class Solution {
    public int[] father;
    public int[] findRedundantConnection(int[][] edges) {
        int n = edges.length;
        father = new int[n + 1];
        // int cnt = 1;
        // Set<int[]> set = new HashSet<>();
        for (int i = 0; i < n + 1; i++) {
            father[i] = i;
        }
        for (int[] edge : edges) {
            int i = edge[0], j = edge[1];
            if (find(i) != find(j)) {
                union(i, j);
                // cnt ++;
                // set.add(edge);
                // if (cnt == n) {
                    // break;
                // }
            } else {
                return edge;
            }
        }
        // for (int i = n - 1; i >= 0; i--) {
        //     if (!set.contains(edges[i])) {
        //         return edges[i];
        //     }
        // }
        return null;

    }
    public int find(int a) {
        while (father[a] != a) a = father[a];
        return a;
    }
    public void union(int a, int b) {
        father[find(b)] = find(a);
    }
}
~~~







## 滑动窗口

### LC-[209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

-   思路：双指针维护滑动窗口，初始时l，r都指向0处，但是设curSum为0，即每次r右移后，再把r之前指向的元素加入curSum，即curSum等于[l, r - 1]窗口内元素的和；不断将右指针向右移加入元素，直到窗口内元素内的和大于等于target。此时记录窗口的长度，需要的话进行更新，然后将左指针一直往右移动，直到curSum小于target，要注意的是每次移动后都要更新minLen的值！如此循环，直到右指针调到数组外面。 

~~~java
// 双指针维护滑动窗口  不断将右指针向右移，直到窗口内元素内的和大于等于target 
// 当curSum大于target时，记录当前窗口长度，然后将左指针不断向右移动，直到curSum小于target
// 方法二：curSum指的是[l,r-1]区间内的和 --> 先移动右指针，再和target比
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int l = 0, r = 0;
        int n = nums.length;
        int curSum = 0;
        int minLen = Integer.MAX_VALUE;
        while (r < n) {
            curSum += nums[r++];
            while (curSum >= target) {
                minLen = Math.min(minLen, r - l);
                curSum -= nums[l++];
            }
        }
        return minLen == Integer.MAX_VALUE ? 0 : minLen;
    }
}
// 方法二：curSum指的是[l,r]区间内的和  --> 先把第一个元素加入curSum   --> 先和target比，再决定是否移动左右指针
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int l = 0, r = 0;
        int n = nums.length;
        int curSum = nums[l];
        int minLen = Integer.MAX_VALUE;
        while (r < n) {
            while (curSum >= target) {
                minLen = Math.min(minLen, r - l + 1);
                curSum -= nums[l++];
            }
            r++;
            if (r < n) curSum += nums[r];
        }
        return minLen == Integer.MAX_VALUE ? 0 : minLen;
    }
}
~~~



### LC -[3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

~~~java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int l = 0, r = 0;
        int n = s.length();
        Map<Character, Integer> map = new HashMap<>();
        int maxLen = 0;
        while (r < n) {
            char c = s.charAt(r++);
            map.put(c, map.getOrDefault(c, 0) + 1);
            while (map.get(c) > 1) {
                char cc = s.charAt(l++); 
                map.put(cc, map.get(cc) - 1);
            }
            maxLen = Math.max(maxLen, r - l);
        }
        return maxLen;
    }
}
~~~



### LC-[1004. 最大连续1的个数 III](https://leetcode-cn.com/problems/max-consecutive-ones-iii/)

~~~java
class Solution {
    public int longestOnes(int[] nums, int k) {
        int l = 0, r = 0;
        int n = nums.length;
        int maxLen = 0;
        while (r < n) {
            // 三步走：先加入nums[r]到窗口(代码中无需体现)；再判断需不需要反转；再移动r
            if (nums[r++] == 0) k--;
            // k--;
            // 判断是否合法
            while (k < 0) {
                if (nums[l++] == 0) k++;
            }
            maxLen = Math.max(maxLen, r - l);
        }
        return maxLen;
    }
}
~~~



### LC-[1208. 尽可能使字符串相等](https://leetcode-cn.com/problems/get-equal-substrings-within-budget/)

~~~java
class Solution {
    public int equalSubstring(String s, String t, int maxCost) {
        int n = s.length();
        int l = 0, r = 0;
        int maxLen = 0;
        while (r < n) {
            maxCost -= Math.abs(s.charAt(r) - t.charAt(r));
            r++;
            while (maxCost < 0) {
                maxCost += Math.abs(s.charAt(l) - t.charAt(l));
                l++;
            }
            maxLen = Math.max(maxLen, r - l);
        }
        return maxLen;
    }
}
~~~





## 前缀和

### LC-[724. 寻找数组的中心下标](https://leetcode-cn.com/problems/find-pivot-index/)

~~~java
class Solution {
    public int pivotIndex(int[] nums) {
        int n = nums.length;
        if (n == 1) {
            return 0;
        }
        int[] preSum = new int[n + 1];
        preSum[0] = 0;
        // 将preSum[]长度设为n+1比较好，不然不好统一判断0号位置的前缀和
        for (int i = 1; i < n + 1; i++) {  // 第i个前缀和
            preSum[i] = preSum[i - 1] + nums[i - 1];
        }
        for (int i = 1; i < n + 1; i++) { //  第i个数
            if (preSum[i - 1] == preSum[n] - preSum[i]){
                return i - 1;
            }
        }
        return -1;
    }
}
~~~



### LC-[560. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

**方法一：前缀和**

~~~java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length;
        int[] preSum = new int[n + 1];
        preSum[0] = 0;
        Map<Integer, Integer> map = new HashMap<>(); 
        map.put(0, 1);
        int ans = 0;
        for (int i = 1; i < n + 1; i++) {
            preSum[i] = preSum[i - 1] + nums[i - 1];
            ans += map.getOrDefault(preSum[i] - k, 0);
            map.put(preSum[i], map.getOrDefault(preSum[i], 0) + 1);
        }
        return ans;
    }
}
~~~

>   这题滑动窗口做不了，因为有负值

### [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

~~~java
class Solution {
    public int ans = 0;
    public int curSum = 0;  // 前缀和
    public Map<Integer, Integer> map = new HashMap<>();  // 记录各个前缀和
    public int targetSum;
    public int pathSum(TreeNode root, int targetSum) {
        if (root == null) return 0;
        this.targetSum = targetSum;
        map.put(0, 1);  // 这里很重要，不然从根节点到叶子节点路径和刚好为target的话就无法作为正确答案加进去了。
        dfs(root);
        return ans;
    }
    public void dfs(TreeNode p) {
        if (p == null) return;
        curSum += p.val;
        ans += map.getOrDefault(curSum - targetSum, 0);
        map.put(curSum, map.getOrDefault(curSum, 0) + 1);
        dfs(p.left);
        dfs(p.right);
        map.put(curSum, map.get(curSum) - 1);
        curSum -= p.val;
    }
}
~~~

### [1248. 统计「优美子数组」](https://leetcode-cn.com/problems/count-number-of-nice-subarrays/)

**方法一：前缀和**

-   思路：前缀和数组统计到i为止奇数出现的次数。

~~~java
class Solution {
    public int numberOfSubarrays(int[] nums, int k) {
        int n = nums.length;
        int[] preSum = new int[n + 1];
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        int ans = 0;
        preSum[0] = 0;
        for (int i = 1; i < n + 1; i++) {
            preSum[i] = (nums[i - 1] % 2 == 0 ? 0 : 1) + preSum[i - 1];
            ans += map.getOrDefault(preSum[i] - k, 0);
            map.put(preSum[i], map.getOrDefault(preSum[i], 0) + 1);
        }
        return ans;
    }
}
~~~

**方法二：滑动窗口**

不合适

~~~


~~~









## 差分

~~~
// 对应关系  存储的时候都往后移动一位
sum: 0 1 2 3 4 5 6 7
sub: _ 0 1 2 3 4 5 6
num: _ 0 1 2 3 4 5 6
~~~

### LC-[1094. 拼车](https://leetcode-cn.com/problems/car-pooling/)

~~~java
class Solution {
    public boolean carPooling(int[][] trips, int capacity) {
        int[] preSum = new int[1010];
        int[] sub = new int[1010];
        preSum[0] = 0;
        for (int[] trip : trips) {
            int start = trip[1], end = trip[2];
            // 由于preSum[0]被设置成了0，作为占位的 所以sub和num都对应往后移动一位
            sub[start + 1] += trip[0];
            sub[end + 1] -= trip[0];
        }
        for (int i = 1; i < 1010; i++) {
            preSum[i] = preSum[i - 1] + sub[i];
            if (preSum[i] > capacity) return false;
        }
        return true;
    }
}
~~~

### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

**方法一：前缀和与差分**

-   思路：找到差距最大的左端点和右端点

    ​		  先从第二天开始算每天与前一天的差分值(因为第一天不可能卖出，所以不用算，diff[0]默认为0即可)，然后从第二天开始计算截止这一天的前缀和，意味着如果这一天卖出的话收益最大是多少，如果算出来的前缀和是负数，说明从前面任一天买入、今天卖出都是亏损的，没有意义，所以直接将该日期的前缀和设为0，同时也意味着这一天可以作为新的买入点。

~~~java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[] diff = new int[n];
        int ans = 0;
        int[] preSum = new int[n];
        for (int i = 1; i < n; i++) {
            diff[i] = prices[i] - prices[i - 1];
        }
        for (int i = 1; i < n; i++) {
            preSum[i] = Math.max(0, preSum[i - 1] + diff[i]);
            ans = Math.max(ans, preSum[i]);
        }
        return ans;
    }
}
~~~



### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

**方法一：前缀和+差分**

-   思路：找到每一段递增的区间

~~~java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[] diff = new int[n];
        int[] preSum = new int[n];
        int ans = 0;
        for (int i = 1; i < n; i++) {
            diff[i] = prices[i] - prices[i - 1];
        }
        for (int i = 1; i < n; i++) {
            if (diff[i] < 0) {
                ans += preSum[i - 1];
                preSum[i] = 0;
            } else {
                preSum[i] = preSum[i - 1] + diff[i];
            }
        }
        if (preSum[n - 1] > 0) ans += preSum[n - 1];
        return ans;
    }
}
~~~









## 拓扑排序

### LeetCode210

## 字符串

### LC-[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

~~~java
class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        int maxLen = 0;
        int[] ans = new int[2];
        for (int i = 0; i < n; i++) {
            int l, r;
            // 以一个元素为中心点扩展
            l = i; r = i;
            while (l >=0 && r < n && s.charAt(l) == s.charAt(r)) {
                if (r - l + 1 > maxLen) {
                    maxLen = r - l + 1;
                    ans[0] = l;
                    ans[1] = r;
                }
                l--;
                r++;
            }
            // 以两个元素为中心点扩展
            l = i; r = i + 1;
            while (l >=0 && r < n && s.charAt(l) == s.charAt(r)) {
                if (r - l + 1 > maxLen) {
                    maxLen = r - l + 1;
                    ans[0] = l;
                    ans[1] = r;
                }
                l--;
                r++;
            }
            
        }
        return s.substring(ans[0], ans[1] + 1);
    }
}
~~~



### LC-[20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

~~~java
class Solution {
    public boolean isValid(String s) {
        int n = s.length();
        Deque<Character> stack = new ArrayDeque<Character>();
        for (int i = 0; i < n; i++) {
            char ch = s.charAt(i);
            if (ch == '(' || ch == '{' || ch == '[') {
                stack.push(ch);
            } 
            if (stack.isEmpty()) return false;
            if (ch == ')') {
                if (stack.pop() != '(') return false;
            }
            if (ch == '}') {
                if (stack.pop() != '{') return false;
            }
            if (ch == ']') {
                if (stack.pop() != '[') return false;
            }
        }
        return stack.isEmpty();
    }
}
~~~



### LC-[43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)

**方法一：相乘-溢出**

~~~java
class Solution {
    public String multiply(String num1, String num2) {
        int n1 = num1.length(), n2 = num2.length();
        long sum = 0;
        for (int i = n2 - 1; i >= 0; i--) {  // num2
            long cur = 0L;
            int ch2 = Integer.parseInt(num2.charAt(i) + "");
            for (int j = n1 - 1; j >= 0; j--) {  // num1
                int ch1 = Integer.parseInt(num1.charAt(j) + "");
                long res =  ch2 * ch1;
                cur += (res * Math.pow(10, n1 - j - 1));
            }
            sum += cur * Math.pow(10, n2 - i - 1);
        }
        return sum + "";
    }
}
~~~

**方法二：逐位相乘后加到对应位置**

-   思路： 假设num1的长度为m, num2的长度为n, 那么num1*num2的乘积的长度最多是m + n; 逐位相加，num[i] * num2[j]的结果对应加到res[i+j, i+j+1]处，i+j+1是低位，所以先全都加到低位; 最后从低位往高位遍历，将低位“溢出”的部分进到高位。

<img src="alg-img/字符串相乘.png" width="600px">

~~~java
class Solution {
    public String multiply(String num1, String num2) {
        if (num2.equals("0") || num1.equals("0")) return "0";
        int m = num1.length(), n = num2.length();
        int[] res = new int[m + n];
        for (int i = 0; i < m; i++) {  // num1
            int ch1 = num1.charAt(i) - '0';
            for (int j = 0; j < n; j++) {
                int ch2 = num2.charAt(j) - '0';
                // num[i] * num2[j]的结果对应加到res[i+j, i+j+1]处，i+j+1是低位，所以先全都加到低位
                res[i + j + 1] += ch1 * ch2;
            }
        }
        for (int k = m + n - 1; k > 0; k--) {
            // 将低位超过10的部分进到高位
            res[k - 1] += res[k] / 10;
            res[k] = res[k] % 10;
        }
        StringBuffer sb = new StringBuffer();
        for (int k = 0; k < m + n; k++) {
            if (k == 0 && res[k] == 0) continue;
            sb.append(res[k]);
        }
        return sb.toString();
    }
}
~~~







### LC-[93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

-   思路：递归的去截取每一段地址，递归终止条件为字符串刚好用完且刚好是4段，将当前子串纳入path的条件是区间合法且子串符合作为ip地址一个字段的约束条件(即不能有前导0、大于等于0小于等于255)，

~~~java
class Solution {
    public List<String> res = new ArrayList<>();
    public List<String> restoreIpAddresses(String s) {
        int len = s.length();
        if (len < 4 || len > 12) return res;
        Deque<String> path = new ArrayDeque<>();
        dfs(s, 0, 4, path);
        return res;
    }
    public void dfs(String s, int begin, int remain, Deque<String> path) {
        int len = s.length();
        if (begin == len && remain == 0) {
            res.add(String.join(".", path));
            return;
        }
        // 当前字段左边界为begin，右边界可以是begin、begin+1、begin+2
        for (int end = begin; end < begin + 3; end++) {
            // 如果end越界了，[begin, end]这个区间无效，更大的区间更加无效，则以当前字段以begin作为左边界已经不会再有解了，所以直接break
            if (end > len - 1) break;
            // 如果索引合法且子串符合ip地址条件 纳入path并进行下一层递归
            if (isVaild(s, begin, end)) {
                path.offerLast(s.substring(begin, end + 1));
                // 当前字段找完了，递归去找下一个字段
                dfs(s, end + 1, remain - 1, path);
                path.pollLast();  // 回溯
            }
        }
    }
    // 检查s[l,r]是否可以作为ip地址的一个字段
    public boolean isVaild(String s, int left, int right) {
        int len = right - left + 1;
        // 不能字段长度大于1并且有前导0
        if (len > 1 && s.charAt(left) == '0') return false;
        int num = Integer.parseInt(s.substring(left, right + 1));
        // 范围要合法
        return num >= 0 && num <= 255;  
    }
}
~~~







## 二分查找

### LC-[33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

-   思路：先用二分查找到最小值的位置，然后确定target所在的区间，再对小区间做二分查找。

~~~java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        if (n == 1) return nums[0] == target ? 0 : -1;
        int l = 0, r = n - 1;
        while (l < r) {
            int mid = l + ((r - l) >> 1);
            if (nums[mid] > nums[r]) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        // l是最小值的索引
        int ll, rr;
        if (target <= nums[n - 1]) {
            ll = l;
            rr = n - 1;
        } else {
            ll = 0;
            rr = l - 1;
        }
        while (ll <= rr) {
            int mid = ll + ((rr - ll) >> 1);
            if (nums[mid] == target) return mid;
            if (nums[mid] > target) rr = mid - 1;
            else ll = mid + 1;
        }
        return -1;
    }
    // 前面的是可以排除
    public boolean check(int[] nums, int mid, int l, int r) {
        return nums[mid] > nums[r];
    }
}
~~~



### LC-[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

~~~java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int n = nums.length;
        if (n == 0) return new int[]{-1,-1};
        int l = 0, r = n - 1;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] < target) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        if (nums[l] != target) {
            return new int[]{-1,-1};
        }
        int ll = 0, rr = n - 1;
        while (ll < rr) {
            int mid = ll + (rr - ll + 1) / 2;
            if (nums[mid] > target) {
                rr = mid - 1;
            } else {
                ll = mid;
            }
        }
        if (nums[ll] != target) {
            return new int[]{-1,-1};
        }
        return new int[]{l, ll};
    }
}
// 优美版：
class Solution {
    public int[] searchRange(int[] nums, int target) {
        if (nums.length == 0) return new int[]{-1, -1};
        return new int[]{bsearch1(nums, target), bsearch2(nums, target)};
    }
    public int bsearch1(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if ( nums[mid] < target ) l = mid + 1;  // 前面肯定没问题
            else r = mid;  
        }
        return nums[l] == target ? l : -1;
    }
    public int bsearch2(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while (l < r) {
            int mid = l + (r - l + 1) / 2;
            if (nums[mid] <= target) l = mid;  
            else r = mid - 1;    // 后面肯定没问题  nums[mid] > target
        }
        return nums[l] == target ? l : -1;
    }
    public boolean check(int[] nums, int mid) {
        return nums[mid] > nums[nums.length - 1];  // mid及其前面肯定没问题
    }
}
~~~



## BFS

### [127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)

**方法一：单向BFS**

~~~java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> set = new HashSet<>();
        for (String s : wordList) {
            set.add(s);
        }
        Deque<String>  qu = new ArrayDeque<>();
        qu.offer(beginWord);
        int dist = 0;
        while (!qu.isEmpty()) {
            int size = qu.size();
            dist ++;
            for (int i = 0; i < size; i++) {
                String curWord = qu.poll();
                // System.out.print(dist + ":" + curWord + ":");
                if (curWord.equals(endWord)) {
                    return dist;
                }
                char[] curWordArr = curWord.toCharArray();
                for (int j = 0; j < curWordArr.length; j++) {
                    char pre = curWordArr[j];
                    for (char c = 'a'; c <= 'z'; c++) {
                        curWordArr[j] = c;
                        String tmp = new String(curWordArr);
                        // System.out.print(tmp + " ");
                        if (set.contains(tmp)) {
                            // System.out.print(tmp + " ");
                            qu.offer(tmp);
                            set.remove(tmp);
                        }
                    }
                    curWordArr[j] = pre;
                }
                // System.out.println();
            }
        }
        return 0;
    }
}
~~~

**方向二：双向BFS**

~~~java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        if (!wordList.contains(endWord)) return 0;
        Set<String> set = new HashSet<>(wordList);
        Set<String> visitedL = new HashSet<>();
        Set<String> visitedR = new HashSet<>();
        Deque<String>  quL = new ArrayDeque<>();
        Deque<String>  quR = new ArrayDeque<>();
        quL.offer(beginWord);
        quR.offer(endWord);
        visitedL.add(beginWord);
        visitedR.add(endWord);
        int dist = 1;
        while (!quL.isEmpty() && !quR.isEmpty()) {
            if (quL.size() > quR.size()) {
                Deque<String> quTemp = quL;
                quL = quR;
                quR = quTemp;
                Set<String>  visTemp = visitedL;
                visitedL = visitedR;
                visitedR = visTemp;
            }
            int size = quL.size();
            for (int i = 0; i < size; i++) {
                String curWord = quL.poll();
                char[] curWordArr = curWord.toCharArray();
                for (int j = 0; j < curWordArr.length; j++) {
                    char pre = curWordArr[j];
                    for (char c = 'a'; c <= 'z'; c++) {
                        curWordArr[j] = c;
                        String tmp = new String(curWordArr);
                        if (!set.contains(tmp)) continue;
                        if (visitedL.contains(tmp)) continue;
                        if (visitedR.contains(tmp)) {
                            return dist + 1;
                        }
                        quL.offer(tmp);
                        visitedL.add(tmp);
                    }
                    curWordArr[j] = pre;
                }
            }
            dist ++;
        }
        return 0;

    }
}
~~~



### [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

**方法一：BFS**

~~~java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        int n = s.length();
        Set<String> wordSet = new HashSet<>(wordDict);
        Set<String> visited = new HashSet<>();
        Deque<String> queue = new ArrayDeque<>();
        for (String str : wordDict) {
            if (str.length() > s.length()) continue;
            if (!s.substring(0, str.length()).equals(str)) continue;
            if (visited.contains(str)) continue;
            queue.offer(str);
        }
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                String curString = queue.poll();  // leet code
                if (visited.contains(curString)) continue;
                visited.add(curString);
                System.out.println(curString);
                if (s.equals(curString)) return true;
                for (String str : wordDict) {
                    System.out.println(str);
                    String newString = curString + str;
                    if (newString.length() > s.length()) continue;
                    if (!s.substring(0, newString.length()).equals(newString)) continue;
                    queue.offer(newString);
                }
            }
        }
        return false;
    }
}
~~~





### [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)

**方法一：DFS**

~~~java
class Solution {
    public int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    public int[][] visited;
    public void solve(char[][] board) {
        int m = board.length, n = board[0].length;
        visited = new int[m][n];
        for (int i = 0; i < m; i++) {
            if (board[i][0] == 'O') dfs(board, i , 0);
            if (board[i][n - 1] == 'O') dfs(board, i , n - 1);
        }
        for (int j = 1; j < n - 1; j++) {
            if (j < n && board[0][j] == 'O') dfs(board, 0, j);
            if (j < n && board[m - 1][j] == 'O') dfs(board, m - 1, j);
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == 'O') board[i][j] = 'X';
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == 'A') board[i][j] = 'O';
            }
        }
    }
    public void dfs(char[][] board, int i, int j) {
        int m = board.length, n = board[0].length;
        if (i < 0 || i > m - 1 || j < 0 || j > n - 1 || board[i][j] == 'X' || visited[i][j] == 1) {
            return;
        }
        board[i][j] = 'A';
        visited[i][j] = 1;
        for (int[] dir : dirs) {
            int ii = i + dir[0], jj = j + dir[1];
            dfs(board, ii, jj);
        }
    }
}
~~~



### [529. 扫雷游戏](https://leetcode-cn.com/problems/minesweeper/)

**方法一：BFS**

~~~java
class Solution {
    public char[][] updateBoard(char[][] board, int[] click) {
        int m = board.length, n = board[0].length;
        int[][] visited = new int[m][n];
        // System.out.println(m * n);
        int r = click[0], c = click[1];
        if (board[r][c] == 'M') {
            board[r][c] = 'X';
            return board;
        }
        if (board[r][c] == 'B' || board[r][c] == 'X') return board;
        if (board[r][c] == 'E') {
            visited[r][c] = 1;
            Deque<int[]> qu  = new ArrayDeque<>();
            qu.offer(new int[]{r, c});
            int[][] dirs = {{-1,0},{1, 0},{0, -1},{0, 1},{-1, -1},{-1, 1},{1,-1},{1,1}};
            while (!qu.isEmpty()) {
                int size = qu.size();
                for (int i = 0; i < size; i++) {
                    int[] cur = qu.poll();
                    int cur_r = cur[0], cur_c = cur[1];
                    int cnt = 0;  // 炸弹数量
                    Deque<int[]> neiEmpty  = new ArrayDeque<>();
                    for (int[] dir : dirs) {
                        int ne_r = cur_r + dir[0], ne_c = cur_c + dir[1];
                        if (ne_r < 0 || ne_r > m - 1 || ne_c < 0 || ne_c > n - 1) continue;
                        if (board[ne_r][ne_c] == 'M') cnt ++;
                        if (visited[ne_r][ne_c] == 1) continue;
                        visited[ne_r][ne_c] = 1;
                        if (board[ne_r][ne_c] == 'E') {
                            neiEmpty.offer(new int[]{ne_r, ne_c});
                        }
                    }
                    if (cnt > 0) {
                        board[cur_r][cur_c] = (char)('0' + cnt);  //（char）(n + '0')
                        for (int[] nei : neiEmpty) {
                            visited[nei[0]][nei[1]] = 0;  // 回溯！！！！！
                        }
                    }
                    else {
                        qu.addAll(neiEmpty);
                        board[cur_r][cur_c] = 'B';
                    }
                }
            }
        }
        return board;
    }
}
~~~



### 815(hard)

## DFS&回溯

### LC-[78. 子集](https://leetcode-cn.com/problems/subsets/)

~~~java
class Solution {
    public List<List<Integer>> res;
    public List<List<Integer>> subsets(int[] nums) {
        res = new ArrayList<>();
        res.add(new ArrayList<>());
        for (int i = 0; i < nums.length; i++) {
            dfs(nums, i, new ArrayList<>());
        }
        return res;
    }
    // 将第i个加入到路径中
    public void dfs(int[] nums, int i, List<Integer> path) {
        if (i == nums.length) return;
        path.add(nums[i]);
        res.add(new ArrayList(path));
        for (int j = i + 1; j < nums.length; j++) {
            dfs(nums, j, path);
        }
        path.remove(path.size() - 1);
    }
}
~~~



### LC-[934. 最短的桥](https://leetcode-cn.com/problems/shortest-bridge/)


~~~java
class Solution {
    public int[][] dirs = {{-1, 0},{1, 0},{0, -1},{0, 1}};
    public Deque<int[]> qu = new ArrayDeque<>();
    public int[][] visited;
    public int shortestBridge(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        visited = new int[m][n];
        flag:for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    dfs(grid, i, j);
                    break flag;
                }
            }
        }
        int len = 0;
        while (!qu.isEmpty()) {
            int size = qu.size();
            for (int i = 0; i < size; i++) {
                int[] cur = qu.poll();
                for (int[] dir : dirs) {
                    int ii = cur[0] + dir[0], jj = cur[1] + dir[1];
                    if (ii < 0 || ii > m - 1 || jj < 0 || jj > n - 1 || visited[ii][jj] == 1 || grid[ii][jj] == 2 ) continue;
                    if (grid[ii][jj] == 1) return len;
                    qu.offer(new int[]{ii, jj});
                    visited[ii][jj] = 1;  // !!!!!
                }
            }
            len ++;
        }
        return 1;
    }
    public void dfs(int[][] grid, int i, int j) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || i > m - 1 || j < 0 || j > n - 1 || grid[i][j] != 1) return;
        grid[i][j] = 2;
        qu.offer(new int[]{i, j});
        visited[i][j] = 1;
        for (int[] dir : dirs) {
            int ii = i + dir[0], jj = j + dir[1];
            dfs(grid, ii, jj);
        }
    }
}
~~~





### 685(hard)

### 1102（会员）

### 531（会员）

### 533 （会员）

### LC-[113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

~~~java
class Solution {
    public List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        if (root == null) return res;
        Deque<Integer> path = new ArrayDeque<>();
        dfs(root, targetSum, path);
        return res;
    }
    public void dfs(TreeNode root, int target, Deque path) {
        if (root == null) return;
        path.offerLast(root.val);
        if (root.left == null && root.right == null && target == root.val) {
            res.add(new ArrayList(path));
        }
        dfs(root.left, target - root.val, path);
        dfs(root.right, target - root.val, path);
        path.pollLast();
    }
}
~~~



### 332(hard)

### LC [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

~~~java
class Solution {
    public Map<TreeNode, Integer> memo0 = new HashMap<>();
    public Map<TreeNode, Integer> memo1 = new HashMap<>();
    public int rob(TreeNode root) {
        return Math.max(dfs(root, 1), dfs(root, 0));
    }
    public int dfs(TreeNode root, int flag) {
        if (root == null) return 0;
        if (flag == 0) {  // 当前节点不给偷 子节点可以偷也可以不偷
            if (memo0.containsKey(root)) return memo0.get(root);
            int res = Math.max(dfs(root.left, 1), dfs(root.left, 0)) + Math.max(dfs(root.right, 1), dfs(root.right, 0));
            memo0.put(root, res);
            return res;
        } else {  // 当前节点偷了 子节点不能偷
            if (memo1.containsKey(root)) return memo1.get(root);
            int res = dfs(root.left, 0) + dfs(root.right, 0) + root.val;
            memo1.put(root, res);
            return res;
        }
    }
}
~~~





## 动态规划

### LC-[213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

**方法一：分情况讨论**

~~~java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) return nums[0];
        if (n == 2) return Math.max(nums[0], nums[1]);
        //递推公式：dp[n] = max(            dp[n - 1],               dp[n - 2] + num[n])
        //                    n不取,其最大值就等于n-1最大值    n取,n-1就不能取,其最大值等于n-2的最大值就是本身
        // 1. num[0]不取  num[n-1]可以随便取不取
        int[] dp0 = new int[n], dp1 = new int[n];
        dp0[0] = 0; 
        dp0[1] = nums[1];
        for (int i = 2; i < n; i++) {
            dp0[i] = Math.max(dp0[i - 1], dp0[i - 2] + nums[i]);
        }
        // 2. num[0]取 那么num[n-1]就一定不能取 所以dp[n-1]就等于dp[n-2]
        dp1[0] = nums[0];
        dp1[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < n - 1; i++) {
            dp1[i] = Math.max(dp1[i - 1], dp1[i - 2] + nums[i]);
        }
        dp1[n - 1] = dp1[n - 2];
        return Math.max(dp0[n - 1], dp1[n - 1]);
    }
}
~~~

### 对比：LC-[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

~~~java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) return nums[0];
        if (n == 2) return Math.max(nums[0], nums[1]);
        int[] dp = new int[n];
        int res = 0;
        dp[0] = 0;
        dp[1] = nums[1];
        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        res = dp[n - 1];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        res = Math.max(res, dp[n - 1]);
        return res;
    }
}
~~~



### 123（hard）

### LC-[62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

~~~java
class Solution {
    public int uniquePaths(int m, int n) {
        // dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        if (m == 1 || n == 1) return 1;
        int[][] dp = new int[m][n];
        // dp[0][0] = 1;
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
~~~



### LC-[63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

~~~java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length, n = obstacleGrid[0].length;
        if (m == 1 && n == 1) return 1 - obstacleGrid[0][0];
        if (obstacleGrid[0][0] == 1 || obstacleGrid[m-1][n-1] == 1) return 0;
        int[][] dp = new int[m][n];
        dp[0][0] = 1;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 && j == 0) continue;
                if (obstacleGrid[i][j] == 1) dp[i][j] = 0;
                else {
                    int up = i - 1 >= 0 ? dp[i - 1][j] : 0;
                    int left = j - 1 >= 0 ? dp[i][j - 1] : 0;
                    dp[i][j] = up + left;
                }
            }
        }
        return dp[m - 1][n - 1];
    }
}
~~~



### 361(会员)

### 1230(会员)

### LC-[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

-   思路：设dp[i]表示以num[i]结尾的最长递增子序列的长度，将dp[0~n-1]都初始化为1，因为最短长度也是一个元素本身；然后去遍历他前面的所有元素，找到某个元素严格小于num[i]并且使得dp[i]最大，递推公式为：`dp[i] = max(dp[i], dp[0], dp[1]...dp[i - 1])`。

~~~java
// 优化写法：
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        if (n == 1) return 1;
        int[] dp = new int[n];
        for (int i = 0; i < n; i++) dp[i] = 1;
        int maxLen = 1;
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);       
                }
            }
            maxLen = Math.max(maxLen, dp[i]);
        }
        return maxLen;
    }
}
// 第一版：
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        if (n == 1) return 1;
        int[] dp = new int[n];
        dp[0] = 1;  // 应该是将所有元素的dp值都初始化为1！！
        int maxLen = 1;
        for (int i = 1; i < n; i++) {
            int pre = i - 1;
            while (pre >= 0) {
                if (nums[pre] < nums[i]) {
                    dp[i] = Math.max(dp[i], dp[pre] + 1);
                } else dp[i] = Math.max(dp[i], 1);  // 没有初始化1导致了这里的特殊处理
                pre--;
            }
            maxLen = Math.max(maxLen, dp[i]);
        }
        return maxLen;
    }
}
~~~



## 贪心算法

### LC-[55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

**方法一：BFS**

~~~java
class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;
        if (n == 1) return true;
        Deque<Integer> qu = new ArrayDeque<>();
        qu.offer(0);
        int[] visited = new int[n];
        visited[0] = 1;
        while (!qu.isEmpty()) {
            int size = qu.size();
            for (int i = 0; i < size; i++) {
                int idx = qu.poll();  // 0
                int step = nums[idx];  // 2
                for (int k = 1; k <= step; k++) {
                    int next = idx + k;
                    if (next == n - 1) return true;
                    if (visited[next] == 1) continue;
                    qu.offer(next);
                    visited[next] = 1;
                }
            }
        }
        return false;
    }
}
~~~



### 对比 LC-[45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

~~~java
class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        if (n == 1) return 0;
        Deque<Integer> qu = new ArrayDeque<>();
        qu.offer(0);
        int[] visited = new int[n];
        visited[0] = 1;
        int cnt = 0;
        while (!qu.isEmpty()) {
            int size = qu.size();
            for (int i = 0; i < size; i++) {
                int idx = qu.poll();
                int step = nums[idx];
                for (int k = 1; k <= step; k++) {
                    int next = idx + k;
                    if (next == n - 1) {
                        return cnt + 1;
                    }
                    if (visited[next] == 1) continue;
                    qu.offer(next);
                    visited[next] = 1;
                }
            }
            cnt++;
        }
        return 0;
    }
}
~~~



### LC-[435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

**方法一：堆排序**

~~~java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        if (intervals.length == 1) return 0;
        Queue<Integer[]> heap = new PriorityQueue<>((o1, o2) -> (o1[0] - o2[0]));
        for (int[] tmp : intervals) heap.offer(new Integer[]{tmp[0], tmp[1]});
        int left = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
        int cnt = 0;
        while(!heap.isEmpty()) {
            Integer[] cur = heap.poll();
            int curL = cur[0], curR = cur[1];
            // 整个新区间都在已合并区间右边
            if (curL >= right) {
                left = curL;
                right = curR;
            } 
            // 左区间在已合并区间内部
            else {
                if (curR <= right) {
                    left = curL;
                    right = curR;
                }
                cnt ++;  // 丢弃
            }
        }
        return cnt;
    }
}
// 5.25%
~~~

**方法二：数组排序**

~~~java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        if (intervals.length == 1) return 0;
        Arrays.sort(intervals, (o1, o2) -> (o1[0] - o2[0]));
        int left = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
        int cnt = 0;
        for (int[] cur : intervals) {
            int curL = cur[0], curR = cur[1];
            // 整个新区间都在已合并区间右边
            if (curL >= right) {
                left = curL;
                right = curR;
            } 
            // 左区间在已合并区间内部
            else {
                if (curR <= right) {
                    left = curL;
                    right = curR;
                }
                cnt ++;  // 丢弃
            }
        }
        return cnt;
    }
}
~~~



### 621

### 452

## 字典树

### LeetCode820

### 208

### 648







1811 面试官







# SQL

## LC-175 组合两个表

~~~sql
select P.firstName, P.lastName, A.city, A.state from Person P left join Address A on P.personId=A.personId;
~~~

>   1）左联结（left join），联结结果保留左表的全部数据
>
>   2）右联结（right join），联结结果保留右表的全部数据
>
>   3）内联结（inner join），取两表的公共数

## LC-[176. 第二高的薪水](https://leetcode-cn.com/problems/second-highest-salary/)

~~~sql
select ifNull(
    (select distinct salary from Employee order by salary desc limit 1,1), null
) as SecondHighestSalary;
~~~

>   ```sql
>   # limit n, 1,代表从第n条数据开始查询，1代表查询的条数（只查询一条）
>   # limit 0,1 其实就代表查询第一条数据
>   # limit 1,1 其实就代表查询第二条数据
>   # limit 1 offset 1:limit后面的数字是查询几条数据，offset后面的数据是从哪条数据开始查询
>   # limit 2 offerset 3:也就是查询4和5这两条数据
>   ```



## LC-[177. 第N高的薪水](https://leetcode-cn.com/problems/nth-highest-salary/)

~~~sql
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
set N = N - 1;
  RETURN (
      # Write your MySQL query statement below.
      select ifNull(
          (select distinct salary from Employee order by salary desc limit N,1), null
      ) as getNthHighestSalary 
  );
END
~~~

>   LIMIT里面不能做运算，所以要处理下N的值











